1
00:00:00,000 --> 00:00:06,120
I guess one thing I I am the rest of the

2
00:00:03,030 --> 00:00:08,250
staff request is that you whenever you

3
00:00:06,120 --> 00:00:10,889
have a question you first read the book

4
00:00:08,250 --> 00:00:13,769
and then you reread the assignment and

5
00:00:10,889 --> 00:00:16,560
you maybe reread it again and then you

6
00:00:13,769 --> 00:00:18,840
ask us because a lot of the questions

7
00:00:16,560 --> 00:00:21,930
we're getting are ones where we just say

8
00:00:18,840 --> 00:00:24,600
look at this page of the book look at

9
00:00:21,930 --> 00:00:27,269
this paragraph of the assignment look at

10
00:00:24,600 --> 00:00:31,980
this part of the file that you were

11
00:00:27,269 --> 00:00:34,590
given and so I mean there's a lot of

12
00:00:31,980 --> 00:00:36,899
stuff and I understand how sometimes

13
00:00:34,590 --> 00:00:39,390
it's easy to miss things so not saying

14
00:00:36,899 --> 00:00:41,520
don't ever ask questions but just before

15
00:00:39,390 --> 00:00:44,430
you ask your questions trying to figure

16
00:00:41,520 --> 00:00:47,039
out if I really should have come through

17
00:00:44,430 --> 00:00:48,989
the resources I have available to see if

18
00:00:47,039 --> 00:00:55,770
the answer to my question is can be

19
00:00:48,989 --> 00:00:57,930
found there so anyways enjoy the web so

20
00:00:55,770 --> 00:01:01,500
today is a sort of second part of a

21
00:00:57,930 --> 00:01:03,769
two-part lecture on integers and integer

22
00:01:01,500 --> 00:01:07,500
arithmetic last time we looked at

23
00:01:03,769 --> 00:01:11,580
representations about how bit patterns

24
00:01:07,500 --> 00:01:13,830
can be interpreted as either unsigned

25
00:01:11,580 --> 00:01:19,080
numbers meaning they range between zero

26
00:01:13,830 --> 00:01:21,150
and two to the word size minus one or as

27
00:01:19,080 --> 00:01:24,240
two's complement numbers which is the

28
00:01:21,150 --> 00:01:25,890
most compliment you away to represent

29
00:01:24,240 --> 00:01:27,900
what are sometimes called signed numbers

30
00:01:25,890 --> 00:01:30,420
ones it can be their negative or

31
00:01:27,900 --> 00:01:32,340
positive and by the way there are other

32
00:01:30,420 --> 00:01:35,930
ways to represent signed numbers out

33
00:01:32,340 --> 00:01:38,759
there but tooth complemented so so

34
00:01:35,930 --> 00:01:42,450
overwhelmingly the most used system that

35
00:01:38,759 --> 00:01:45,020
that's what we concentrate on today what

36
00:01:42,450 --> 00:01:47,250
we'll do is now go beyond the

37
00:01:45,020 --> 00:01:49,619
representations of these values to talk

38
00:01:47,250 --> 00:01:53,549
about arithmetic operations on them and

39
00:01:49,619 --> 00:01:55,530
some of their properties and what we'll

40
00:01:53,549 --> 00:01:58,140
do in general we talk about the unsigned

41
00:01:55,530 --> 00:02:00,360
case which is in some ways easier to

42
00:01:58,140 --> 00:02:03,000
understand and more intuitive and then

43
00:02:00,360 --> 00:02:06,299
talk about the two's complement case so

44
00:02:03,000 --> 00:02:11,430
the basic rule on this is if you take

45
00:02:06,299 --> 00:02:13,780
two numbers that range between up to the

46
00:02:11,430 --> 00:02:16,540
maximum value of an unsigned number

47
00:02:13,780 --> 00:02:19,540
add them but in principle you might need

48
00:02:16,540 --> 00:02:21,550
to get an extra bit to represent that

49
00:02:19,540 --> 00:02:23,950
thumb if you want to represent the true

50
00:02:21,550 --> 00:02:24,810
some sort of integer sum of those two

51
00:02:23,950 --> 00:02:27,160
numbers

52
00:02:24,810 --> 00:02:30,100
because you're doubling it and

53
00:02:27,160 --> 00:02:32,400
unfortunately we can't just go out and

54
00:02:30,100 --> 00:02:35,770
add more bits to your computer

55
00:02:32,400 --> 00:02:39,670
indefinitely so we just stop it at some

56
00:02:35,770 --> 00:02:41,920
point and say well whatever bit happened

57
00:02:39,670 --> 00:02:43,720
to be in that sort of next / bit

58
00:02:41,920 --> 00:02:46,239
position we're just going to drop it and

59
00:02:43,720 --> 00:02:48,190
pretend it doesn't exist and say that

60
00:02:46,239 --> 00:02:51,790
the result of addition is just whatever

61
00:02:48,190 --> 00:02:55,090
the W bit pattern you get if you only

62
00:02:51,790 --> 00:03:00,010
consider the first W bits out of it with

63
00:02:55,090 --> 00:03:01,989
no warning no messages no error or

64
00:03:00,010 --> 00:03:07,750
anything this is just it happens

65
00:03:01,989 --> 00:03:12,400
silently so for at each compliment this

66
00:03:07,750 --> 00:03:14,530
is not such a hard thing to understand

67
00:03:12,400 --> 00:03:17,470
it can be thought of as just modular

68
00:03:14,530 --> 00:03:19,690
arithmetic computing modulo the two to

69
00:03:17,470 --> 00:03:21,430
the word size and so I'm going to use

70
00:03:19,690 --> 00:03:22,900
some examples and this time I've got

71
00:03:21,430 --> 00:03:26,709
them worked out a little more carefully

72
00:03:22,900 --> 00:03:29,350
so I will get mixed up as much and we'll

73
00:03:26,709 --> 00:03:32,560
use the word size of four here and as I

74
00:03:29,350 --> 00:03:34,989
mentioned last time it really helps with

75
00:03:32,560 --> 00:03:38,170
this to work do the examples with small

76
00:03:34,989 --> 00:03:40,709
word sizes to get a your intuition for

77
00:03:38,170 --> 00:03:43,720
it rather than trying to write out

78
00:03:40,709 --> 00:03:45,670
32-bit numbers or 64-bit numbers or

79
00:03:43,720 --> 00:03:53,019
something like that so if you think

80
00:03:45,670 --> 00:03:57,670
about in the unsigned case a 4-bit

81
00:03:53,019 --> 00:04:03,070
number means that it will range between

82
00:03:57,670 --> 00:04:06,900
0 and 2 to the 4th minus 1 or 15 right

83
00:04:03,070 --> 00:04:11,370
and so let's just do a few examples of

84
00:04:06,900 --> 00:04:16,230
cases where it overflows so if you add

85
00:04:11,370 --> 00:04:16,230
13 to 5

86
00:04:20,009 --> 00:04:24,970
first of all you know I assume already

87
00:04:23,110 --> 00:04:28,449
that you just add binary numbers the way

88
00:04:24,970 --> 00:04:30,250
you learned in school of just doing

89
00:04:28,449 --> 00:04:36,479
carries and so forth except it's all

90
00:04:30,250 --> 00:04:41,650
modulo two so this is zero carry one one

91
00:04:36,479 --> 00:04:44,500
zero carry one zero carry one

92
00:04:41,650 --> 00:04:48,630
so in principle to represent the sum

93
00:04:44,500 --> 00:04:52,840
which is this is five so to represent 18

94
00:04:48,630 --> 00:04:54,639
you need five bits not four but we're

95
00:04:52,840 --> 00:04:58,860
just going to conveniently drop that

96
00:04:54,639 --> 00:05:03,780
number and say that this is actually 2

97
00:04:58,860 --> 00:05:06,490
which of course is what 18 module 16 is

98
00:05:03,780 --> 00:05:13,870
so the unsigned case is really pretty

99
00:05:06,490 --> 00:05:16,780
straightforward and we can visualize

100
00:05:13,870 --> 00:05:21,550
this in this pictures in the book too by

101
00:05:16,780 --> 00:05:25,229
saying if you are representing on the X

102
00:05:21,550 --> 00:05:28,449
and y axis what they call U and V are

103
00:05:25,229 --> 00:05:30,699
values between 0 and 15 the range of

104
00:05:28,449 --> 00:05:32,440
possible unsigned numbers and if we're

105
00:05:30,699 --> 00:05:37,150
going to add those we could get a sum

106
00:05:32,440 --> 00:05:39,960
that up to as much as 30 which would in

107
00:05:37,150 --> 00:05:42,870
principle require 5 bits to represent

108
00:05:39,960 --> 00:05:45,250
but what we'll do is we'll just by

109
00:05:42,870 --> 00:05:48,099
dropping that most significant bit what

110
00:05:45,250 --> 00:05:52,270
we do is to create a clip that when you

111
00:05:48,099 --> 00:05:54,639
roll over from 15 to 16 instead it drops

112
00:05:52,270 --> 00:05:58,720
all the way down to 0 and that's

113
00:05:54,639 --> 00:06:00,849
referred to as an overflow and then from

114
00:05:58,720 --> 00:06:05,080
there we'll build up to the maximum

115
00:06:00,849 --> 00:06:08,020
value here will be 14 which is 30 minus

116
00:06:05,080 --> 00:06:10,930
16 so what we've done is basically as

117
00:06:08,020 --> 00:06:14,169
this picture shows when we overflow we

118
00:06:10,930 --> 00:06:17,580
effectively subtract off 2 to the W from

119
00:06:14,169 --> 00:06:21,400
the sum and keep it within the

120
00:06:17,580 --> 00:06:26,440
representable range of W bit numbers so

121
00:06:21,400 --> 00:06:28,510
that's untimed two's complement once the

122
00:06:26,440 --> 00:06:30,830
first thing I want to convince you of is

123
00:06:28,510 --> 00:06:36,110
that two's complement addition

124
00:06:30,830 --> 00:06:40,300
looks just like a regular edition in

125
00:06:36,110 --> 00:06:43,190
other words I can perform a subtraction

126
00:06:40,300 --> 00:06:45,440
and addition of subtraction of numbers

127
00:06:43,190 --> 00:06:47,740
by using this tooth compliment

128
00:06:45,440 --> 00:06:50,600
representation for negative numbers so

129
00:06:47,740 --> 00:06:59,150
well let me just show you some examples

130
00:06:50,600 --> 00:07:01,100
of that so first of all remember that

131
00:06:59,150 --> 00:07:02,960
what range of values what's the smallest

132
00:07:01,100 --> 00:07:06,050
number that could be represented with a

133
00:07:02,960 --> 00:07:11,050
four bit the most negative number four

134
00:07:06,050 --> 00:07:18,770
bit two's complement number minus eight

135
00:07:11,050 --> 00:07:23,050
and the largest plus seven thank you so

136
00:07:18,770 --> 00:07:23,050
let's just do some examples if we took

137
00:07:25,840 --> 00:07:35,630
this number 1 1 0 1 as the two's

138
00:07:31,760 --> 00:07:44,530
complement number is minus 3 and we add

139
00:07:35,630 --> 00:07:44,530
it to 5 we'll get what we got before

140
00:07:51,000 --> 00:07:54,960
and we're not good at we're going to

141
00:07:52,800 --> 00:07:59,070
ignore whatever carry bid it is and so

142
00:07:54,960 --> 00:08:02,340
the result is - I'm going behold that's

143
00:07:59,070 --> 00:08:06,510
what five minus three is so it seems

144
00:08:02,340 --> 00:08:07,980
like magic because it is Tuesday and

145
00:08:06,510 --> 00:08:09,900
that's why part of the reason why I

146
00:08:07,980 --> 00:08:11,880
choose complement is to the most

147
00:08:09,900 --> 00:08:14,730
commonly used way of representing signed

148
00:08:11,880 --> 00:08:18,200
numbers because the same hardware the

149
00:08:14,730 --> 00:08:22,140
same algorithms that are used for doing

150
00:08:18,200 --> 00:08:33,180
addition in work for either unsigned or

151
00:08:22,140 --> 00:08:37,800
two's complement numbers and this works

152
00:08:33,180 --> 00:08:41,370
as well just to show you if the overflow

153
00:08:37,800 --> 00:08:48,210
goes if the resulting film is goes the

154
00:08:41,370 --> 00:08:54,080
other way so if I have minus 3 and minus

155
00:08:48,210 --> 00:08:54,080
5 and plus 3 and I add those together

156
00:09:02,680 --> 00:09:13,990
I'll get 1 1 1 0 which is minus 2 so

157
00:09:10,310 --> 00:09:18,110
again if you use the same patterns for

158
00:09:13,990 --> 00:09:20,660
the same rule for addition as you do

159
00:09:18,110 --> 00:09:24,800
with an unsigned case you'll get two

160
00:09:20,660 --> 00:09:28,250
complementary rhythm so let's look at a

161
00:09:24,800 --> 00:09:39,280
few cases where the two's complement

162
00:09:28,250 --> 00:09:39,280
overflows so if we take 3

163
00:09:44,920 --> 00:10:00,879
and -6 and we add them together we'll

164
00:09:57,429 --> 00:10:08,919
get one one one zero we're going to drop

165
00:10:00,879 --> 00:10:11,129
off the carry which is what seven so

166
00:10:08,919 --> 00:10:13,359
we've added two negative numbers and

167
00:10:11,129 --> 00:10:15,429
it's become positive

168
00:10:13,359 --> 00:10:24,699
and that's referred to as a negative

169
00:10:15,429 --> 00:10:28,179
overflow and the reason of course is the

170
00:10:24,699 --> 00:10:35,109
number minus nine can't be represented

171
00:10:28,179 --> 00:10:39,970
in a 4-bit to compliment number so it

172
00:10:35,109 --> 00:10:42,459
overflowed you'll notice that the cost

173
00:10:39,970 --> 00:10:47,350
seven of course differs from minus 9 by

174
00:10:42,459 --> 00:10:50,410
16 and that's not next to and then going

175
00:10:47,350 --> 00:10:58,529
the other direction if we had two large

176
00:10:50,410 --> 00:10:58,529
positive numbers so if we add 7 & 5

177
00:11:08,790 --> 00:11:27,100
we'll get minus six so this was seven

178
00:11:14,579 --> 00:11:29,050
plus five is minus four and so this is

179
00:11:27,100 --> 00:11:39,519
referred to as positive overflow we've

180
00:11:29,050 --> 00:11:40,980
taken two positive numbers and added

181
00:11:39,519 --> 00:11:43,930
them together and gotten a negative

182
00:11:40,980 --> 00:11:46,990
result and you could see this by the way

183
00:11:43,930 --> 00:11:49,810
if you think about this addition we took

184
00:11:46,990 --> 00:11:52,449
seven and five would be twelve and this

185
00:11:49,810 --> 00:11:55,540
is the bit level representation of

186
00:11:52,449 --> 00:11:58,899
twelve it's just that because this is

187
00:11:55,540 --> 00:12:04,870
not the time bit we think of that as

188
00:11:58,899 --> 00:12:07,959
minus four not positive twelve and so

189
00:12:04,870 --> 00:12:11,050
that's the the idea of two's complement

190
00:12:07,959 --> 00:12:15,779
overflow and you can see there's two

191
00:12:11,050 --> 00:12:19,180
different cases here one is where the

192
00:12:15,779 --> 00:12:22,120
number that the sum was if we looked at

193
00:12:19,180 --> 00:12:25,630
the true sum the numbers that you'd get

194
00:12:22,120 --> 00:12:27,639
for example 12 is too big to represent

195
00:12:25,630 --> 00:12:29,139
and so when we think of that as a two's

196
00:12:27,639 --> 00:12:30,160
complement number it becomes now a

197
00:12:29,139 --> 00:12:33,069
negative number

198
00:12:30,160 --> 00:12:35,740
so that's positive overflow similarly if

199
00:12:33,069 --> 00:12:38,529
we have two negative numbers and we add

200
00:12:35,740 --> 00:12:41,380
them together so that the sum is too

201
00:12:38,529 --> 00:12:43,209
small to negative to represent then

202
00:12:41,380 --> 00:12:46,000
those become positive numbers that's

203
00:12:43,209 --> 00:12:49,180
negative overflow and you can see that

204
00:12:46,000 --> 00:12:53,949
in this picture the same ideas before

205
00:12:49,180 --> 00:12:56,470
except there's three regions this is and

206
00:12:53,949 --> 00:13:00,480
by the way now you'll see our numbers

207
00:12:56,470 --> 00:13:04,930
range between minus 8 and positive 7 and

208
00:13:00,480 --> 00:13:10,149
the sum to come will also range between

209
00:13:04,930 --> 00:13:13,170
minus 8 and a positive 7 but there's

210
00:13:10,149 --> 00:13:16,329
these three regions one is the where

211
00:13:13,170 --> 00:13:19,059
everything's fine

212
00:13:16,329 --> 00:13:23,049
it's within the representable range the

213
00:13:19,059 --> 00:13:24,670
other is where the sum was so far toward

214
00:13:23,049 --> 00:13:28,389
the negative side that it becomes

215
00:13:24,670 --> 00:13:32,249
positive or where it's so high on the

216
00:13:28,389 --> 00:13:37,299
positive side that it becomes negative

217
00:13:32,249 --> 00:13:41,949
and so part of data web you'll you'll

218
00:13:37,299 --> 00:13:44,559
learn to understand these quite in quite

219
00:13:41,949 --> 00:13:47,709
precisely but that lets the idea it's a

220
00:13:44,559 --> 00:13:49,720
little bit counterintuitive to say you

221
00:13:47,709 --> 00:13:51,910
know somehow I can accept the idea the

222
00:13:49,720 --> 00:13:54,850
modular arithmetic for unsigned numbers

223
00:13:51,910 --> 00:13:58,449
there's some sort of mathematical beauty

224
00:13:54,850 --> 00:14:04,079
to a modular arithmetic and this disk

225
00:13:58,449 --> 00:14:09,149
looks like kind of useless right from a

226
00:14:04,079 --> 00:14:13,449
from a operational characteristic but

227
00:14:09,149 --> 00:14:14,160
it's the way it is and we're stuck with

228
00:14:13,449 --> 00:14:18,819
it

229
00:14:14,160 --> 00:14:20,619
and multiplication is basically the same

230
00:14:18,819 --> 00:14:23,290
idea in fact all the operations are

231
00:14:20,619 --> 00:14:25,239
basically the same idea that if you

232
00:14:23,290 --> 00:14:28,989
can't represent it within the word size

233
00:14:25,239 --> 00:14:33,939
you just take the lower W bits so all

234
00:14:28,989 --> 00:14:35,679
this complicated notation here is just a

235
00:14:33,939 --> 00:14:37,959
way of saying in principle if you take

236
00:14:35,679 --> 00:14:42,160
2w bit numbers and multiply them

237
00:14:37,959 --> 00:14:44,949
together you may need a the result may

238
00:14:42,160 --> 00:14:49,139
require as much as 2 times W bits to

239
00:14:44,949 --> 00:14:50,739
represent before addition its W plus 1

240
00:14:49,139 --> 00:14:52,119
multiplication you actually have to

241
00:14:50,739 --> 00:14:57,279
double because you're potentially

242
00:14:52,119 --> 00:15:00,160
squaring the largest number and so again

243
00:14:57,279 --> 00:15:02,139
we don't want to just keep doubling our

244
00:15:00,160 --> 00:15:04,480
word size over and over again we'll run

245
00:15:02,139 --> 00:15:13,869
out of bits very quickly that way and so

246
00:15:04,480 --> 00:15:17,559
we just truncate it at W bits and for

247
00:15:13,869 --> 00:15:19,509
the unsigned case it's again modular

248
00:15:17,559 --> 00:15:24,989
arithmetic it's something that you can

249
00:15:19,509 --> 00:15:24,989
kind of understand and believe but for

250
00:15:25,019 --> 00:15:30,230
two and so again let's just do a few

251
00:15:28,480 --> 00:15:33,800
examples and I won't try and

252
00:15:30,230 --> 00:15:36,500
work out multiplying in binary is like

253
00:15:33,800 --> 00:15:38,360
multiplying in decimal you do a big

254
00:15:36,500 --> 00:15:42,100
table and it takes a long time so I

255
00:15:38,360 --> 00:15:54,410
won't try to do that but let me just

256
00:15:42,100 --> 00:15:58,190
show a few examples so if I multiply

257
00:15:54,410 --> 00:16:01,699
three times five is of course equal to

258
00:15:58,190 --> 00:16:13,850
15 and in an unsigned number I can

259
00:16:01,699 --> 00:16:22,699
represent that right so that's okay but

260
00:16:13,850 --> 00:16:28,399
if I multiply a five times five then

261
00:16:22,699 --> 00:16:30,500
that would have representation if I were

262
00:16:28,399 --> 00:16:31,790
to think about it as possibly as many as

263
00:16:30,500 --> 00:16:40,670
eight bits it would have a

264
00:16:31,790 --> 00:16:43,250
representation with an extra bit and I'm

265
00:16:40,670 --> 00:16:46,399
going to throw this part away and so I'd

266
00:16:43,250 --> 00:16:49,690
call that nine which of course is equal

267
00:16:46,399 --> 00:16:49,690
to 25 960

268
00:16:52,790 --> 00:16:58,890
um and and so that's the general idea of

269
00:16:56,850 --> 00:17:01,710
it is regardless of whatever is in this

270
00:16:58,890 --> 00:17:03,960
upper part of the work of the product

271
00:17:01,710 --> 00:17:06,480
I'm just going to discard that and only

272
00:17:03,960 --> 00:17:08,459
look at the lower one and vice gets a

273
00:17:06,480 --> 00:17:11,520
little more interesting with the two's

274
00:17:08,459 --> 00:17:18,689
complement case so let's look at what

275
00:17:11,520 --> 00:17:21,770
that does and the answer is even a

276
00:17:18,689 --> 00:17:24,300
little bit stranger that you not only

277
00:17:21,770 --> 00:17:27,449
trunk throw away whatever high order

278
00:17:24,300 --> 00:17:29,700
bits happen to be there but whatever bit

279
00:17:27,449 --> 00:17:31,500
gets left in this position will

280
00:17:29,700 --> 00:17:35,150
determine whether it's a positive or a

281
00:17:31,500 --> 00:17:38,520
negative result even though with

282
00:17:35,150 --> 00:17:42,390
completely irrespective of the signs of

283
00:17:38,520 --> 00:17:46,160
the original two operands so that can

284
00:17:42,390 --> 00:17:46,160
make you go all over the place

285
00:18:01,650 --> 00:18:16,650
so if we had five times four or 20 that

286
00:18:09,760 --> 00:18:16,650
would be represented in this 8-bit form

287
00:18:22,380 --> 00:18:31,780
like so and we just call that for right

288
00:18:28,690 --> 00:18:40,150
is we're showing this away but if we did

289
00:18:31,780 --> 00:18:43,140
five times five as we saw before that's

290
00:18:40,150 --> 00:18:43,140
represented like this

291
00:18:49,770 --> 00:18:56,970
and that sum now becomes so we're

292
00:18:54,510 --> 00:19:00,840
throwing away this and this becomes our

293
00:18:56,970 --> 00:19:07,260
sign bit so the result is minus 8 plus 1

294
00:19:00,840 --> 00:19:08,760
or minus 7 so you see this is a similar

295
00:19:07,260 --> 00:19:12,059
to an example we showed at the beginning

296
00:19:08,760 --> 00:19:14,820
of the first lecture that you can have

297
00:19:12,059 --> 00:19:18,600
two positive numbers and multiply them

298
00:19:14,820 --> 00:19:20,429
and get a negative result and because of

299
00:19:18,600 --> 00:19:26,880
the sort of course of this overflow

300
00:19:20,429 --> 00:19:31,309
question there oh I'm just taking 25 and

301
00:19:26,880 --> 00:19:35,660
writing it in binary yeah if you want to

302
00:19:31,309 --> 00:19:38,520
you know you start with the two numbers

303
00:19:35,660 --> 00:19:40,020
I'm not going to do well actually this

304
00:19:38,520 --> 00:19:42,480
one's an easy one there's a trick for

305
00:19:40,020 --> 00:19:44,790
this if you want to know multiply a

306
00:19:42,480 --> 00:19:47,780
number by a power of two we're going to

307
00:19:44,790 --> 00:19:55,710
show that later you just shift it left

308
00:19:47,780 --> 00:19:57,840
by two position so that one's an easy

309
00:19:55,710 --> 00:20:00,120
one otherwise you have to write out the

310
00:19:57,840 --> 00:20:03,900
table and sum all the results and all

311
00:20:00,120 --> 00:20:06,110
that stuff I prefer to what computers do

312
00:20:03,900 --> 00:20:06,110
that

313
00:20:12,929 --> 00:20:20,770
and again this to complement stuff one

314
00:20:17,770 --> 00:20:25,270
interesting feature is that it works for

315
00:20:20,770 --> 00:20:26,620
our negative numbers too so if you do

316
00:20:25,270 --> 00:20:29,799
this trick of throwing away the

317
00:20:26,620 --> 00:20:31,779
high-order bit and you'll have overflow

318
00:20:29,799 --> 00:20:34,299
cases like before because you're

319
00:20:31,779 --> 00:20:36,460
throwing away information but the lower

320
00:20:34,299 --> 00:20:39,100
bits if the number is representable

321
00:20:36,460 --> 00:20:45,669
you'll get the right result so let me

322
00:20:39,100 --> 00:20:50,080
just demonstrate to that to you so this

323
00:20:45,669 --> 00:20:52,750
is a minus 3 but you remember that this

324
00:20:50,080 --> 00:21:01,840
is equivalent to 13 as an unsigned

325
00:20:52,750 --> 00:21:04,809
number and this is minus 2 which is

326
00:21:01,840 --> 00:21:10,929
equivalent to my 14 as an unsigned

327
00:21:04,809 --> 00:21:16,690
number so now if we multiply 13 times 14

328
00:21:10,929 --> 00:21:20,399
you get 182 and that has a hex

329
00:21:16,690 --> 00:21:20,399
representation of b6

330
00:21:27,120 --> 00:21:36,360
and so just looking at the low order for

331
00:21:31,480 --> 00:21:40,720
bit are 0 1 1 0 is 6 and indeed that

332
00:21:36,360 --> 00:21:43,659
negative 3 times minus 2 is 6 so the

333
00:21:40,720 --> 00:21:45,429
point being oh and I'm waving my hands

334
00:21:43,659 --> 00:21:47,980
here because I don't want to go through

335
00:21:45,429 --> 00:21:52,360
all the details but to complement

336
00:21:47,980 --> 00:21:56,200
multiplication also gives you if you can

337
00:21:52,360 --> 00:21:58,120
do it using the exact same rules and as

338
00:21:56,200 --> 00:22:00,250
you do for unsigned multiplication the

339
00:21:58,120 --> 00:22:04,299
exact same hardware I should mention

340
00:22:00,250 --> 00:22:06,220
that and there are instructions in the

341
00:22:04,299 --> 00:22:09,130
computer in ways that you can get the

342
00:22:06,220 --> 00:22:10,899
upper word of a multiplication too and

343
00:22:09,130 --> 00:22:13,139
though it's the bit patterns are

344
00:22:10,899 --> 00:22:15,370
different depending on whether it

345
00:22:13,139 --> 00:22:17,139
treated as a tooth compliment number

346
00:22:15,370 --> 00:22:19,510
versus unsigned so these typically

347
00:22:17,139 --> 00:22:23,620
different instructions for doing that

348
00:22:19,510 --> 00:22:26,799
computation but 99% of the time or more

349
00:22:23,620 --> 00:22:28,539
you just are looking at this lower part

350
00:22:26,799 --> 00:22:30,429
of the product and that's the same

351
00:22:28,539 --> 00:22:34,899
whether it's a two's complement or an

352
00:22:30,429 --> 00:22:36,909
unsigned and it handles negative numbers

353
00:22:34,899 --> 00:22:39,690
positive but it has these overflow

354
00:22:36,909 --> 00:22:39,690
characteristics

355
00:22:42,779 --> 00:22:49,299
so as I was talking about there's a

356
00:22:46,539 --> 00:22:51,940
trick we can do for multiplying by a

357
00:22:49,299 --> 00:22:54,010
power of two which is just to shift the

358
00:22:51,940 --> 00:22:57,460
number to the left and you'll often see

359
00:22:54,010 --> 00:22:59,559
that when you have in your code I want

360
00:22:57,460 --> 00:23:02,049
to multiply some number by four you'll

361
00:22:59,559 --> 00:23:04,360
write in your C code if you look at the

362
00:23:02,049 --> 00:23:07,240
assembly code you'll see that what the

363
00:23:04,360 --> 00:23:10,059
compiler generated is just says oh just

364
00:23:07,240 --> 00:23:12,130
shift it left by two so in general and

365
00:23:10,059 --> 00:23:21,250
you could see why this is true by the

366
00:23:12,130 --> 00:23:35,710
way if you think of the number as the

367
00:23:21,250 --> 00:23:38,409
sum of the bits where X sub I is the ice

368
00:23:35,710 --> 00:23:43,240
bit and X is the number it represents if

369
00:23:38,409 --> 00:23:45,630
I want to if I shift everything left by

370
00:23:43,240 --> 00:23:49,480
two what I'm effectively doing is

371
00:23:45,630 --> 00:23:52,690
increasing their weight by that number

372
00:23:49,480 --> 00:23:57,179
of positions so let's just shift by one

373
00:23:52,690 --> 00:23:57,179
if I shift everything to the left by one

374
00:24:00,360 --> 00:24:11,080
which we write like this and see two

375
00:24:03,250 --> 00:24:13,809
left two less symbols so I taking that

376
00:24:11,080 --> 00:24:16,600
sum but now waiting the disk by two to

377
00:24:13,809 --> 00:24:20,049
be I plus one by one more and of course

378
00:24:16,600 --> 00:24:27,870
that's equal to twice what the original

379
00:24:20,049 --> 00:24:34,299
sum was and so we double the number and

380
00:24:27,870 --> 00:24:36,880
that works although even if you shift

381
00:24:34,299 --> 00:24:39,010
things so that you lose some bits right

382
00:24:36,880 --> 00:24:42,190
they they shift off to the left all

383
00:24:39,010 --> 00:24:42,519
you're doing is the way multiplication

384
00:24:42,190 --> 00:24:45,850
works

385
00:24:42,519 --> 00:24:48,460
anyhow of truncating to W bit product so

386
00:24:45,850 --> 00:24:52,210
you'll see this as I mentioned quite

387
00:24:48,460 --> 00:24:54,370
often in in compiled code machine level

388
00:24:52,210 --> 00:24:55,360
code that they're doing shifts where you

389
00:24:54,370 --> 00:24:57,370
might expect them

390
00:24:55,360 --> 00:24:59,670
to be doing multiplications and the

391
00:24:57,370 --> 00:25:01,630
reason for that is an optimization is

392
00:24:59,670 --> 00:25:03,970
historically the multiplication

393
00:25:01,630 --> 00:25:08,170
instruction took a lot longer than a

394
00:25:03,970 --> 00:25:11,580
shift instruction say one clock cycle to

395
00:25:08,170 --> 00:25:15,480
do a shift and it used to be like 11 12

396
00:25:11,580 --> 00:25:20,650
30 clock cycles to do a multiplication

397
00:25:15,480 --> 00:25:22,540
nowadays like on the computers we use

398
00:25:20,650 --> 00:25:24,010
the sharp machines it only take three

399
00:25:22,540 --> 00:25:26,860
clock cycles to do multiplication

400
00:25:24,010 --> 00:25:29,559
because they added a lot of hardware to

401
00:25:26,860 --> 00:25:33,340
do that but three clock cycles is still

402
00:25:29,559 --> 00:25:35,410
more time than one and so when you can

403
00:25:33,340 --> 00:25:37,840
get away with a shift it's generally a

404
00:25:35,410 --> 00:25:41,799
better idea and the compiler has its own

405
00:25:37,840 --> 00:25:44,950
kind of judgment calls on when is it

406
00:25:41,799 --> 00:25:52,600
more efficient to substitute one

407
00:25:44,950 --> 00:25:55,200
operation for another did we design lose

408
00:25:52,600 --> 00:25:55,200
ground here

409
00:25:59,990 --> 00:26:10,770
okay so the idea that if we want to

410
00:26:06,980 --> 00:26:20,310
multiply something by 2 to the K we just

411
00:26:10,770 --> 00:26:23,880
shift it left by K bit it turns out that

412
00:26:20,310 --> 00:26:25,740
the same almost works for dividing by 2

413
00:26:23,880 --> 00:26:28,770
as well that if you want to divide

414
00:26:25,740 --> 00:26:33,600
something by a power of 2 you can shift

415
00:26:28,770 --> 00:26:35,550
it right by in the same general idea the

416
00:26:33,600 --> 00:26:38,070
only thing that becomes a little bit

417
00:26:35,550 --> 00:26:41,040
quirky is well what if the number you

418
00:26:38,070 --> 00:26:53,610
have is not actually divisible by that

419
00:26:41,040 --> 00:27:07,700
power of 2 so for example if we had the

420
00:26:53,610 --> 00:27:12,950
number 0 1 what it's going to use yeah

421
00:27:07,700 --> 00:27:22,470
so that's 6 so if we shift it right by 1

422
00:27:12,950 --> 00:27:26,370
we'll get 0 0 1 0 1 1 thank you which is

423
00:27:22,470 --> 00:27:34,410
3 and that's 6 divided by 2 is 3 if we

424
00:27:26,370 --> 00:27:39,390
shift that again we'll get 1 but of

425
00:27:34,410 --> 00:27:44,190
course you know that 3 halves or 1.5 the

426
00:27:39,390 --> 00:27:48,810
rule on integer division is you round it

427
00:27:44,190 --> 00:27:53,460
down round it towards 0 and so that goes

428
00:27:48,810 --> 00:27:58,590
to 1 so this is what the unsigned case

429
00:27:53,460 --> 00:28:01,220
works fine the sine case which I don't

430
00:27:58,590 --> 00:28:01,220
have a slide for

431
00:28:05,159 --> 00:28:13,289
is a little bit less of pretty oh well

432
00:28:11,999 --> 00:28:15,149
first of all you notice if it's a

433
00:28:13,289 --> 00:28:18,809
positive number the shifting rights

434
00:28:15,149 --> 00:28:21,269
going to be the right thing oh just as

435
00:28:18,809 --> 00:28:30,929
is for untime but let's take a number

436
00:28:21,269 --> 00:28:36,479
that is negative so this is plus two

437
00:28:30,929 --> 00:28:39,809
minus six right now here's where

438
00:28:36,479 --> 00:28:41,909
remember I told you in the previous

439
00:28:39,809 --> 00:28:44,549
lecture there's two ways to do shifting

440
00:28:41,909 --> 00:28:47,429
there's logical shifting where you fill

441
00:28:44,549 --> 00:28:53,970
in with zeros and arithmetic shifting

442
00:28:47,429 --> 00:28:55,950
where you fill in with ones and guess

443
00:28:53,970 --> 00:28:59,609
where arithmetic shifting comes in this

444
00:28:55,950 --> 00:29:01,889
is it when you want to preserve the sign

445
00:28:59,609 --> 00:29:04,739
of a number while you're dividing it by

446
00:29:01,889 --> 00:29:08,729
powers of two you want arithmetic shifts

447
00:29:04,739 --> 00:29:11,700
so if we shift this by one we'll keep

448
00:29:08,729 --> 00:29:16,470
that sign bit and then copy the other

449
00:29:11,700 --> 00:29:20,099
ones over all right so we just preserve

450
00:29:16,470 --> 00:29:27,239
this bit here and copied the other ones

451
00:29:20,099 --> 00:29:29,909
over and this is minus three and so

452
00:29:27,239 --> 00:29:36,919
that's good but now if we shift again

453
00:29:29,909 --> 00:29:36,919
arithmetic we will get what

454
00:29:40,220 --> 00:29:46,740
nice - I can see you guys need to know

455
00:29:43,950 --> 00:29:49,080
how to negate numbers right you don't

456
00:29:46,740 --> 00:29:52,529
know that so I'll show you in a second

457
00:29:49,080 --> 00:29:58,139
so here is a little bit problematic that

458
00:29:52,529 --> 00:29:59,879
we shifted we want to divide by two but

459
00:29:58,139 --> 00:30:02,549
the rule should be the same that you

460
00:29:59,879 --> 00:30:05,580
should round toward zero and what this

461
00:30:02,549 --> 00:30:07,049
is doing is it's rounding toward minus

462
00:30:05,580 --> 00:30:09,720
infinity its rounding

463
00:30:07,049 --> 00:30:14,249
toward a more negative number than the

464
00:30:09,720 --> 00:30:19,110
truth thing and so there's a little cute

465
00:30:14,249 --> 00:30:21,360
little trick that says before you shift

466
00:30:19,110 --> 00:30:24,360
before you divide by a power of two

467
00:30:21,360 --> 00:30:33,360
before you do the shift you should add a

468
00:30:24,360 --> 00:30:35,279
bias which in this case would just be

469
00:30:33,360 --> 00:30:37,559
one and I'll tell you where that comes

470
00:30:35,279 --> 00:30:42,889
from and so if we add those numbers

471
00:30:37,559 --> 00:30:42,889
together we'll get one one one zero

472
00:30:44,269 --> 00:30:54,509
right and now when we do the shift on

473
00:30:47,369 --> 00:30:56,999
that we'll get 1 1 1 1 and that's minus

474
00:30:54,509 --> 00:30:59,029
1 so there's a trick and you'll again

475
00:30:56,999 --> 00:31:02,399
you'll see the compiler doing this where

476
00:30:59,029 --> 00:31:05,009
you have in your code divided by 16 and

477
00:31:02,399 --> 00:31:07,049
we'll add a bias and then it will do a

478
00:31:05,009 --> 00:31:09,450
right shift instead of calling division

479
00:31:07,049 --> 00:31:12,869
and by the way division really really is

480
00:31:09,450 --> 00:31:16,369
slow even on a modern computer like what

481
00:31:12,869 --> 00:31:20,070
you have the shark machines it takes

482
00:31:16,369 --> 00:31:22,830
thirty plus clock cycles so anytime the

483
00:31:20,070 --> 00:31:25,470
compiler can avoid figure out a trick

484
00:31:22,830 --> 00:31:30,509
that does it with shifting and tweaking

485
00:31:25,470 --> 00:31:32,129
things around it will oh so I realized I

486
00:31:30,509 --> 00:31:34,909
should tell you there's a couple ways

487
00:31:32,129 --> 00:31:34,909
you can

488
00:31:35,290 --> 00:31:39,470
negated number that are handy to know if

489
00:31:37,760 --> 00:31:44,960
you ever have to do it in your head or

490
00:31:39,470 --> 00:31:47,420
on paper and the standard way is what's

491
00:31:44,960 --> 00:31:53,270
called complement and increment so this

492
00:31:47,420 --> 00:31:59,210
is how do I go from X to minus X so if I

493
00:31:53,270 --> 00:32:00,920
have a number and I want to negate it

494
00:31:59,210 --> 00:32:04,100
whether it's currently a negative number

495
00:32:00,920 --> 00:32:06,200
or it's a positive number the same trick

496
00:32:04,100 --> 00:32:11,810
works what I'll do is complement it

497
00:32:06,200 --> 00:32:20,060
meaning I'll flip all the bits and then

498
00:32:11,810 --> 00:32:30,460
I'll add one to that and do the regular

499
00:32:20,060 --> 00:32:32,840
sum and so this is six this is minus six

500
00:32:30,460 --> 00:32:34,580
so if you ever have to do it by hand

501
00:32:32,840 --> 00:32:36,070
that's the way to do a compliment in

502
00:32:34,580 --> 00:32:44,570
increment and it goes the other way

503
00:32:36,070 --> 00:32:50,780
you'll see if I compliment this and I

504
00:32:44,570 --> 00:32:54,790
increment it I'll get back to my

505
00:32:50,780 --> 00:32:54,790
previous number so that's the trick that

506
00:32:55,330 --> 00:33:00,740
it's pretty much only useful when you do

507
00:32:57,860 --> 00:33:04,240
things on the blackboard or when you

508
00:33:00,740 --> 00:33:04,240
have to solve a problem in data web

509
00:33:09,880 --> 00:33:20,600
so anyway this idea of doing a using up

510
00:33:18,620 --> 00:33:22,520
shifting to the right to do power of two

511
00:33:20,600 --> 00:33:24,650
division is actually that's the whole

512
00:33:22,520 --> 00:33:27,730
justification for arithmetic shifting in

513
00:33:24,650 --> 00:33:31,850
the first place which by the way in NC

514
00:33:27,730 --> 00:33:35,540
there's no fixed requirement for how

515
00:33:31,850 --> 00:33:37,309
shifting works in C for signed numbers

516
00:33:35,540 --> 00:33:40,630
for unsigned it has to be a logical

517
00:33:37,309 --> 00:33:44,360
shift sign numbers the C standard says

518
00:33:40,630 --> 00:33:46,940
there's no fixed definition the reality

519
00:33:44,360 --> 00:33:49,580
is on our machines most machines just

520
00:33:46,940 --> 00:33:52,220
about every machine out there when it's

521
00:33:49,580 --> 00:33:53,870
a two's complement number when it's a

522
00:33:52,220 --> 00:33:56,179
negative where it's assigned number

523
00:33:53,870 --> 00:33:59,679
two's complement and when you do a shift

524
00:33:56,179 --> 00:33:59,679
it will be an arithmetic shift

525
00:34:06,770 --> 00:34:13,399
so getting back to them summarizing this

526
00:34:09,980 --> 00:34:15,669
integer arithmetic you see that first of

527
00:34:13,399 --> 00:34:18,730
all whether it's signed your unsigned

528
00:34:15,669 --> 00:34:23,200
the addition or multiplication

529
00:34:18,730 --> 00:34:27,230
operations are the same whether it's a

530
00:34:23,200 --> 00:34:31,730
unsigned number or two's complement and

531
00:34:27,230 --> 00:34:33,830
it works the negative stuff works out as

532
00:34:31,730 --> 00:34:38,899
long as you don't have an overflow and

533
00:34:33,830 --> 00:34:40,879
you can end up with an overflow only one

534
00:34:38,899 --> 00:34:44,300
type of overflow for unsigned in two

535
00:34:40,879 --> 00:34:47,240
types four signed numbers but it's not

536
00:34:44,300 --> 00:34:50,810
like they just overflow and generate

537
00:34:47,240 --> 00:34:53,210
random numbers there's some of a pattern

538
00:34:50,810 --> 00:34:56,230
to what result what they are and how

539
00:34:53,210 --> 00:34:56,230
they can be interpreted

540
00:35:00,650 --> 00:35:06,750
so we I talked about this a little bit

541
00:35:03,990 --> 00:35:08,760
last time and gave this example similar

542
00:35:06,750 --> 00:35:13,170
to this but let me go over it a little

543
00:35:08,760 --> 00:35:15,780
bit more one thing you might think of

544
00:35:13,170 --> 00:35:18,330
while if it's unsigned and signed stuff

545
00:35:15,780 --> 00:35:20,940
gets so murky and we saw some funny

546
00:35:18,330 --> 00:35:24,090
examples last time maybe we should just

547
00:35:20,940 --> 00:35:26,850
vanished unsigned numbers from the

548
00:35:24,090 --> 00:35:30,030
universe and only allow two's complement

549
00:35:26,850 --> 00:35:32,250
and that's exactly the rule that was

550
00:35:30,030 --> 00:35:37,230
adopted for example in Java they said

551
00:35:32,250 --> 00:35:39,210
this is too weird what let's just say

552
00:35:37,230 --> 00:35:44,750
every number is two's complement the

553
00:35:39,210 --> 00:35:52,320
only trick they did was they put in a

554
00:35:44,750 --> 00:36:02,700
triple right shift means logical shift

555
00:35:52,320 --> 00:36:07,250
this is Java this is not C whereas the

556
00:36:02,700 --> 00:36:07,250
double is a arithmetic

557
00:36:13,220 --> 00:36:18,980
so because they rise there's a lot of

558
00:36:16,700 --> 00:36:21,099
cute little times when you want to play

559
00:36:18,980 --> 00:36:25,220
tricks with things and you need that

560
00:36:21,099 --> 00:36:27,560
logical rate shift so that's actually

561
00:36:25,220 --> 00:36:30,170
one approach or other more modern

562
00:36:27,560 --> 00:36:32,630
languages and si are saying it's okay to

563
00:36:30,170 --> 00:36:34,520
have signed and unsigned but we don't

564
00:36:32,630 --> 00:36:36,530
want them sort of mysteriously being

565
00:36:34,520 --> 00:36:38,990
cast back and forth in ways that the

566
00:36:36,530 --> 00:36:42,109
programmer might not recognize and so

567
00:36:38,990 --> 00:36:44,660
you have to explicitly do a cast

568
00:36:42,109 --> 00:36:46,790
rather than implicitly and I think

569
00:36:44,660 --> 00:36:49,579
that's the better approach but see as I

570
00:36:46,790 --> 00:36:53,060
mentioned does this implicit casting and

571
00:36:49,579 --> 00:36:59,990
so as we saw for last time what happens

572
00:36:53,060 --> 00:37:03,980
with this program when you run it to

573
00:36:59,990 --> 00:37:06,220
count down through an array do you

574
00:37:03,980 --> 00:37:06,220
remember

575
00:37:08,780 --> 00:37:17,420
well as I if it's unsigned what will

576
00:37:13,700 --> 00:37:19,420
happen with this test it always succeed

577
00:37:17,420 --> 00:37:21,650
so the thing will be in an infinite loop

578
00:37:19,420 --> 00:37:25,190
actually what will happen is it will try

579
00:37:21,650 --> 00:37:28,220
to access I will go down to 0 and then

580
00:37:25,190 --> 00:37:30,349
it will wrap around to become the

581
00:37:28,220 --> 00:37:32,150
largest possible unsigned number which

582
00:37:30,349 --> 00:37:34,359
is probably way out of balance and it

583
00:37:32,150 --> 00:37:37,310
will give a memory error

584
00:37:34,359 --> 00:37:39,349
but it won't do what's supposed to be

585
00:37:37,310 --> 00:37:41,270
and as I mentioned before these things

586
00:37:39,349 --> 00:37:43,640
there's a lot of sneaky ways this

587
00:37:41,270 --> 00:37:46,520
problem can show up in ways you might

588
00:37:43,640 --> 00:37:52,609
never think of so for example the

589
00:37:46,520 --> 00:37:56,180
operators sizeof is defined to say how

590
00:37:52,609 --> 00:37:58,880
big a particular datatype is it's a very

591
00:37:56,180 --> 00:38:02,089
useful operator but it's its return

592
00:37:58,880 --> 00:38:04,630
value is a what's called a size

593
00:38:02,089 --> 00:38:09,819
underscore T which is defined to be a

594
00:38:04,630 --> 00:38:13,430
long unsigned number and so if we just

595
00:38:09,819 --> 00:38:16,640
throw in a constant like this then this

596
00:38:13,430 --> 00:38:20,300
subtraction we have a sign is now int

597
00:38:16,640 --> 00:38:24,010
but sizeof is unsigned and so it will

598
00:38:20,300 --> 00:38:26,510
cast that to be unsigned implicitly and

599
00:38:24,010 --> 00:38:30,619
when you compare it to 0 you'll have the

600
00:38:26,510 --> 00:38:32,630
same problem as before so just to show

601
00:38:30,619 --> 00:38:37,010
you that these things can speak in in

602
00:38:32,630 --> 00:38:41,810
very tricky ways so one way to do that

603
00:38:37,010 --> 00:38:47,710
then is just don't use unsigned like and

604
00:38:41,810 --> 00:38:51,020
make sure if this is a a possible

605
00:38:47,710 --> 00:38:54,069
unsigned number you cast it to signed

606
00:38:51,020 --> 00:38:57,920
you make sure this is recognized signed

607
00:38:54,069 --> 00:38:59,510
but there's another way that actually at

608
00:38:57,920 --> 00:39:01,130
least there's a fellow over in the

609
00:38:59,510 --> 00:39:04,520
software engineering Institute named

610
00:39:01,130 --> 00:39:10,310
Robert Secord who has written the books

611
00:39:04,520 --> 00:39:13,190
that are sooner considered the the gold

612
00:39:10,310 --> 00:39:14,930
standard for how to write secure code he

613
00:39:13,190 --> 00:39:16,849
works for this organization called the

614
00:39:14,930 --> 00:39:21,650
computer emergency response team which

615
00:39:16,849 --> 00:39:25,849
is out there tracking down bad things

616
00:39:21,650 --> 00:39:28,430
going on in computer security and one of

617
00:39:25,849 --> 00:39:30,289
the things he and others have done is to

618
00:39:28,430 --> 00:39:34,099
try and come up with standards so that

619
00:39:30,289 --> 00:39:36,230
people who write programs will you know

620
00:39:34,099 --> 00:39:37,670
avoid some of the pitfalls that make

621
00:39:36,230 --> 00:39:41,630
their programs vulnerable to the

622
00:39:37,670 --> 00:39:43,970
security of laws to attack and so his

623
00:39:41,630 --> 00:39:46,010
recommended technique is when I first

624
00:39:43,970 --> 00:39:52,579
saw this it was so counterintuitive to

625
00:39:46,010 --> 00:39:54,710
me it it hardly made sense right so you

626
00:39:52,579 --> 00:39:57,410
start and again this is all unsigned

627
00:39:54,710 --> 00:40:01,359
arithmetic so I'm starting to count down

628
00:39:57,410 --> 00:40:04,069
and my test is when I is less than count

629
00:40:01,359 --> 00:40:06,829
so here's the thing I started off

630
00:40:04,069 --> 00:40:09,829
smaller than count and it's only being

631
00:40:06,829 --> 00:40:16,970
decremented so when would this test ever

632
00:40:09,829 --> 00:40:19,940
fail hmm when it overflows when it wraps

633
00:40:16,970 --> 00:40:22,910
around right when I goes from zero and

634
00:40:19,940 --> 00:40:26,329
counts down to what would now be you max

635
00:40:22,910 --> 00:40:28,880
this test will fail which is exactly

636
00:40:26,329 --> 00:40:31,670
when you want it to stop and his

637
00:40:28,880 --> 00:40:34,010
observation is and see with signed

638
00:40:31,670 --> 00:40:37,099
numbers there's no guarantee on what

639
00:40:34,010 --> 00:40:38,690
happens with overflowing as I said most

640
00:40:37,099 --> 00:40:40,520
people just assume it's going to be

641
00:40:38,690 --> 00:40:42,440
two's complement but if you really want

642
00:40:40,520 --> 00:40:44,900
to be careful you shouldn't assume

643
00:40:42,440 --> 00:40:46,539
anything outside of the C standard and

644
00:40:44,900 --> 00:40:49,220
if you're trying to write secure code

645
00:40:46,539 --> 00:40:53,869
it's probably a good idea to be cautious

646
00:40:49,220 --> 00:40:56,630
be conservative on the other hand the C

647
00:40:53,869 --> 00:40:59,000
standard guarantees it that unsigned

648
00:40:56,630 --> 00:41:01,430
arithmetic will be modular arithmetic so

649
00:40:59,000 --> 00:41:04,190
it guarantees that if you subtract one

650
00:41:01,430 --> 00:41:08,390
from zero you'll get the largest number

651
00:41:04,190 --> 00:41:11,869
that could be represented so it will be

652
00:41:08,390 --> 00:41:14,539
okay and in fact he recommends instead

653
00:41:11,869 --> 00:41:18,140
of using unsigned which is on our

654
00:41:14,539 --> 00:41:21,619
machines just a 32-bit value that you

655
00:41:18,140 --> 00:41:25,849
call it a size T which is a 64-bit value

656
00:41:21,619 --> 00:41:28,670
and so and write your code the way that

657
00:41:25,849 --> 00:41:31,039
I showed you so I've actually started

658
00:41:28,670 --> 00:41:33,289
doing this and once you kind of get used

659
00:41:31,039 --> 00:41:34,260
to it it's an OK way to write code but

660
00:41:33,289 --> 00:41:37,890
it's very

661
00:41:34,260 --> 00:41:45,210
strange looking in this way one thing

662
00:41:37,890 --> 00:41:50,280
I'll point out is what would happen if

663
00:41:45,210 --> 00:41:55,590
if count were a signed number and int

664
00:41:50,280 --> 00:42:01,980
and it were you were and it was less

665
00:41:55,590 --> 00:42:10,890
than zero what would happen here so I

666
00:42:01,980 --> 00:42:13,410
less than count what would happen right

667
00:42:10,890 --> 00:42:15,720
and so it become a very large positive

668
00:42:13,410 --> 00:42:18,390
number and this test would almost

669
00:42:15,720 --> 00:42:20,910
certainly succeed so you have the same

670
00:42:18,390 --> 00:42:24,570
this code doesn't avoid the pitfall it

671
00:42:20,910 --> 00:42:26,820
just shifts it to saying you better make

672
00:42:24,570 --> 00:42:31,490
sure you don't you know test for this

673
00:42:26,820 --> 00:42:37,200
case beforehand before you get into it

674
00:42:31,490 --> 00:42:39,420
so I think part of it is the observation

675
00:42:37,200 --> 00:42:43,320
that man if you want to be careful and

676
00:42:39,420 --> 00:42:46,140
write code that that is guaranteed

677
00:42:43,320 --> 00:42:47,970
correct no matter what implementation

678
00:42:46,140 --> 00:42:50,400
goes on as long as it's within the CIE

679
00:42:47,970 --> 00:43:00,210
standard it's pretty tricky business to

680
00:42:50,400 --> 00:43:04,950
question up there yes

681
00:43:00,210 --> 00:43:07,280
which is unfortunate right so yes that's

682
00:43:04,950 --> 00:43:09,810
exactly the rule that it's implicitly

683
00:43:07,280 --> 00:43:13,140
silently the C compiler doesn't give any

684
00:43:09,810 --> 00:43:17,100
warnings you'll never know it cast it's

685
00:43:13,140 --> 00:43:19,830
unsigned and as these examples show when

686
00:43:17,100 --> 00:43:22,980
you stare at that code and you think

687
00:43:19,830 --> 00:43:25,020
about it it's really easy to have bugs

688
00:43:22,980 --> 00:43:27,300
that you just you can look at it a

689
00:43:25,020 --> 00:43:31,320
thousand times and not realize that it's

690
00:43:27,300 --> 00:43:34,590
a bug it's a very and there's examples

691
00:43:31,320 --> 00:43:38,340
these examples in the book of security

692
00:43:34,590 --> 00:43:43,040
flaws in sort of very important library

693
00:43:38,340 --> 00:43:43,040
software due to this problem exactly

694
00:43:44,470 --> 00:43:49,190
so part of the reason we teach in the

695
00:43:46,940 --> 00:43:53,349
course is just so you appreciate that

696
00:43:49,190 --> 00:43:57,019
this is a quirk in this and see that

697
00:43:53,349 --> 00:44:00,079
again 99% of the time you'll never even

698
00:43:57,019 --> 00:44:02,089
it won't bother you at all but there

699
00:44:00,079 --> 00:44:09,019
will be some oddball cases that you can

700
00:44:02,089 --> 00:44:13,759
get in trouble with so the other place

701
00:44:09,019 --> 00:44:16,279
that you'll find unsigned arithmetic

702
00:44:13,759 --> 00:44:18,109
unsigned representation useful is first

703
00:44:16,279 --> 00:44:21,650
of all when you're doing modular

704
00:44:18,109 --> 00:44:25,670
arithmetic which is for example the way

705
00:44:21,650 --> 00:44:27,920
most encryption algorithms work or when

706
00:44:25,670 --> 00:44:30,829
you're using the bits not to represent

707
00:44:27,920 --> 00:44:35,509
numbers but to represent sets the way I

708
00:44:30,829 --> 00:44:38,180
described it before then you don't want

709
00:44:35,509 --> 00:44:45,859
it it's easiest to just think of that as

710
00:44:38,180 --> 00:44:48,950
unsigned numbers okay so the final thing

711
00:44:45,859 --> 00:44:51,769
to talk about today is some of the

712
00:44:48,950 --> 00:44:55,849
low-level representations of numbers

713
00:44:51,769 --> 00:45:01,329
within memory and the main point is when

714
00:44:55,849 --> 00:45:01,329
you are running a program on a computer

715
00:45:01,509 --> 00:45:07,640
from the programming perspective either

716
00:45:04,400 --> 00:45:11,029
even as an assembly level programmer not

717
00:45:07,640 --> 00:45:13,069
just as a C programmer in your mind the

718
00:45:11,029 --> 00:45:15,739
memory is just this big array of bytes

719
00:45:13,069 --> 00:45:19,299
that's numbered from 0 up to some

720
00:45:15,739 --> 00:45:23,589
maximum number so for example in the

721
00:45:19,299 --> 00:45:29,450
machines we're using the 64-bit machines

722
00:45:23,589 --> 00:45:31,880
an address is represented in 64 bits but

723
00:45:29,450 --> 00:45:35,410
in fact the maximum address you're

724
00:45:31,880 --> 00:45:41,180
allowed to use in current machines is a

725
00:45:35,410 --> 00:45:43,789
47 bits and to the forty-seventh is

726
00:45:41,180 --> 00:45:47,150
still a pretty big number so that's more

727
00:45:43,789 --> 00:45:49,190
memory than anyone's able to buy right

728
00:45:47,150 --> 00:45:51,440
now anyhow and so it's a reasonable

729
00:45:49,190 --> 00:45:54,890
restriction but the point is that

730
00:45:51,440 --> 00:45:56,849
logically your program thinks that it

731
00:45:54,890 --> 00:45:58,890
has a array of

732
00:45:56,849 --> 00:46:01,349
at many bites let's try and figure out

733
00:45:58,890 --> 00:46:09,029
how big to xlvii is anyone know it off

734
00:46:01,349 --> 00:46:12,829
the top of their head so there's a trick

735
00:46:09,029 --> 00:46:12,829
if you want to get an approximate idea

736
00:46:13,970 --> 00:46:24,210
which is to say that 2 to the 10th which

737
00:46:18,809 --> 00:46:29,190
is 110 24 is approximately equal to 10

738
00:46:24,210 --> 00:46:31,799
to the third you say oh well that's

739
00:46:29,190 --> 00:46:36,599
really helpful what it means is that 10

740
00:46:31,799 --> 00:46:38,630
bits worth of number is about the same

741
00:46:36,599 --> 00:46:48,180
as three decimal digits

742
00:46:38,630 --> 00:46:57,509
all right so for example 2 to the 20th

743
00:46:48,180 --> 00:47:03,930
is around 10 to the 6 2 to the 30th it's

744
00:46:57,509 --> 00:47:08,849
around 10 to the 9th to the 40th around

745
00:47:03,930 --> 00:47:15,479
10 to the 12th and so that would tell

746
00:47:08,849 --> 00:47:18,059
you that 2 to the 48-47 is around 128

747
00:47:15,479 --> 00:47:23,430
times 10 to the 12th which is 128

748
00:47:18,059 --> 00:47:26,249
terabyte right Tara 10 to the 12 so if

749
00:47:23,430 --> 00:47:29,309
you just want to say you know get a

750
00:47:26,249 --> 00:47:31,769
quick figure 4 and of course these are

751
00:47:29,309 --> 00:47:34,170
approximations but if you just want to

752
00:47:31,769 --> 00:47:36,569
get a quick handle on how big a number

753
00:47:34,170 --> 00:47:38,910
you know what range of values can I

754
00:47:36,569 --> 00:47:42,569
represent with so many bits of it this

755
00:47:38,910 --> 00:47:45,900
is a really easy trick to do that so the

756
00:47:42,569 --> 00:47:51,960
point is a 128 terabytes

757
00:47:45,900 --> 00:47:54,329
is a lot you can buy disk drives a

758
00:47:51,960 --> 00:47:56,910
couple of disk drives will do that for

759
00:47:54,329 --> 00:47:59,700
you but you couldn't buy enough DRAM on

760
00:47:56,910 --> 00:48:02,460
a normal budget to get that kind of

761
00:47:59,700 --> 00:48:04,920
memory so that's the current range of

762
00:48:02,460 --> 00:48:08,489
values but logically when you run a

763
00:48:04,920 --> 00:48:10,500
program it thinks that it has that

764
00:48:08,489 --> 00:48:12,900
possible range now it

765
00:48:10,500 --> 00:48:15,510
doesn't really and in fact what happens

766
00:48:12,900 --> 00:48:17,810
is that the operating system only allows

767
00:48:15,510 --> 00:48:20,670
certain regions within that memory to be

768
00:48:17,810 --> 00:48:23,160
referenced and other regions if you try

769
00:48:20,670 --> 00:48:24,750
to access them it will create a it will

770
00:48:23,160 --> 00:48:28,080
signal an error what they call a

771
00:48:24,750 --> 00:48:29,730
segmentation fault but logically at

772
00:48:28,080 --> 00:48:32,400
least it's as if you have this big array

773
00:48:29,730 --> 00:48:34,020
of bytes now in reality and we'll go

774
00:48:32,400 --> 00:48:39,260
into this when we talk about how the

775
00:48:34,020 --> 00:48:39,260
memory system is works in virtual memory

776
00:48:40,610 --> 00:48:45,840
there's this very complex combination of

777
00:48:43,440 --> 00:48:48,930
hardware and software that gives the

778
00:48:45,840 --> 00:48:51,900
program this image of a very large what

779
00:48:48,930 --> 00:48:54,380
you call flap space just a big array of

780
00:48:51,900 --> 00:48:57,540
bytes when in reality it's shuffling

781
00:48:54,380 --> 00:48:59,640
between different regions of your memory

782
00:48:57,540 --> 00:49:03,440
and even between your memory and your

783
00:48:59,640 --> 00:49:09,540
disk drive on your computer to make it

784
00:49:03,440 --> 00:49:11,610
implement this particular idea that you

785
00:49:09,540 --> 00:49:13,890
have this big array of bytes and that's

786
00:49:11,610 --> 00:49:17,250
all handled as I said by the operating

787
00:49:13,890 --> 00:49:19,440
system by the computer hardware and it's

788
00:49:17,250 --> 00:49:21,120
largely invisible even to the machine

789
00:49:19,440 --> 00:49:30,180
level programmer even people writing

790
00:49:21,120 --> 00:49:32,280
assembly code you'll often hear the term

791
00:49:30,180 --> 00:49:35,550
word size and it can get very confusing

792
00:49:32,280 --> 00:49:38,120
confusing nowadays because there's no

793
00:49:35,550 --> 00:49:41,550
really fixed idea of what a word size is

794
00:49:38,120 --> 00:49:45,810
but roughly speaking the word size

795
00:49:41,550 --> 00:49:52,020
should be whatever the largest number is

796
00:49:45,810 --> 00:49:55,020
that or the range that sort of signifies

797
00:49:52,020 --> 00:49:58,650
how big a pointer is in this language or

798
00:49:55,020 --> 00:50:01,020
Hardware wise the largest sort of chunk

799
00:49:58,650 --> 00:50:03,210
of hardware for which there's standard

800
00:50:01,020 --> 00:50:06,180
support for storing it for arithmetic

801
00:50:03,210 --> 00:50:09,450
operations and so forth so when we say

802
00:50:06,180 --> 00:50:12,500
it's a 64-bit machine what we mean is

803
00:50:09,450 --> 00:50:16,170
that it it regular and routinely

804
00:50:12,500 --> 00:50:19,710
manipulate 64-bit values err on

805
00:50:16,170 --> 00:50:22,950
arithmetic operations and also it has a

806
00:50:19,710 --> 00:50:24,300
pointers or the values of addresses are

807
00:50:22,950 --> 00:50:28,470
64 bits

808
00:50:24,300 --> 00:50:30,540
even if for right now only 47 of those

809
00:50:28,470 --> 00:50:34,680
bits are usable it's still considered a

810
00:50:30,540 --> 00:50:40,950
64-bit machine one thing that strange is

811
00:50:34,680 --> 00:50:49,290
in one of the features of of machines

812
00:50:40,950 --> 00:50:53,160
such as we have huh is that if I compile

813
00:50:49,290 --> 00:50:56,610
a program using a GCC the standard

814
00:50:53,160 --> 00:51:02,520
compiler I can specify either I want it

815
00:50:56,610 --> 00:51:08,460
to be 64 bit code or 32-bit code as a

816
00:51:02,520 --> 00:51:10,920
flag and it will actually generate two

817
00:51:08,460 --> 00:51:13,650
different kinds of object code as a

818
00:51:10,920 --> 00:51:16,710
result and we'll talk in a look about

819
00:51:13,650 --> 00:51:20,220
these later but for right now the point

820
00:51:16,710 --> 00:51:23,000
is the hardware itself doesn't

821
00:51:20,220 --> 00:51:25,680
necessarily define what the word size is

822
00:51:23,000 --> 00:51:27,810
it's a combination of the hardware and

823
00:51:25,680 --> 00:51:30,300
the compiler that determines what is the

824
00:51:27,810 --> 00:51:33,720
word size being used in this particular

825
00:51:30,300 --> 00:51:36,450
program and that code can be run on the

826
00:51:33,720 --> 00:51:39,330
point is the 64 bit machine such as we

827
00:51:36,450 --> 00:51:43,860
have and most machines are nowadays can

828
00:51:39,330 --> 00:51:52,170
insert of a backward compatibility style

829
00:51:43,860 --> 00:51:55,170
also execute 32-bit code and as we also

830
00:51:52,170 --> 00:51:57,360
saw one of the other features is even

831
00:51:55,170 --> 00:52:01,290
though it's a 64 bit word size the data

832
00:51:57,360 --> 00:52:04,680
type int without any other qualifiers to

833
00:52:01,290 --> 00:52:07,350
it is just 32 bits so the sort of this

834
00:52:04,680 --> 00:52:10,500
mixture of how big things are so when

835
00:52:07,350 --> 00:52:12,570
people just say word or word size and

836
00:52:10,500 --> 00:52:15,000
let's say give a precise definition

837
00:52:12,570 --> 00:52:17,070
that's not a very meaningful term and

838
00:52:15,000 --> 00:52:19,380
we'll sort of throw it around when we

839
00:52:17,070 --> 00:52:21,570
mean sort of a generic chunk of bits

840
00:52:19,380 --> 00:52:25,280
without trying to assume that it has a

841
00:52:21,570 --> 00:52:25,280
particular number of bits to it

842
00:52:34,900 --> 00:52:43,700
yes so one of the things is if we ever

843
00:52:37,760 --> 00:52:47,300
get to 64-bit words it will be 16

844
00:52:43,700 --> 00:52:49,630
petabytes 18 petabytes opinion how you

845
00:52:47,300 --> 00:52:53,330
define when you those numbers get big

846
00:52:49,630 --> 00:52:57,890
the error due to this approximation gets

847
00:52:53,330 --> 00:53:00,140
more significant but something times 10

848
00:52:57,890 --> 00:53:12,200
to the 15th bytes but right now we can

849
00:53:00,140 --> 00:53:14,960
only get to 128 times 10 to the 12 so

850
00:53:12,200 --> 00:53:18,020
anyway it's the idea that the memory

851
00:53:14,960 --> 00:53:21,530
itself is a series of bytes but we can

852
00:53:18,020 --> 00:53:24,200
group those into blocks of words of

853
00:53:21,530 --> 00:53:29,300
different word sizes and the way we do

854
00:53:24,200 --> 00:53:33,800
that is usually by assuming that the the

855
00:53:29,300 --> 00:53:36,260
address of the word is the lowest valued

856
00:53:33,800 --> 00:53:41,410
address in it and we also will generally

857
00:53:36,260 --> 00:53:47,359
try to align these so that for example a

858
00:53:41,410 --> 00:53:50,510
32-bit word would be a line so its first

859
00:53:47,359 --> 00:53:53,770
byte its lowest byte has all zeros in

860
00:53:50,510 --> 00:53:53,770
the frick stuff

861
00:53:57,059 --> 00:54:05,759
in the first five bit positions right

862
00:54:01,569 --> 00:54:08,920
now 32 4 I'm sorry the lowest two bytes

863
00:54:05,759 --> 00:54:15,880
right so as this example shows their

864
00:54:08,920 --> 00:54:17,559
address is 0 4 8 and 12 they should have

865
00:54:15,880 --> 00:54:21,400
really written this in hex and said it's

866
00:54:17,559 --> 00:54:24,279
C I guess these are all in decimal

867
00:54:21,400 --> 00:54:27,849
anyhow so yeah these are decimal numbers

868
00:54:24,279 --> 00:54:31,349
so 0 4 8 12 so you see these are in

869
00:54:27,849 --> 00:54:33,970
multiples of 4 of bit boundaries and

870
00:54:31,349 --> 00:54:37,089
similarly the 64-bit words are in

871
00:54:33,970 --> 00:54:39,400
multiples of 8 and those are known as

872
00:54:37,089 --> 00:54:41,230
aligned words and will generally will

873
00:54:39,400 --> 00:54:43,150
see that the compiler works pretty hard

874
00:54:41,230 --> 00:54:44,980
to keep things aligned because the

875
00:54:43,150 --> 00:54:48,910
hardware runs more efficiently that way

876
00:54:44,980 --> 00:54:50,799
but the main point is that we can just

877
00:54:48,910 --> 00:54:52,720
take as many bytes as we want and

878
00:54:50,799 --> 00:54:57,700
collect them together and call it a word

879
00:54:52,720 --> 00:54:59,499
for whatever word size we need and as we

880
00:54:57,700 --> 00:55:01,539
think we saw a variant of this table

881
00:54:59,499 --> 00:55:05,319
before but this is the machines we'll be

882
00:55:01,539 --> 00:55:09,460
working on that the standard int is

883
00:55:05,319 --> 00:55:12,210
still only 32 bits but if we qualify

884
00:55:09,460 --> 00:55:15,880
something as being wrong then it will be

885
00:55:12,210 --> 00:55:17,069
64 bits and will tend to do that there's

886
00:55:15,880 --> 00:55:18,609
two different floating-point

887
00:55:17,069 --> 00:55:21,759
representations that we'll talk about

888
00:55:18,609 --> 00:55:25,480
and then the main feature of a 64 bit

889
00:55:21,759 --> 00:55:31,089
machine is it has an 8 byte or 64 bit

890
00:55:25,480 --> 00:55:35,170
pointer as compared to 32 now there's

891
00:55:31,089 --> 00:55:38,499
one other kind of detail that says ok so

892
00:55:35,170 --> 00:55:40,569
if a word has multiple bytes in it what

893
00:55:38,499 --> 00:55:44,980
order should those bytes be should it be

894
00:55:40,569 --> 00:55:48,029
the and these two basic ways this could

895
00:55:44,980 --> 00:55:50,589
go one is that you put the bytes in

896
00:55:48,029 --> 00:55:52,569
what's known as little endian order

897
00:55:50,589 --> 00:55:54,940
meaning that the first byte in the word

898
00:55:52,569 --> 00:55:57,880
is the least significant byte and then

899
00:55:54,940 --> 00:55:59,890
the next and then the next and the final

900
00:55:57,880 --> 00:56:03,970
byte in the word is the most significant

901
00:55:59,890 --> 00:56:05,589
or you can flip that around and those

902
00:56:03,970 --> 00:56:09,180
are called little-endian and big-endian

903
00:56:05,589 --> 00:56:09,180
is the

904
00:56:09,310 --> 00:56:18,609
the sort of terms for that which comes

905
00:56:12,099 --> 00:56:20,410
from a English book called Gulliver's

906
00:56:18,609 --> 00:56:23,680
Travels which didn't anticipate

907
00:56:20,410 --> 00:56:25,390
computers at all but it's an interesting

908
00:56:23,680 --> 00:56:27,609
story of how that comes about

909
00:56:25,390 --> 00:56:29,859
so in out there in the world you'll find

910
00:56:27,609 --> 00:56:32,589
both types of machines big Indian and

911
00:56:29,859 --> 00:56:34,780
little Indian machines it turns out that

912
00:56:32,589 --> 00:56:38,290
increasingly it's getting hard to find

913
00:56:34,780 --> 00:56:43,089
big Indian machines so little indeed all

914
00:56:38,290 --> 00:56:45,359
of x86 is little Indian and it turns out

915
00:56:43,089 --> 00:56:48,910
ARM processors like what you have in

916
00:56:45,359 --> 00:56:52,990
almost every cell phone here is an ARM

917
00:56:48,910 --> 00:56:54,910
processor and the hardware and those can

918
00:56:52,990 --> 00:56:58,839
actually be configured to run either way

919
00:56:54,910 --> 00:57:00,760
big-endian or little-endian but when

920
00:56:58,839 --> 00:57:02,560
you're running it on any of the standard

921
00:57:00,760 --> 00:57:06,790
operating systems that run on ARM

922
00:57:02,560 --> 00:57:10,030
processors then it's running little

923
00:57:06,790 --> 00:57:13,089
Indian so there used to be a brand

924
00:57:10,030 --> 00:57:16,750
called Sun Microsystems and they were

925
00:57:13,089 --> 00:57:20,230
fairly common on campus and then back in

926
00:57:16,750 --> 00:57:22,720
the Macintosh before they were x86

927
00:57:20,230 --> 00:57:26,710
processors they ran one called the

928
00:57:22,720 --> 00:57:28,839
PowerPC and that was a big engine

929
00:57:26,710 --> 00:57:32,260
machine but those are long in the

930
00:57:28,839 --> 00:57:34,990
distant past the internet about the only

931
00:57:32,260 --> 00:57:37,599
place out there when you send packets

932
00:57:34,990 --> 00:57:41,080
over the internet you want to send in

933
00:57:37,599 --> 00:57:43,690
32-bit words they're actually sent in

934
00:57:41,080 --> 00:57:46,000
big endian order and so at the network

935
00:57:43,690 --> 00:57:49,599
interface you have to translate between

936
00:57:46,000 --> 00:57:54,550
those two so again just to illustrate

937
00:57:49,599 --> 00:57:57,540
what I mean by this is think of a byte

938
00:57:54,550 --> 00:58:00,820
value for byte value like this and

939
00:57:57,540 --> 00:58:02,710
remember that the way we write numbers

940
00:58:00,820 --> 00:58:05,050
is we put the most significant to the

941
00:58:02,710 --> 00:58:07,260
left and the least significant to the

942
00:58:05,050 --> 00:58:07,260
right

943
00:58:09,059 --> 00:58:16,289
and so now with a big-endian inserted

944
00:58:13,380 --> 00:58:19,589
the intuitive one from that perspective

945
00:58:16,289 --> 00:58:22,019
in that the bike if you write the words

946
00:58:19,589 --> 00:58:24,719
in memory from the smallest address up

947
00:58:22,019 --> 00:58:27,659
to the highest the big endian will sort

948
00:58:24,719 --> 00:58:31,109
of map to what you see whereas the

949
00:58:27,659 --> 00:58:36,929
little endian will look confusing that

950
00:58:31,109 --> 00:58:38,819
you say 0 1 2 3 4 5 6 7 because 6 7 is

951
00:58:36,929 --> 00:58:40,890
actually the least significant byte here

952
00:58:38,819 --> 00:58:46,919
and so that comes first in little-endian

953
00:58:40,890 --> 00:58:48,900
order and and so the it used to be

954
00:58:46,919 --> 00:58:51,900
people would get in passionate arguments

955
00:58:48,900 --> 00:58:57,749
about this that sort of in the distant

956
00:58:51,900 --> 00:59:00,719
past but and people saying you know and

957
00:58:57,749 --> 00:59:02,880
the main feature in some sort of

958
00:59:00,719 --> 00:59:05,279
argument of big indian nuts is this

959
00:59:02,880 --> 00:59:08,219
feature here that when you look at it

960
00:59:05,279 --> 00:59:10,109
it's easier to write down but computers

961
00:59:08,219 --> 00:59:11,999
don't really care they're happy either

962
00:59:10,109 --> 00:59:14,039
way and so they just want one convention

963
00:59:11,999 --> 00:59:17,069
or another and like I said some

964
00:59:14,039 --> 00:59:19,619
hardware's can actually be a by a sort

965
00:59:17,069 --> 00:59:21,989
of flag to flip it from being big endian

966
00:59:19,619 --> 00:59:24,689
to little Indian but the reality is most

967
00:59:21,989 --> 00:59:27,929
of machines one counter you'll encounter

968
00:59:24,689 --> 00:59:30,709
a little endian machine stoudek but just

969
00:59:27,929 --> 00:59:33,569
to give you an example here's some

970
00:59:30,709 --> 00:59:36,809
results that I got from actual machines

971
00:59:33,569 --> 00:59:38,880
there used to be some machines around so

972
00:59:36,809 --> 00:59:41,159
back in the old days I could run this I

973
00:59:38,880 --> 00:59:44,039
don't even know where to get a big

974
00:59:41,159 --> 00:59:48,719
endian machine anymore so these are sort

975
00:59:44,039 --> 00:59:50,789
of legacy result but you'll see that the

976
00:59:48,719 --> 00:59:53,189
main feature is between a little Indian

977
00:59:50,789 --> 00:59:56,630
and a big endian machine when you have

978
00:59:53,189 --> 00:59:59,729
an integer the bikes get flipped around

979
00:59:56,630 --> 01:00:01,909
so that the re significant byte comes

980
00:59:59,729 --> 01:00:06,239
first in a little endian machine and

981
01:00:01,909 --> 01:00:09,239
last in a big endian machine and that's

982
01:00:06,239 --> 01:00:13,259
true with negative numbers as well that

983
01:00:09,239 --> 01:00:17,730
you'll get the sign bits first in a big

984
01:00:13,259 --> 01:00:22,440
endian machine a long

985
01:00:17,730 --> 01:00:25,320
you'll see that the only difference

986
01:00:22,440 --> 01:00:27,450
between a 32-bit machine the 64-bit

987
01:00:25,320 --> 01:00:29,280
machine is you have more zeros or more

988
01:00:27,450 --> 01:00:34,350
ones depending whether it's a positive

989
01:00:29,280 --> 01:00:37,710
or negative number and again the Sun and

990
01:00:34,350 --> 01:00:40,350
if I had access to a 64-bit machine Sun

991
01:00:37,710 --> 01:00:43,290
is now manufactured by a company called

992
01:00:40,350 --> 01:00:44,670
Oracle so in principle I could go get

993
01:00:43,290 --> 01:00:46,770
one of these machines and run this

994
01:00:44,670 --> 01:00:50,450
experiment but it's really not a very

995
01:00:46,770 --> 01:00:50,450
interesting experiment so I won't bother

996
01:00:50,660 --> 01:00:58,109
so in principle I could try it on a

997
01:00:53,400 --> 01:01:03,810
64-bit Oracle machine and show you

998
01:00:58,109 --> 01:01:06,840
something different so one thing that

999
01:01:03,810 --> 01:01:09,240
kind of a useful tool the book goes

1000
01:01:06,840 --> 01:01:13,290
through some examples of this is a

1001
01:01:09,240 --> 01:01:16,890
little program that will take a series

1002
01:01:13,290 --> 01:01:20,250
of bytes starting at some position start

1003
01:01:16,890 --> 01:01:24,240
and do it for however many bytes you

1004
01:01:20,250 --> 01:01:29,609
request and just print out in hex format

1005
01:01:24,240 --> 01:01:33,900
the two hex digits that represent that

1006
01:01:29,609 --> 01:01:37,619
bite valve and here this term pointer

1007
01:01:33,900 --> 01:01:42,650
I'm using an unsigned care as a pointer

1008
01:01:37,619 --> 01:01:42,650
type a sort of generic pointer type

1009
01:01:45,790 --> 01:01:57,440
and so again if I run this on a x86

1010
01:01:53,120 --> 01:01:59,210
machine oh oh and I'm also by the way

1011
01:01:57,440 --> 01:02:04,070
printing out the actual address that

1012
01:01:59,210 --> 01:02:06,070
this character is stored in too and so

1013
01:02:04,070 --> 01:02:11,150
you'll see that there is these addresses

1014
01:02:06,070 --> 01:02:13,850
with a lot of 7f of what that means is

1015
01:02:11,150 --> 01:02:15,950
it's in the upper end of this 47 bit

1016
01:02:13,850 --> 01:02:19,610
address space if you work it through

1017
01:02:15,950 --> 01:02:24,740
there's seven is three ones and then

1018
01:02:19,610 --> 01:02:28,610
there's enough hex digits here to

1019
01:02:24,740 --> 01:02:32,780
correspond to so there's 11 hex digits

1020
01:02:28,610 --> 01:02:34,940
beyond the seven and you'll see that

1021
01:02:32,780 --> 01:02:40,550
these addresses are at successive bytes

1022
01:02:34,940 --> 01:02:42,650
BC B DB EB F and the values are 63 B 0 0

1023
01:02:40,550 --> 01:02:49,060
0 0 this is the least significant byte

1024
01:02:42,650 --> 01:02:54,260
and these are the successive byte and a

1025
01:02:49,060 --> 01:02:57,140
similar I can I can use this to examine

1026
01:02:54,260 --> 01:02:58,880
pointers of various sorts and I can

1027
01:02:57,140 --> 01:03:02,510
examine different values and just get

1028
01:02:58,880 --> 01:03:04,880
their low-level byte representations and

1029
01:03:02,510 --> 01:03:06,650
so I did this back when I could get to a

1030
01:03:04,880 --> 01:03:08,570
Sun machine it had one way of

1031
01:03:06,650 --> 01:03:10,700
representing a pointer and the main

1032
01:03:08,570 --> 01:03:14,450
point is even across machines whether

1033
01:03:10,700 --> 01:03:16,130
it's a byte ordering or whatever you'll

1034
01:03:14,450 --> 01:03:17,930
get different values for pointers

1035
01:03:16,130 --> 01:03:20,360
there's no guarantee that when you load

1036
01:03:17,930 --> 01:03:22,820
them a computer program into one machine

1037
01:03:20,360 --> 01:03:26,570
and run it that it will use the same

1038
01:03:22,820 --> 01:03:28,400
addresses as that same programming

1039
01:03:26,570 --> 01:03:30,200
running on a different machine even if

1040
01:03:28,400 --> 01:03:33,280
actually they're identical hardware and

1041
01:03:30,200 --> 01:03:35,780
operating system there can be variation

1042
01:03:33,280 --> 01:03:38,330
because pointers aren't you can't

1043
01:03:35,780 --> 01:03:45,380
directly copy a pointer from one machine

1044
01:03:38,330 --> 01:03:47,780
to another on one thing about also is

1045
01:03:45,380 --> 01:03:51,620
regardless of byte ordering the ordering

1046
01:03:47,780 --> 01:03:54,560
of of characters is the same and so a

1047
01:03:51,620 --> 01:03:58,010
string in C is always represented by a

1048
01:03:54,560 --> 01:03:59,170
series of bytes where the final byte is

1049
01:03:58,010 --> 01:04:02,520
0

1050
01:03:59,170 --> 01:04:05,319
called null-terminated and the

1051
01:04:02,520 --> 01:04:07,869
individual bytes correspond to the

1052
01:04:05,319 --> 01:04:11,349
character codes for that number and

1053
01:04:07,869 --> 01:04:14,079
these character codes are just sometimes

1054
01:04:11,349 --> 01:04:16,540
called ASCII format which is a little

1055
01:04:14,079 --> 01:04:18,760
bit old-fashioned by the way there's

1056
01:04:16,540 --> 01:04:24,849
more modern character codes too that can

1057
01:04:18,760 --> 01:04:27,460
represent non English alphabets but the

1058
01:04:24,849 --> 01:04:31,690
C standard is still back in the days of

1059
01:04:27,460 --> 01:04:52,510
only supporting the the ASCII format

1060
01:04:31,690 --> 01:05:00,760
question uh-huh yes so this should have

1061
01:04:52,510 --> 01:05:04,030
been well no this is good so I'm casting

1062
01:05:00,760 --> 01:05:06,160
I want to show the for bite-size event

1063
01:05:04,030 --> 01:05:09,130
for because this is an int I'm

1064
01:05:06,160 --> 01:05:12,460
representing the pointer let's see the

1065
01:05:09,130 --> 01:05:16,299
code we're printing the pointer all this

1066
01:05:12,460 --> 01:05:20,530
notation % P is the directive to say

1067
01:05:16,299 --> 01:05:24,000
print out a pointer proposed right and %

1068
01:05:20,530 --> 01:05:27,849
X is the directive to print out a hex

1069
01:05:24,000 --> 01:05:30,280
representation so it's printing out both

1070
01:05:27,849 --> 01:05:32,380
the address the starting position of

1071
01:05:30,280 --> 01:05:35,470
that particular byte and the value of

1072
01:05:32,380 --> 01:05:38,040
that byte as two different things does

1073
01:05:35,470 --> 01:05:38,040
that answer your question

1074
01:05:39,549 --> 01:05:58,660
returning upper darker yes but remember

1075
01:05:52,880 --> 01:06:02,599
show bytes is being given a pointer and

1076
01:05:58,660 --> 01:06:04,750
a length and so what this is and what

1077
01:06:02,599 --> 01:06:08,480
it's saying is starting at that address

1078
01:06:04,750 --> 01:06:11,660
print out the next series of bytes for

1079
01:06:08,480 --> 01:06:14,180
me how many bytes I asked for and in

1080
01:06:11,660 --> 01:06:18,020
this case I'm I'm creating a pointer to

1081
01:06:14,180 --> 01:06:20,390
this integer but I want to show the the

1082
01:06:18,020 --> 01:06:22,970
bytes in that integer the four bytes

1083
01:06:20,390 --> 01:06:25,280
that make up that integer and that's why

1084
01:06:22,970 --> 01:06:33,410
I'm giving it the number four here

1085
01:06:25,280 --> 01:06:38,240
instead of eight is it yes it will be

1086
01:06:33,410 --> 01:06:41,210
and that's fine because in this code I'm

1087
01:06:38,240 --> 01:06:43,280
using the percent P directive to

1088
01:06:41,210 --> 01:06:46,549
designate how to print out the pointer

1089
01:06:43,280 --> 01:06:48,049
and that will print it as many bytes as

1090
01:06:46,549 --> 01:06:51,530
it takes for that particular machine

1091
01:06:48,049 --> 01:06:53,690
that it's running on so percent P is

1092
01:06:51,530 --> 01:06:55,760
actually a very handy directive if you

1093
01:06:53,690 --> 01:06:57,380
have to print addresses like for

1094
01:06:55,760 --> 01:06:59,869
debugging purposes or something because

1095
01:06:57,380 --> 01:07:04,839
it will automatically adapt to whatever

1096
01:06:59,869 --> 01:07:04,839
machine it's running on question

1097
01:07:06,820 --> 01:07:13,580
well I've defined it to be an unsigned

1098
01:07:09,710 --> 01:07:17,090
care here so type def is a way to

1099
01:07:13,580 --> 01:07:19,460
introduce a name for some of data type

1100
01:07:17,090 --> 01:07:24,320
right and so I've just declared a

1101
01:07:19,460 --> 01:07:28,850
pointer quote pointer to refer to an

1102
01:07:24,320 --> 01:07:32,960
unsigned care if you did a void star it

1103
01:07:28,850 --> 01:07:37,790
would not be happy with this reference

1104
01:07:32,960 --> 01:07:40,160
here right you can't you can't reference

1105
01:07:37,790 --> 01:07:41,870
a void star is just a way to pass around

1106
01:07:40,160 --> 01:07:44,240
a generic pointer but you can't actually

1107
01:07:41,870 --> 01:07:47,840
reference that element so what I'm

1108
01:07:44,240 --> 01:07:51,470
basically doing is saying this reference

1109
01:07:47,840 --> 01:07:53,360
is treated like an array you treat my

1110
01:07:51,470 --> 01:08:01,130
series of bytes is an array and print

1111
01:07:53,360 --> 01:08:08,050
out each of the bytes in that array and

1112
01:08:01,130 --> 01:08:11,140
so here where I'm a is a number and I'm

1113
01:08:08,050 --> 01:08:14,830
taking the address of that integer and

1114
01:08:11,140 --> 01:08:18,110
casting it to be an unsigned care star

1115
01:08:14,830 --> 01:08:19,970
so sort of a generic slightly generic

1116
01:08:18,110 --> 01:08:23,320
pointer but not quite as generic as void

1117
01:08:19,970 --> 01:08:25,940
star and then printing it up

1118
01:08:23,320 --> 01:08:32,420
was it good quite easy good questions by

1119
01:08:25,940 --> 01:08:35,000
the way okay so the point being that

1120
01:08:32,420 --> 01:08:39,290
strings are just strings and that's the

1121
01:08:35,000 --> 01:08:41,930
same from one machine to the next okay

1122
01:08:39,290 --> 01:08:44,870
let's finish up today with some puzzles

1123
01:08:41,930 --> 01:08:48,740
and these have this annoying way of

1124
01:08:44,870 --> 01:08:52,670
showing up on exams so it's worth being

1125
01:08:48,740 --> 01:08:54,620
able to do these kind of things and

1126
01:08:52,670 --> 01:08:58,630
you'll also notice I cleverly did not

1127
01:08:54,620 --> 01:08:58,630
include the answers in the slide

1128
01:09:00,199 --> 01:09:04,219
so you can't you can't just peek ahead

1129
01:09:02,660 --> 01:09:05,750
and figure out what the answers are so

1130
01:09:04,219 --> 01:09:07,190
let's just go through them but I

1131
01:09:05,750 --> 01:09:10,370
actually worked them out to make sure I

1132
01:09:07,190 --> 01:09:13,100
had the entry zone so if X and basically

1133
01:09:10,370 --> 01:09:15,949
these are sort of statements that you

1134
01:09:13,100 --> 01:09:18,529
want to say these are either always true

1135
01:09:15,949 --> 01:09:21,710
and maybe there's some logic behind why

1136
01:09:18,529 --> 01:09:24,020
it's always true or possibly false and

1137
01:09:21,710 --> 01:09:27,140
you won't have to give some example that

1138
01:09:24,020 --> 01:09:28,640
would make that false so let's go

1139
01:09:27,140 --> 01:09:32,390
through these as many as we have time

1140
01:09:28,640 --> 01:09:35,989
for and see where we get to so if I take

1141
01:09:32,390 --> 01:09:39,589
X and I double it multiply it by 2 if X

1142
01:09:35,989 --> 01:09:41,179
who are negative and my guaranteed that

1143
01:09:39,589 --> 01:09:47,000
2x will be negative

1144
01:09:41,179 --> 01:09:50,330
no so by the way one general way to find

1145
01:09:47,000 --> 01:09:53,330
counter examples is to try team in it's

1146
01:09:50,330 --> 01:09:55,640
a really good one and that works here

1147
01:09:53,330 --> 01:09:57,310
right if I take team n which is one and

1148
01:09:55,640 --> 01:10:00,020
a bunch of zeros I double it like

1149
01:09:57,310 --> 01:10:07,130
shifting it but left and it will become

1150
01:10:00,020 --> 01:10:09,410
what zero right is and so again assume

1151
01:10:07,130 --> 01:10:12,860
that X is that any negative number and

1152
01:10:09,410 --> 01:10:16,940
UX is it's unsigned I'm sorry

1153
01:10:12,860 --> 01:10:19,280
two's complement number and UX is what

1154
01:10:16,940 --> 01:10:21,170
happens if I cast it to be unsigned so

1155
01:10:19,280 --> 01:10:26,210
as u X always you're greater than or

1156
01:10:21,170 --> 01:10:31,699
equal to zero yeah that's slightly more

1157
01:10:26,210 --> 01:10:35,179
obscure if I take X and I mask off seven

1158
01:10:31,699 --> 01:10:38,440
you remember is the bit pattern 1 1 1 so

1159
01:10:35,179 --> 01:10:41,690
as I mask off all but the lowest 3 bits

1160
01:10:38,440 --> 01:10:43,910
and I find that those are all one I'm

1161
01:10:41,690 --> 01:10:47,540
already giving you the answer here and

1162
01:10:43,910 --> 01:10:50,980
then I shift it left by 30 position what

1163
01:10:47,540 --> 01:10:50,980
can I say about the result

1164
01:10:59,269 --> 01:11:21,320
so I know the ex must finish with 3:1

1165
01:11:04,760 --> 01:11:23,269
right and I shift that by 30 and this

1166
01:11:21,320 --> 01:11:26,090
these will be the only two bits that are

1167
01:11:23,269 --> 01:11:29,300
left after the shifting and they will be

1168
01:11:26,090 --> 01:11:32,449
in the most significant position so what

1169
01:11:29,300 --> 01:11:35,329
can I say about that number is negative

1170
01:11:32,449 --> 01:11:39,530
so this is a true statement rather

1171
01:11:35,329 --> 01:11:42,400
obscure but it is true is UX greater

1172
01:11:39,530 --> 01:11:42,400
than minus one

1173
01:11:44,559 --> 01:11:59,179
it's almost true right the one counter

1174
01:11:51,679 --> 01:12:01,159
example would be what the zoo well

1175
01:11:59,179 --> 01:12:03,469
actually no you're right there's a lot

1176
01:12:01,159 --> 01:12:04,639
of examples it's hardly ever true it's

1177
01:12:03,469 --> 01:12:07,460
almost always false

1178
01:12:04,639 --> 01:12:13,809
I was wrong the only thing that would

1179
01:12:07,460 --> 01:12:19,699
make it true would be XI it's never true

1180
01:12:13,809 --> 01:12:22,340
okay so it's never true okay if X is

1181
01:12:19,699 --> 01:12:24,909
greater than Y is minus X less than

1182
01:12:22,340 --> 01:12:24,909
minus y

1183
01:12:34,120 --> 01:12:40,700
No so by the way one thing we didn't

1184
01:12:38,090 --> 01:12:48,320
really cover is what is the negative of

1185
01:12:40,700 --> 01:12:58,700
tea men and to see that we can use our

1186
01:12:48,320 --> 01:13:03,620
complement income instrument trick so

1187
01:12:58,700 --> 01:13:07,010
when you compliment an increment T min

1188
01:13:03,620 --> 01:13:10,850
you get T min and that's why it's such a

1189
01:13:07,010 --> 01:13:18,880
great counter example so in particular

1190
01:13:10,850 --> 01:13:21,920
if Y is T min and X is something else

1191
01:13:18,880 --> 01:13:25,840
then that left-hand part will be true

1192
01:13:21,920 --> 01:13:25,840
but the right-hand part will not be true

1193
01:13:26,080 --> 01:13:33,130
okay x times X greater than or equal to

1194
01:13:28,790 --> 01:13:36,130
zero we've seen examples of that being

1195
01:13:33,130 --> 01:13:36,130
false

1196
01:13:36,919 --> 01:13:41,869
if X is it is just kind of silly if X is

1197
01:13:40,070 --> 01:13:47,090
greater than zero and Y is greater than

1198
01:13:41,869 --> 01:13:49,159
zero is X plus y greater than zero no if

1199
01:13:47,090 --> 01:13:53,260
X is greater than or equal to zero is

1200
01:13:49,159 --> 01:13:53,260
minus X less than or equal to zero

1201
01:13:53,530 --> 01:13:58,189
gotcha

1202
01:13:54,800 --> 01:14:01,969
you're right it's true right because

1203
01:13:58,189 --> 01:14:04,159
that but let's take it counterpart if X

1204
01:14:01,969 --> 01:14:07,820
is less than or equal to zero is minus x

1205
01:14:04,159 --> 01:14:10,340
squared equals zero team n right so

1206
01:14:07,820 --> 01:14:13,699
right the point being that the largest

1207
01:14:10,340 --> 01:14:16,369
any positive number can be represented

1208
01:14:13,699 --> 01:14:18,590
as negative but there's one negative

1209
01:14:16,369 --> 01:14:21,979
number that can't be represented as

1210
01:14:18,590 --> 01:14:25,610
positive and so that asymmetry is why

1211
01:14:21,979 --> 01:14:29,479
you get different answers to these if I

1212
01:14:25,610 --> 01:14:33,949
take X and I look at minus X and I shift

1213
01:14:29,479 --> 01:14:37,159
them to the right by 31 am I going to

1214
01:14:33,949 --> 01:14:39,579
get all ones this is a really weird

1215
01:14:37,159 --> 01:14:39,579
statement

1216
01:14:47,850 --> 01:14:54,360
so it actually kind of works right if I

1217
01:14:51,370 --> 01:14:54,360
take all zeros

1218
01:15:01,809 --> 01:15:07,800
and I subtract one I'll get minus one

1219
01:15:10,289 --> 01:15:28,780
and I or them that works so what's wrong

1220
01:15:19,780 --> 01:15:31,300
with this what's that oh but if I shift

1221
01:15:28,780 --> 01:15:44,940
it to the right 31 places that's going

1222
01:15:31,300 --> 01:15:48,639
to shift arithmetic aliy what's that oh

1223
01:15:44,940 --> 01:15:50,079
I see oh I'm sorry

1224
01:15:48,639 --> 01:15:56,829
I already jumped ahead to a different

1225
01:15:50,079 --> 01:15:58,829
puzzle X and minus X and I so you're

1226
01:15:56,829 --> 01:16:04,989
right actually

1227
01:15:58,829 --> 01:16:09,610
if the two numbers is zero and I or

1228
01:16:04,989 --> 01:16:12,539
those I get zero but you'll figure out

1229
01:16:09,610 --> 01:16:16,449
you'll notice if it's anything non zero

1230
01:16:12,539 --> 01:16:18,670
actually this will be true and that's an

1231
01:16:16,449 --> 01:16:20,710
interesting feature so there's a couple

1232
01:16:18,670 --> 01:16:22,510
other puzzles and I'll I'll let you

1233
01:16:20,710 --> 01:16:24,840
solve those on your own we're all set

1234
01:16:22,510 --> 01:16:24,840
for today

