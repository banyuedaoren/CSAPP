1
00:00:00,060 --> 00:00:08,130
good afternoon everyone so today we're

2
00:00:04,710 --> 00:00:11,219
going to transition into a topic that to

3
00:00:08,130 --> 00:00:15,420
me is sort of the reward for having

4
00:00:11,219 --> 00:00:17,940
slugged through all the low-level stuff

5
00:00:15,420 --> 00:00:21,380
you've done up to this point to be able

6
00:00:17,940 --> 00:00:25,080
to really understand and become adept at

7
00:00:21,380 --> 00:00:26,460
programming network software not these

8
00:00:25,080 --> 00:00:28,619
are lots of networking that we're not

9
00:00:26,460 --> 00:00:31,769
going to cover but at least to have some

10
00:00:28,619 --> 00:00:34,079
familiarity with it so I know that a lot

11
00:00:31,769 --> 00:00:35,670
of you are sort of in the midst of

12
00:00:34,079 --> 00:00:38,760
trying to figure out how to make Melek

13
00:00:35,670 --> 00:00:42,600
run and make it run fast and so this

14
00:00:38,760 --> 00:00:44,309
this of topic is really more pointing

15
00:00:42,600 --> 00:00:46,320
toward the future but it's very relevant

16
00:00:44,309 --> 00:00:49,559
to the final web you'll do for the

17
00:00:46,320 --> 00:00:52,190
course and so we're starting to to get

18
00:00:49,559 --> 00:00:52,190
ready for that

19
00:00:55,960 --> 00:01:01,010
so like I said this course is not really

20
00:00:59,239 --> 00:01:03,110
a full course in networking there's many

21
00:01:01,010 --> 00:01:05,479
other courses at the university that are

22
00:01:03,110 --> 00:01:07,340
and so what we're going to try and do is

23
00:01:05,479 --> 00:01:09,500
give you just a little flavor of it and

24
00:01:07,340 --> 00:01:11,840
particularly as everything in the course

25
00:01:09,500 --> 00:01:14,180
of programmers perspective so how you as

26
00:01:11,840 --> 00:01:19,850
a software developer would make use of

27
00:01:14,180 --> 00:01:25,880
the c-level api's that are relevant to

28
00:01:19,850 --> 00:01:28,180
network programming yeah why isn't this

29
00:01:25,880 --> 00:01:28,180
working

30
00:01:30,790 --> 00:01:38,659
so the idea behind most networking

31
00:01:36,560 --> 00:01:41,090
systems is what's called the

32
00:01:38,659 --> 00:01:43,040
client-server model and the idea is that

33
00:01:41,090 --> 00:01:46,400
there's the service out there that you

34
00:01:43,040 --> 00:01:48,770
want access to and you as a customer or

35
00:01:46,400 --> 00:01:51,700
a client are making a request to that

36
00:01:48,770 --> 00:01:55,130
server so an example would be when you

37
00:01:51,700 --> 00:01:57,950
order something on Amazon Amazon has a

38
00:01:55,130 --> 00:02:00,470
bunch of servers and you go to your web

39
00:01:57,950 --> 00:02:05,330
browser and content it contacts the

40
00:02:00,470 --> 00:02:07,490
Amazon a web server and you make

41
00:02:05,330 --> 00:02:10,369
transactions you request something you

42
00:02:07,490 --> 00:02:13,610
provide information and it gives you

43
00:02:10,369 --> 00:02:15,950
back pretty pictures of things you might

44
00:02:13,610 --> 00:02:18,019
want to buy it acknowledges your credit

45
00:02:15,950 --> 00:02:20,480
card transactions those are all very

46
00:02:18,019 --> 00:02:23,720
classic client-server types of

47
00:02:20,480 --> 00:02:25,940
interactions you as the client Amazon is

48
00:02:23,720 --> 00:02:29,390
the server another interesting example

49
00:02:25,940 --> 00:02:31,400
is a telephone so if you think about it

50
00:02:29,390 --> 00:02:34,790
a telephone is both a client and a

51
00:02:31,400 --> 00:02:37,670
server in that when I'm making a placing

52
00:02:34,790 --> 00:02:40,850
a call to somebody else I'm the client

53
00:02:37,670 --> 00:02:41,510
and that person's phone is the server

54
00:02:40,850 --> 00:02:45,320
right

55
00:02:41,510 --> 00:02:48,200
it's sitting there waiting for calls to

56
00:02:45,320 --> 00:02:51,440
come in and when that call comes in it

57
00:02:48,200 --> 00:02:54,290
makes a connection we talk over the

58
00:02:51,440 --> 00:02:56,360
phone and then I hang up either side

59
00:02:54,290 --> 00:02:59,180
hangs up so there's a lot of instances

60
00:02:56,360 --> 00:03:01,480
out there of some variation of client

61
00:02:59,180 --> 00:03:04,519
and server and it's a much richer idea

62
00:03:01,480 --> 00:03:06,890
in that you can often switch back and

63
00:03:04,519 --> 00:03:10,600
forth the roles of those two parties but

64
00:03:06,890 --> 00:03:13,640
it's a pretty universal and a ubiquitous

65
00:03:10,600 --> 00:03:17,870
way of thinking about how to set up a

66
00:03:13,640 --> 00:03:23,540
network system so in general then the

67
00:03:17,870 --> 00:03:26,359
idea is that there's a working the

68
00:03:23,540 --> 00:03:29,660
client is making some requests to the

69
00:03:26,359 --> 00:03:32,060
server the server does something locally

70
00:03:29,660 --> 00:03:35,120
to deal with it it receives it gets

71
00:03:32,060 --> 00:03:36,769
information that retrieves from its

72
00:03:35,120 --> 00:03:39,680
database the things you might want to

73
00:03:36,769 --> 00:03:42,140
buy and then it sends back information

74
00:03:39,680 --> 00:03:43,430
saying nicely formatted

75
00:03:42,140 --> 00:03:46,340
Paige with all kinds of shopping

76
00:03:43,430 --> 00:03:50,600
suggestions and then the client decides

77
00:03:46,340 --> 00:03:55,400
what to do next so from a hardware

78
00:03:50,600 --> 00:03:58,640
perspective the interface to a between

79
00:03:55,400 --> 00:04:01,340
the network and your computer is called

80
00:03:58,640 --> 00:04:06,560
the NIC or network interface card even

81
00:04:01,340 --> 00:04:08,600
though it's not always on a card and we

82
00:04:06,560 --> 00:04:12,319
really won't talk about hardware at all

83
00:04:08,600 --> 00:04:17,090
but what's most interesting from it is

84
00:04:12,319 --> 00:04:22,070
that it looks to your computer like an

85
00:04:17,090 --> 00:04:24,830
i/o device and in fact the UNIX of API

86
00:04:22,070 --> 00:04:27,860
for dealing with networks makes it look

87
00:04:24,830 --> 00:04:32,930
like a file so in particular just as a

88
00:04:27,860 --> 00:04:36,080
disc sits off of a bus and you write

89
00:04:32,930 --> 00:04:38,750
data to a disk or you read it from a

90
00:04:36,080 --> 00:04:41,930
disk similarly it the network sits off

91
00:04:38,750 --> 00:04:43,760
of a similar bus and when you want to

92
00:04:41,930 --> 00:04:46,970
send a message you actually do it by

93
00:04:43,760 --> 00:04:49,520
writing to a sort of virtual file that's

94
00:04:46,970 --> 00:04:51,350
called the network and if you want when

95
00:04:49,520 --> 00:04:54,440
you're receiving data you do it by

96
00:04:51,350 --> 00:04:56,210
reading and so just as several weeks ago

97
00:04:54,440 --> 00:04:58,760
I gave the lecture on Io

98
00:04:56,210 --> 00:05:00,770
it turns out that it's extremely

99
00:04:58,760 --> 00:05:03,560
relevant to network programming and

100
00:05:00,770 --> 00:05:07,250
that's the basic model that that was

101
00:05:03,560 --> 00:05:08,510
created by the early developers of the

102
00:05:07,250 --> 00:05:10,729
sort of standard UNIX

103
00:05:08,510 --> 00:05:12,620
and now that carried over not just to

104
00:05:10,729 --> 00:05:20,120
UNIX but it's the same model for Windows

105
00:05:12,620 --> 00:05:22,220
and other operating systems so and now

106
00:05:20,120 --> 00:05:25,640
let's just talk a little about what

107
00:05:22,220 --> 00:05:29,300
computer networking means the idea of a

108
00:05:25,640 --> 00:05:32,660
network is it's a collection of systems

109
00:05:29,300 --> 00:05:35,300
that are referred to as hosts that are

110
00:05:32,660 --> 00:05:39,740
able to communicate with each other over

111
00:05:35,300 --> 00:05:42,560
some kind of communication fabric let's

112
00:05:39,740 --> 00:05:46,430
call it communication system and they're

113
00:05:42,560 --> 00:05:48,830
sort of partitioned into mostly referred

114
00:05:46,430 --> 00:05:51,919
to as lands or local area networks that

115
00:05:48,830 --> 00:05:54,009
you establish within a small region and

116
00:05:51,919 --> 00:05:57,069
then a wide area network we

117
00:05:54,009 --> 00:06:01,689
would be over something the size of a

118
00:05:57,069 --> 00:06:04,449
city or perhaps more and over a

119
00:06:01,689 --> 00:06:06,990
Enterprise such as CMU it's a very

120
00:06:04,449 --> 00:06:11,830
complex set of for example there's

121
00:06:06,990 --> 00:06:14,110
wireless base stations that right in

122
00:06:11,830 --> 00:06:15,969
this room that you're interacting with

123
00:06:14,110 --> 00:06:18,999
when you're using a wireless system or

124
00:06:15,969 --> 00:06:20,710
your your phone and then there's a whole

125
00:06:18,999 --> 00:06:23,110
networking infrastructure within the

126
00:06:20,710 --> 00:06:26,499
university that then goes to some

127
00:06:23,110 --> 00:06:30,189
commercial providers AT&T in particular

128
00:06:26,499 --> 00:06:32,020
that give it access to the the

129
00:06:30,189 --> 00:06:33,849
commercial internet and then there's

130
00:06:32,020 --> 00:06:36,759
another set of network connections

131
00:06:33,849 --> 00:06:38,139
hosted by the supercomputing Center that

132
00:06:36,759 --> 00:06:40,419
give you access to what's called

133
00:06:38,139 --> 00:06:42,120
Internet 2 which is the resource that's

134
00:06:40,419 --> 00:06:46,870
used for communicating among

135
00:06:42,120 --> 00:06:48,550
universities so underneath you know when

136
00:06:46,870 --> 00:06:50,129
you're doing your networking stuff

137
00:06:48,550 --> 00:06:53,800
there's this amazingly complex

138
00:06:50,129 --> 00:06:56,889
combination of things going on the idea

139
00:06:53,800 --> 00:07:00,610
of an Internet is supposed is refers to

140
00:06:56,889 --> 00:07:03,309
the idea the general idea of a network

141
00:07:00,610 --> 00:07:05,409
of networks taking for example the local

142
00:07:03,309 --> 00:07:08,229
area network that this base station

143
00:07:05,409 --> 00:07:10,330
provides and connecting it up to other

144
00:07:08,229 --> 00:07:13,569
networks on campus and across the world

145
00:07:10,330 --> 00:07:16,839
and when we refer to the capital I

146
00:07:13,569 --> 00:07:19,659
internet that refers to the one instance

147
00:07:16,839 --> 00:07:20,289
the the most significant instance of an

148
00:07:19,659 --> 00:07:23,439
Internet

149
00:07:20,289 --> 00:07:25,620
so lowercase I means the sort of general

150
00:07:23,439 --> 00:07:29,259
idea of creating a network of networks

151
00:07:25,620 --> 00:07:32,649
uppercase I is the specific example that

152
00:07:29,259 --> 00:07:34,629
we all know and use all the time that's

153
00:07:32,649 --> 00:07:36,159
organized by a certain set of principles

154
00:07:34,629 --> 00:07:38,919
that uses a particularly set of

155
00:07:36,159 --> 00:07:41,919
protocols and so forth and of course we

156
00:07:38,919 --> 00:07:43,839
tend to just talk the internet and most

157
00:07:41,919 --> 00:07:47,759
people know that what that really

158
00:07:43,839 --> 00:07:51,939
implies is the sort of existing network

159
00:07:47,759 --> 00:07:53,439
structure that there is and that's good

160
00:07:51,939 --> 00:07:54,639
enough first through the purpose of this

161
00:07:53,439 --> 00:07:56,620
course we're not going to talk much

162
00:07:54,639 --> 00:08:00,069
about other possible designs one might

163
00:07:56,620 --> 00:08:02,560
have for a network so most of the low

164
00:08:00,069 --> 00:08:05,589
level networking is supported by

165
00:08:02,560 --> 00:08:07,750
something called Ethernet and the term

166
00:08:05,589 --> 00:08:11,170
Ethernet actually has evolved tremendous

167
00:08:07,750 --> 00:08:13,030
over time so that it's almost more like

168
00:08:11,170 --> 00:08:15,010
a brand name that it is a specific

169
00:08:13,030 --> 00:08:18,370
technology and the version you're

170
00:08:15,010 --> 00:08:23,860
familiar with the wired version of it

171
00:08:18,370 --> 00:08:27,280
you have a wire to some sort of a box

172
00:08:23,860 --> 00:08:29,740
like that you plug the your ethernet

173
00:08:27,280 --> 00:08:32,950
jacks into and historically those were

174
00:08:29,740 --> 00:08:35,229
called hubs and the idea of a hub was it

175
00:08:32,950 --> 00:08:36,849
was just a repeater that whatever came

176
00:08:35,229 --> 00:08:38,890
into it from one computer it would

177
00:08:36,849 --> 00:08:41,409
broadcast to all the connected machines

178
00:08:38,890 --> 00:08:45,970
and so you only want to do this for

179
00:08:41,409 --> 00:08:48,010
maybe a a dozen or so machines that it's

180
00:08:45,970 --> 00:08:50,800
like a party-line they're all hearing

181
00:08:48,010 --> 00:08:52,600
what everybody else is saying and in

182
00:08:50,800 --> 00:08:55,650
fact the original first version the

183
00:08:52,600 --> 00:08:59,890
ethernet did that by everyone

184
00:08:55,650 --> 00:09:02,110
interacting over a single cable carrying

185
00:08:59,890 --> 00:09:04,960
essentially radio sweet signals and

186
00:09:02,110 --> 00:09:07,450
similarly when you're in this room using

187
00:09:04,960 --> 00:09:09,540
a wireless internet the wireless

188
00:09:07,450 --> 00:09:14,400
internet is sort of like a hub and that

189
00:09:09,540 --> 00:09:16,600
all the packets that you're sending all

190
00:09:14,400 --> 00:09:18,760
across the room they're all sort of

191
00:09:16,600 --> 00:09:21,310
making use of the same radio frequencies

192
00:09:18,760 --> 00:09:23,890
the same communication channel and

193
00:09:21,310 --> 00:09:26,800
there's a protocol for how they detect

194
00:09:23,890 --> 00:09:28,360
when two messages get set at the same

195
00:09:26,800 --> 00:09:31,600
time and therefore interfere with each

196
00:09:28,360 --> 00:09:35,970
other so that can only sort of scale up

197
00:09:31,600 --> 00:09:35,970
to maybe at most a hundred different

198
00:09:36,000 --> 00:09:40,890
hosts communicating because they're all

199
00:09:38,890 --> 00:09:44,650
sharing a single communication channel

200
00:09:40,890 --> 00:09:47,890
now in the wired world what's evolved is

201
00:09:44,650 --> 00:09:50,140
usually when you buy a box or you get

202
00:09:47,890 --> 00:09:51,880
one from your cable company with all

203
00:09:50,140 --> 00:09:57,720
those ports in it it's actually called a

204
00:09:51,880 --> 00:09:57,720
router or sometimes a switch in that it

205
00:09:58,170 --> 00:10:05,380
it doesn't broadcast to everyone it

206
00:10:02,130 --> 00:10:07,300
selectively tries to guess is this

207
00:10:05,380 --> 00:10:11,290
particular message bound for this

208
00:10:07,300 --> 00:10:13,900
particular host and only send to that

209
00:10:11,290 --> 00:10:16,959
one and as you know you can take these

210
00:10:13,900 --> 00:10:20,230
and wire up I think about up to six

211
00:10:16,959 --> 00:10:21,220
levels deep in and hops and basically

212
00:10:20,230 --> 00:10:25,449
create a net

213
00:10:21,220 --> 00:10:27,310
work of wired connections and they'll

214
00:10:25,449 --> 00:10:30,220
all get from one to the other somehow

215
00:10:27,310 --> 00:10:32,579
and then after that it gets more

216
00:10:30,220 --> 00:10:34,720
complicated you can add more

217
00:10:32,579 --> 00:10:38,230
sophisticated types of switching on top

218
00:10:34,720 --> 00:10:39,970
of it but so the general idea of even an

219
00:10:38,230 --> 00:10:42,519
Ethernet is actually a fairly complex

220
00:10:39,970 --> 00:10:44,439
thing but it's some sort of conceptual

221
00:10:42,519 --> 00:10:46,810
level we can just think of it as a bunch

222
00:10:44,439 --> 00:10:51,519
of hosts that can talk directly to one

223
00:10:46,810 --> 00:10:54,160
another and then an internet then refers

224
00:10:51,519 --> 00:10:56,220
to the idea of taking those local area

225
00:10:54,160 --> 00:10:59,199
networks and connecting them together

226
00:10:56,220 --> 00:11:02,230
via routers and routers obey a

227
00:10:59,199 --> 00:11:06,449
particular protocol based on the address

228
00:11:02,230 --> 00:11:11,709
that you're trying to send data to and

229
00:11:06,449 --> 00:11:14,649
and so what you end up with conceptually

230
00:11:11,709 --> 00:11:16,660
is a whole bunch of hosts spread

231
00:11:14,649 --> 00:11:20,079
potentially all across the world and

232
00:11:16,660 --> 00:11:22,389
then some magical system of routers that

233
00:11:20,079 --> 00:11:25,509
will get a message from one place to the

234
00:11:22,389 --> 00:11:28,720
other based on a mode of addressing

235
00:11:25,509 --> 00:11:30,519
where there's some known address of the

236
00:11:28,720 --> 00:11:35,230
hosts that you're trying to send to and

237
00:11:30,519 --> 00:11:37,029
it will hop through multiple routers to

238
00:11:35,230 --> 00:11:39,269
get from one place to the other and

239
00:11:37,029 --> 00:11:43,449
that's true whether it's on campus

240
00:11:39,269 --> 00:11:46,389
or whether it's hopping all the way

241
00:11:43,449 --> 00:11:49,089
around the world and so again there's

242
00:11:46,389 --> 00:11:50,680
this huge body of information to

243
00:11:49,089 --> 00:11:53,529
knowledge about how that routing works

244
00:11:50,680 --> 00:11:55,420
and how its reliable and all that but

245
00:11:53,529 --> 00:11:57,430
we're going to just assume that somebody

246
00:11:55,420 --> 00:11:59,189
else's figured that out and our job as

247
00:11:57,430 --> 00:12:03,389
programmers is just to be able to

248
00:11:59,189 --> 00:12:03,389
communicate from one host to another

249
00:12:05,460 --> 00:12:11,089
and so how could you design a system

250
00:12:08,580 --> 00:12:12,899
where all these diverse systems made by

251
00:12:11,089 --> 00:12:15,000
computers made by different

252
00:12:12,899 --> 00:12:16,910
manufacturers operating under different

253
00:12:15,000 --> 00:12:20,820
countries with different

254
00:12:16,910 --> 00:12:22,560
telecommunications bodies governing

255
00:12:20,820 --> 00:12:25,680
bodies and so forth how can they all

256
00:12:22,560 --> 00:12:27,029
work with each other and the requirement

257
00:12:25,680 --> 00:12:29,160
is you have to have a protocol you have

258
00:12:27,029 --> 00:12:32,610
to have some common set of conventions

259
00:12:29,160 --> 00:12:36,089
for what messages look like how they get

260
00:12:32,610 --> 00:12:38,760
sent what happens if one of them doesn't

261
00:12:36,089 --> 00:12:45,959
make it how do you recover from that and

262
00:12:38,760 --> 00:12:47,880
so forth and so what does the protocol

263
00:12:45,959 --> 00:12:50,580
include well it has to include some way

264
00:12:47,880 --> 00:12:52,110
of naming things so that if I want to

265
00:12:50,580 --> 00:12:55,620
send to some host I have some way of

266
00:12:52,110 --> 00:12:57,870
designating who that host is and then

267
00:12:55,620 --> 00:13:00,180
there's the routing system has to have

268
00:12:57,870 --> 00:13:03,930
some reliable way of getting my data to

269
00:13:00,180 --> 00:13:07,200
that named host and that's the delivery

270
00:13:03,930 --> 00:13:10,050
mechanism and that's usually done and

271
00:13:07,200 --> 00:13:12,810
one of the things that we now accept is

272
00:13:10,050 --> 00:13:15,089
as universal but it really wasn't when

273
00:13:12,810 --> 00:13:17,040
it first came out was idea of you take

274
00:13:15,089 --> 00:13:19,080
all your data and you divide it into

275
00:13:17,040 --> 00:13:22,680
packets and packets are typically about

276
00:13:19,080 --> 00:13:24,600
a thousand to two thousand bytes and so

277
00:13:22,680 --> 00:13:27,209
if you have a longer message it chops it

278
00:13:24,600 --> 00:13:29,430
up into individual packets and sends it

279
00:13:27,209 --> 00:13:31,950
across and all the communication occurs

280
00:13:29,430 --> 00:13:35,400
in a packet level that's different than

281
00:13:31,950 --> 00:13:37,830
the historic phone system was a

282
00:13:35,400 --> 00:13:40,980
connection based system meaning that if

283
00:13:37,830 --> 00:13:44,160
I was calling somebody there is a

284
00:13:40,980 --> 00:13:46,200
dedicated wire set of wires maintained

285
00:13:44,160 --> 00:13:48,680
by the phone company that would be

286
00:13:46,200 --> 00:13:51,029
reserved and locked down for our own use

287
00:13:48,680 --> 00:13:53,060
during the entire duration of that phone

288
00:13:51,029 --> 00:13:53,060
call

289
00:13:55,790 --> 00:14:05,790
so to get then from one host say A to B

290
00:14:02,900 --> 00:14:08,670
what happens is we want to send a packet

291
00:14:05,790 --> 00:14:12,360
and that packet will contain some amount

292
00:14:08,670 --> 00:14:14,010
of data and the idea of packet

293
00:14:12,360 --> 00:14:16,620
communication then is you put little

294
00:14:14,010 --> 00:14:18,300
headers on that contains to the routing

295
00:14:16,620 --> 00:14:20,010
information the equivalent of what you'd

296
00:14:18,300 --> 00:14:23,220
see on the front of an envelope of a

297
00:14:20,010 --> 00:14:25,050
letter perhaps and so and at different

298
00:14:23,220 --> 00:14:27,470
points in the way they'll have different

299
00:14:25,050 --> 00:14:29,970
numbers of headers and different

300
00:14:27,470 --> 00:14:32,280
protocols or formats for what those

301
00:14:29,970 --> 00:14:36,720
headers look like so in particular

302
00:14:32,280 --> 00:14:39,780
within I wanted to send a message you

303
00:14:36,720 --> 00:14:41,850
know I'll do that and then the software

304
00:14:39,780 --> 00:14:44,510
that runs on my machine that handles

305
00:14:41,850 --> 00:14:50,070
this will put a header in front of that

306
00:14:44,510 --> 00:14:52,200
that describes the internet routing and

307
00:14:50,070 --> 00:14:54,000
then it will tack a header in front of

308
00:14:52,200 --> 00:14:56,610
that that talks about the local area

309
00:14:54,000 --> 00:15:00,030
network routing that gets used so that's

310
00:14:56,610 --> 00:15:01,830
what's referred to as the a P hat H the

311
00:15:00,030 --> 00:15:04,800
packet header for the Internet Protocol

312
00:15:01,830 --> 00:15:07,290
and f h1 the frame header for this

313
00:15:04,800 --> 00:15:11,910
particular message being sent within

314
00:15:07,290 --> 00:15:16,050
this local network and then the network

315
00:15:11,910 --> 00:15:18,680
interface card or the adapter here is

316
00:15:16,050 --> 00:15:22,220
then responsible for putting that out

317
00:15:18,680 --> 00:15:24,810
over this local communication of

318
00:15:22,220 --> 00:15:28,590
capability and then that gets received

319
00:15:24,810 --> 00:15:32,610
at the other end by the network adapter

320
00:15:28,590 --> 00:15:39,510
at the receivers direction it will put

321
00:15:32,610 --> 00:15:43,800
up its own frame header on it to pass it

322
00:15:39,510 --> 00:15:48,000
in and that then gets tripped off so

323
00:15:43,800 --> 00:15:50,130
that all hosts B C's is the data that

324
00:15:48,000 --> 00:15:53,340
gets sent but this idea of putting

325
00:15:50,130 --> 00:15:55,890
headers in front and at the time sort of

326
00:15:53,340 --> 00:15:58,320
what they call encapsulation that I'll

327
00:15:55,890 --> 00:16:00,390
take this big packet and I'll just tack

328
00:15:58,320 --> 00:16:01,140
some more information on top to the

329
00:16:00,390 --> 00:16:03,660
front of it

330
00:16:01,140 --> 00:16:04,830
header information and I'll send through

331
00:16:03,660 --> 00:16:08,120
the rest of it just

332
00:16:04,830 --> 00:16:08,120
as a set of bytes

333
00:16:13,280 --> 00:16:19,650
so the internet that we know and love

334
00:16:17,160 --> 00:16:21,480
the capital I internet then has a

335
00:16:19,650 --> 00:16:24,120
particular set of protocols that are

336
00:16:21,480 --> 00:16:26,310
you've probably heard the terms one is

337
00:16:24,120 --> 00:16:29,370
called the IP the Internet Protocol

338
00:16:26,310 --> 00:16:31,650
which is the one that defines ideas

339
00:16:29,370 --> 00:16:35,010
about how do you get how do you name

340
00:16:31,650 --> 00:16:37,560
hosts on the Internet and how do you

341
00:16:35,010 --> 00:16:41,760
send packets and they're referred to

342
00:16:37,560 --> 00:16:44,760
sometimes as datagrams meaning that a

343
00:16:41,760 --> 00:16:49,650
packet is just a single entity that gets

344
00:16:44,760 --> 00:16:52,410
sent from point A to point B and the

345
00:16:49,650 --> 00:16:56,010
underlying IP doesn't guarantee delivery

346
00:16:52,410 --> 00:17:00,180
so it's based on what they call best

347
00:16:56,010 --> 00:17:04,110
effort of communication meaning that at

348
00:17:00,180 --> 00:17:06,000
each step along the way if for example

349
00:17:04,110 --> 00:17:07,650
things are good then it will just send

350
00:17:06,000 --> 00:17:10,670
this packet along if there's too much

351
00:17:07,650 --> 00:17:12,540
congestion there's been a you know

352
00:17:10,670 --> 00:17:15,600
somebody's turned on their microwave

353
00:17:12,540 --> 00:17:19,140
oven and it's set up some radiofrequency

354
00:17:15,600 --> 00:17:21,630
interface interference then at the IP

355
00:17:19,140 --> 00:17:24,660
level it just drops that packet and says

356
00:17:21,630 --> 00:17:27,920
whoops I screwed up sorry it doesn't

357
00:17:24,660 --> 00:17:30,630
even say sorry it just does it silently

358
00:17:27,920 --> 00:17:33,300
and then you can as a programmer make

359
00:17:30,630 --> 00:17:35,640
use of that very low level so normally

360
00:17:33,300 --> 00:17:37,890
as a programmer you don't really want to

361
00:17:35,640 --> 00:17:39,600
program at that level because you'll

362
00:17:37,890 --> 00:17:41,910
send packets and they will get there but

363
00:17:39,600 --> 00:17:45,960
you can if you want to and it's called

364
00:17:41,910 --> 00:17:48,330
UDP a protocol it's just a small

365
00:17:45,960 --> 00:17:50,490
software layer over IP and there's some

366
00:17:48,330 --> 00:17:52,350
applications that you'll see for example

367
00:17:50,490 --> 00:17:55,770
in the computer game world where you

368
00:17:52,350 --> 00:17:57,480
want to send information really fast and

369
00:17:55,770 --> 00:17:59,280
if some information gets dropped it's

370
00:17:57,480 --> 00:18:01,770
not a big deal that people actually

371
00:17:59,280 --> 00:18:04,800
program at that level we won't really

372
00:18:01,770 --> 00:18:07,770
talk about that the more common protocol

373
00:18:04,800 --> 00:18:10,050
that gets used and carries 99% of

374
00:18:07,770 --> 00:18:12,570
Internet traffic is what's called TCP or

375
00:18:10,050 --> 00:18:15,390
transmission control protocol and that

376
00:18:12,570 --> 00:18:18,390
provides the reliable the the equivalent

377
00:18:15,390 --> 00:18:22,200
of telephone connections that I can

378
00:18:18,390 --> 00:18:23,670
reliably send data from point A to point

379
00:18:22,200 --> 00:18:27,480
B

380
00:18:23,670 --> 00:18:30,390
as many vices are like it's guaranteed

381
00:18:27,480 --> 00:18:33,000
delivery it's sometimes fast and

382
00:18:30,390 --> 00:18:36,780
sometimes not but it's there and it's

383
00:18:33,000 --> 00:18:38,580
built on top of the IP of this Datagram

384
00:18:36,780 --> 00:18:40,500
meaning that it has to take whatever

385
00:18:38,580 --> 00:18:42,990
you're sending and slice it up into the

386
00:18:40,500 --> 00:18:45,660
single packets if one of them doesn't

387
00:18:42,990 --> 00:18:48,210
get sent it will resend it until it gets

388
00:18:45,660 --> 00:18:50,400
there they have to deal with the fact

389
00:18:48,210 --> 00:18:53,040
that packets can travel different paths

390
00:18:50,400 --> 00:18:54,930
and one can get ahead of the other in

391
00:18:53,040 --> 00:18:57,480
transmission and so it has to reorder

392
00:18:54,930 --> 00:18:59,300
them in the correct sequence and so

393
00:18:57,480 --> 00:19:01,620
there's a lot of stuff under it but

394
00:18:59,300 --> 00:19:04,590
we'll just assume that it kind of works

395
00:19:01,620 --> 00:19:07,320
and so you can just rely think about it

396
00:19:04,590 --> 00:19:09,780
is I have a stream connection I can send

397
00:19:07,320 --> 00:19:14,510
from A to B and B can send a stream of

398
00:19:09,780 --> 00:19:17,070
data back to me and we're all happy and

399
00:19:14,510 --> 00:19:19,860
so that's the version that looks like

400
00:19:17,070 --> 00:19:22,020
file i/o I just keep writing to a file

401
00:19:19,860 --> 00:19:25,590
and it's sending packets over the

402
00:19:22,020 --> 00:19:27,900
network to the other end and then the

403
00:19:25,590 --> 00:19:29,850
other side can be sending stuff to me

404
00:19:27,900 --> 00:19:32,610
and I'm just reading it and I'm just

405
00:19:29,850 --> 00:19:34,590
reading bytes of data not worrying about

406
00:19:32,610 --> 00:19:37,800
how that got broken up into individual

407
00:19:34,590 --> 00:19:40,290
packets and so that's referred to as the

408
00:19:37,800 --> 00:19:41,820
sockets interface and you'll hear the

409
00:19:40,290 --> 00:19:45,080
term socket programming and that's

410
00:19:41,820 --> 00:19:45,080
exactly what we're talking about

411
00:19:47,809 --> 00:19:58,919
and so from a sort of software system

412
00:19:55,740 --> 00:20:00,840
than software hardware system then the

413
00:19:58,919 --> 00:20:03,600
client and the server are both

414
00:20:00,840 --> 00:20:07,200
implemented as application programs at

415
00:20:03,600 --> 00:20:11,880
the respective endpoints on their hosts

416
00:20:07,200 --> 00:20:15,809
and they make use of of software and

417
00:20:11,880 --> 00:20:17,659
libraries that run some combination of

418
00:20:15,809 --> 00:20:20,220
the user level and at the kernel level

419
00:20:17,659 --> 00:20:26,340
and therefore I have access to direct

420
00:20:20,220 --> 00:20:28,169
resources and so I is a program or an

421
00:20:26,340 --> 00:20:33,000
application programmer then make use of

422
00:20:28,169 --> 00:20:36,230
this software API that lets me do socket

423
00:20:33,000 --> 00:20:40,490
programming and it's based on gives

424
00:20:36,230 --> 00:20:40,490
directly supports tcp/ip

425
00:20:42,440 --> 00:20:48,290
so first of all we're going to talk most

426
00:20:45,630 --> 00:20:50,670
of the time about what called ipv4 a

427
00:20:48,290 --> 00:20:54,450
version 4 which is the one that's been

428
00:20:50,670 --> 00:20:58,680
running for since the 1980s I think

429
00:20:54,450 --> 00:21:01,440
early 1980s and is the standard and

430
00:20:58,680 --> 00:21:03,990
we'll talk very only mentioned very

431
00:21:01,440 --> 00:21:06,050
briefly the idea of what's called ipv6

432
00:21:03,990 --> 00:21:11,070
which is sort of a next-generation

433
00:21:06,050 --> 00:21:13,620
version so the idea of a ipv4 and this

434
00:21:11,070 --> 00:21:15,810
is now we're talking about IP and and

435
00:21:13,620 --> 00:21:21,240
this is true of TCP as well is that an

436
00:21:15,810 --> 00:21:22,770
address is actually just 32 bits but

437
00:21:21,240 --> 00:21:24,990
it's usually expressed in what they call

438
00:21:22,770 --> 00:21:28,280
dotted decimal form and you've seen

439
00:21:24,990 --> 00:21:31,650
these addresses before that it's four

440
00:21:28,280 --> 00:21:35,190
decimal numbers and they can only range

441
00:21:31,650 --> 00:21:36,930
between 0 and 255 because each one of

442
00:21:35,190 --> 00:21:38,640
them is a single byte sorts of

443
00:21:36,930 --> 00:21:40,950
information so we're used to writing

444
00:21:38,640 --> 00:21:43,260
things in hex now in this course but

445
00:21:40,950 --> 00:21:45,990
we're going to write it as each byte is

446
00:21:43,260 --> 00:21:49,920
written as a decimal digit and they're

447
00:21:45,990 --> 00:21:52,170
actually passed and stored in what's

448
00:21:49,920 --> 00:21:55,140
called network byte order which is big

449
00:21:52,170 --> 00:21:56,940
endian byte order and so we have to

450
00:21:55,140 --> 00:21:59,040
worry about the whole big endian versus

451
00:21:56,940 --> 00:22:02,580
good ole Indian thing when we're doing

452
00:21:59,040 --> 00:22:05,220
network programming and you can actually

453
00:22:02,580 --> 00:22:07,410
learn a lot there's a whole of levels of

454
00:22:05,220 --> 00:22:10,200
how the different bytes mean but for

455
00:22:07,410 --> 00:22:19,500
example any IP address it starts with

456
00:22:10,200 --> 00:22:23,130
128 - is it CMU I think and then and so

457
00:22:19,500 --> 00:22:26,700
essentially CMU owns that part of the IP

458
00:22:23,130 --> 00:22:31,260
address space which if you think about

459
00:22:26,700 --> 00:22:33,440
that approximately 2 to the 64th 2 to

460
00:22:31,260 --> 00:22:33,440
the

461
00:22:34,279 --> 00:22:40,099
no not to the 64th - to the 16th

462
00:22:37,340 --> 00:22:47,840
a different IP address is available for

463
00:22:40,099 --> 00:22:50,960
use by campus alma and as i mentioned

464
00:22:47,840 --> 00:22:55,789
there's a newer version called ipv6 that

465
00:22:50,960 --> 00:22:57,679
gives you a 128-bit addresses you can

466
00:22:55,789 --> 00:23:01,009
imagine actually that if you think about

467
00:22:57,679 --> 00:23:04,279
how many nodes are there in the internet

468
00:23:01,009 --> 00:23:09,049
if a four byte address is only two to

469
00:23:04,279 --> 00:23:11,330
the 32 so that's four billion and I

470
00:23:09,049 --> 00:23:13,779
don't know about you but I have a lot of

471
00:23:11,330 --> 00:23:17,479
different things that use IP I have a

472
00:23:13,779 --> 00:23:21,379
phone I have two laptops I have a couple

473
00:23:17,479 --> 00:23:24,710
desktops so if all if every one of us

474
00:23:21,379 --> 00:23:26,059
use multiple IP addresses then actually

475
00:23:24,710 --> 00:23:27,499
the world would be out of them right

476
00:23:26,059 --> 00:23:29,690
there's 7 billion people in the world

477
00:23:27,499 --> 00:23:31,519
not all of who may have access to the

478
00:23:29,690 --> 00:23:34,429
Internet but a large fraction of them do

479
00:23:31,519 --> 00:23:38,299
and so there's a whole kind of crazy way

480
00:23:34,429 --> 00:23:40,820
of dealing with the the multitude of

481
00:23:38,299 --> 00:23:42,830
possible IP addresses so the obvious

482
00:23:40,820 --> 00:23:45,379
thing would be well let's just allocate

483
00:23:42,830 --> 00:23:48,109
a lot more addresses and jump what's to

484
00:23:45,379 --> 00:23:50,839
skip 64 bits and go right to 128 and

485
00:23:48,109 --> 00:23:52,279
that's the idea behind ipv6 but quite

486
00:23:50,839 --> 00:23:54,259
honestly this has been one of those

487
00:23:52,279 --> 00:23:59,809
technologies that's been out there for

488
00:23:54,259 --> 00:24:03,379
over 15 years and still has a very low

489
00:23:59,809 --> 00:24:06,950
level of adoption so it's it's still a

490
00:24:03,379 --> 00:24:08,989
future technology people have basically

491
00:24:06,950 --> 00:24:11,749
figured out all these crazy schemes to

492
00:24:08,989 --> 00:24:14,259
make use of just stick within the four

493
00:24:11,749 --> 00:24:14,259
byte limit

494
00:24:14,880 --> 00:24:17,270
um

495
00:24:19,279 --> 00:24:26,519
okay so let's start talking the program

496
00:24:23,989 --> 00:24:32,369
the sort of programmer perspective on

497
00:24:26,519 --> 00:24:34,889
this and this is one area where you'll

498
00:24:32,369 --> 00:24:37,709
wish you weren't programming in C but

499
00:24:34,889 --> 00:24:40,519
you are so there's a lot of really

500
00:24:37,709 --> 00:24:42,929
crusty stuff and it was all developed

501
00:24:40,519 --> 00:24:46,139
most of the software protocols were

502
00:24:42,929 --> 00:24:46,799
conceived before he even was what it is

503
00:24:46,139 --> 00:24:49,289
today

504
00:24:46,799 --> 00:24:51,329
so like the Kernighan and Ritchie book

505
00:24:49,289 --> 00:24:53,849
you have is called the second edition

506
00:24:51,329 --> 00:24:57,779
and it's based on what was called ANSI C

507
00:24:53,849 --> 00:24:59,879
or ISO C but these all date before that

508
00:24:57,779 --> 00:25:02,039
they date back to the original Kernighan

509
00:24:59,879 --> 00:25:05,549
and Ritchie so for example void star did

510
00:25:02,039 --> 00:25:09,179
not exist in that era and so you use

511
00:25:05,549 --> 00:25:10,559
care stars a generic pointer and so

512
00:25:09,179 --> 00:25:13,169
there's just a lot of stuff in this

513
00:25:10,559 --> 00:25:15,959
programming interface where you go wow

514
00:25:13,169 --> 00:25:16,829
that is really crusty and the truth is

515
00:25:15,959 --> 00:25:19,079
yes you're right

516
00:25:16,829 --> 00:25:20,639
so in particularly there's a lot of

517
00:25:19,079 --> 00:25:22,229
different structures that are defined

518
00:25:20,639 --> 00:25:24,869
and one of them is called an in adder

519
00:25:22,229 --> 00:25:27,269
which means internet address and it's

520
00:25:24,869 --> 00:25:32,489
just defined to be a 32-bit unsigned

521
00:25:27,269 --> 00:25:34,589
number and in general as I mentioned

522
00:25:32,489 --> 00:25:36,779
there the so called network byte order

523
00:25:34,589 --> 00:25:39,869
whoever designed the original protocols

524
00:25:36,779 --> 00:25:42,959
was a fan of big endian addressing and

525
00:25:39,869 --> 00:25:44,579
so that's what it is even though

526
00:25:42,959 --> 00:25:45,839
actually most of the machines that are

527
00:25:44,579 --> 00:25:49,769
out there in this world are little

528
00:25:45,839 --> 00:25:51,570
endian and so there's a set of standard

529
00:25:49,769 --> 00:25:53,729
library functions that you use to

530
00:25:51,570 --> 00:25:56,909
convert between network order and host

531
00:25:53,729 --> 00:26:00,570
order and the idea of it is now if I run

532
00:25:56,909 --> 00:26:03,509
my software on a little Indian or a big

533
00:26:00,570 --> 00:26:05,609
endian machine these functions will do

534
00:26:03,509 --> 00:26:08,339
the right thing so if I just use these

535
00:26:05,609 --> 00:26:10,739
standard libraries then I don't have to

536
00:26:08,339 --> 00:26:12,589
worry about porting it every time I

537
00:26:10,739 --> 00:26:15,959
change the word or during the machine

538
00:26:12,589 --> 00:26:20,190
one of the things you'll notice here is

539
00:26:15,959 --> 00:26:24,269
there is no function to convert 64-bit

540
00:26:20,190 --> 00:26:27,539
data between a network order and host

541
00:26:24,269 --> 00:26:30,359
order so I don't know what people do

542
00:26:27,539 --> 00:26:30,909
when I do it I just write my own set my

543
00:26:30,359 --> 00:26:34,299
own function

544
00:26:30,909 --> 00:26:37,409
to do it or I don't because I know my

545
00:26:34,299 --> 00:26:40,559
other end is a little endian machine

546
00:26:37,409 --> 00:26:44,649
so anyways these are already some

547
00:26:40,559 --> 00:26:47,590
functions you'll start seeing for that

548
00:26:44,649 --> 00:26:49,200
look like network conversion software

549
00:26:47,590 --> 00:26:52,809
[Music]

550
00:26:49,200 --> 00:26:54,940
and as I mentioned the addresses are

551
00:26:52,809 --> 00:26:59,769
written in a dotted decimal form and

552
00:26:54,940 --> 00:27:03,759
it's also big endian so if I were to

553
00:26:59,769 --> 00:27:06,190
write in hex 128 is of course 8 0 so

554
00:27:03,759 --> 00:27:12,519
that's the most significant byte of the

555
00:27:06,190 --> 00:27:15,489
IP address and then there is a set of

556
00:27:12,519 --> 00:27:17,440
functions API calls you can use to

557
00:27:15,489 --> 00:27:22,450
convert between this dotted decimal

558
00:27:17,440 --> 00:27:26,590
format and the actual just a 32-bit

559
00:27:22,450 --> 00:27:29,289
unsigned int and actually it used to be

560
00:27:26,590 --> 00:27:30,789
there is you might see some older

561
00:27:29,289 --> 00:27:33,279
presentations where they use different

562
00:27:30,789 --> 00:27:38,049
names for this but the most recent

563
00:27:33,279 --> 00:27:40,179
version API calls this the the

564
00:27:38,049 --> 00:27:44,129
presentation version the dotted decimal

565
00:27:40,179 --> 00:27:44,129
they referred to it as a presentation

566
00:27:44,429 --> 00:27:50,619
then you can look up the and it's in the

567
00:27:47,440 --> 00:27:55,629
book to what the calls to these look

568
00:27:50,619 --> 00:27:59,169
like but you probably don't or very

569
00:27:55,629 --> 00:28:00,820
seldom when you're thinking about I want

570
00:27:59,169 --> 00:28:04,419
to go to Google you don't think about

571
00:28:00,820 --> 00:28:08,499
what its IP address is you just go to wo

572
00:28:04,419 --> 00:28:11,590
comm and for everything you do you refer

573
00:28:08,499 --> 00:28:13,960
to it by this it would have referred

574
00:28:11,590 --> 00:28:16,840
called Internet domain names which is a

575
00:28:13,960 --> 00:28:20,590
hierarchical naming system where as you

576
00:28:16,840 --> 00:28:24,429
know there's dot edu is for educational

577
00:28:20,590 --> 00:28:28,059
institutions com is for commercial net

578
00:28:24,429 --> 00:28:33,190
is general networking of many countries

579
00:28:28,059 --> 00:28:36,009
have their own suffix so you know dot de

580
00:28:33,190 --> 00:28:38,109
is for Germany and so forth and so those

581
00:28:36,009 --> 00:28:40,299
are called the first level domain names

582
00:28:38,109 --> 00:28:44,789
and then there's a hierarchal naming

583
00:28:40,299 --> 00:28:44,789
structure under that and uh

584
00:28:45,020 --> 00:28:52,430
there's actually an interesting question

585
00:28:48,390 --> 00:28:54,630
of okay how do I then map from those

586
00:28:52,430 --> 00:28:57,720
hierarchical names those domain names

587
00:28:54,630 --> 00:29:01,790
into this dotted decimal or the 32 bit

588
00:28:57,720 --> 00:29:05,760
IP address and the job of that is by a

589
00:29:01,790 --> 00:29:08,970
very large distributed system called the

590
00:29:05,760 --> 00:29:12,840
DNS the domain name system where the

591
00:29:08,970 --> 00:29:15,660
only sort of centrally managed part of

592
00:29:12,840 --> 00:29:18,470
it is at the top level so for each of

593
00:29:15,660 --> 00:29:22,110
these first level domain names there's

594
00:29:18,470 --> 00:29:24,180
there's a collection a very large

595
00:29:22,110 --> 00:29:29,850
collection of machines that keep track

596
00:29:24,180 --> 00:29:32,310
of all the all the IP addresses that map

597
00:29:29,850 --> 00:29:35,010
to one of those first level domain names

598
00:29:32,310 --> 00:29:37,590
and then for example CMU maintains its

599
00:29:35,010 --> 00:29:38,970
own naming Authority so anything that

600
00:29:37,590 --> 00:29:44,040
says something

601
00:29:38,970 --> 00:29:47,760
CMU edu there's local DNS servers within

602
00:29:44,040 --> 00:29:54,150
CMU that are picking apart okay where

603
00:29:47,760 --> 00:29:58,970
should you know if I say CS CMU edu what

604
00:29:54,150 --> 00:30:01,530
would be the the IP address for that

605
00:29:58,970 --> 00:30:03,330
well and it's actually pretty

606
00:30:01,530 --> 00:30:05,430
interesting how this is managed because

607
00:30:03,330 --> 00:30:10,230
it's all it's totally decentralized

608
00:30:05,430 --> 00:30:16,320
there's a whole set of protocols that

609
00:30:10,230 --> 00:30:18,060
govern how naming is done so but

610
00:30:16,320 --> 00:30:19,890
conceptually we can think of it as just

611
00:30:18,060 --> 00:30:23,280
this big database that gives me a

612
00:30:19,890 --> 00:30:25,910
mapping where I can give a domain name

613
00:30:23,280 --> 00:30:29,490
and it will get back to me a one or more

614
00:30:25,910 --> 00:30:30,990
IP addresses I can give an IP address

615
00:30:29,490 --> 00:30:33,710
and it will come back with one or more

616
00:30:30,990 --> 00:30:33,710
domain names

617
00:30:37,080 --> 00:30:42,640
and so there's actually an application

618
00:30:39,370 --> 00:30:44,620
you can run on most machines called

619
00:30:42,640 --> 00:30:48,490
nslookup and there's another one called

620
00:30:44,620 --> 00:30:51,670
dig that you can use to find basically

621
00:30:48,490 --> 00:30:54,250
probe the DNS and find in either

622
00:30:51,670 --> 00:30:56,130
direction you can look at the given a

623
00:30:54,250 --> 00:30:58,750
domain name you can find its IP address

624
00:30:56,130 --> 00:31:03,160
given an IP address you can find its

625
00:30:58,750 --> 00:31:07,270
domain name and we also I'll show you

626
00:31:03,160 --> 00:31:10,900
some code that just as an example of how

627
00:31:07,270 --> 00:31:15,580
you do the programming I'll just show

628
00:31:10,900 --> 00:31:18,690
that momentarily called hostname so just

629
00:31:15,580 --> 00:31:18,690
some examples

630
00:31:29,210 --> 00:31:35,929
you know if I look up some address like

631
00:31:32,869 --> 00:31:39,580
the the website for the computer science

632
00:31:35,929 --> 00:31:43,089
school computer science using nslookup

633
00:31:39,580 --> 00:31:46,909
it comes back can people see this okay

634
00:31:43,089 --> 00:31:49,159
you want it bigger okay so this is what

635
00:31:46,909 --> 00:31:53,389
NSF looks like and this stuff here just

636
00:31:49,159 --> 00:31:57,229
tells you you know who where was the

637
00:31:53,389 --> 00:31:58,609
actual directory entry in the which DNS

638
00:31:57,229 --> 00:32:05,419
server actually gave this information

639
00:31:58,609 --> 00:32:09,799
back and it says that WCAG mu is

640
00:32:05,419 --> 00:32:14,899
actually a synonym for a weirder one

641
00:32:09,799 --> 00:32:18,619
called W web - lb servcie SC mu dot edu

642
00:32:14,899 --> 00:32:19,219
and its IP address is 128 - like you'd

643
00:32:18,619 --> 00:32:24,019
expect

644
00:32:19,219 --> 00:32:31,279
- 1713 and of course that works not just

645
00:32:24,019 --> 00:32:36,739
at CMU but I can you know go ask about

646
00:32:31,279 --> 00:32:40,399
what Stanford is up to and it will come

647
00:32:36,739 --> 00:32:48,469
back and it's IP addresses of something

648
00:32:40,399 --> 00:32:52,039
170 1.64 and that's been managed by that

649
00:32:48,469 --> 00:32:54,649
and you'll see again it I asked for WCS

650
00:32:52,039 --> 00:32:57,409
at Stanford you said well the real name

651
00:32:54,649 --> 00:33:02,089
of that is CS dot stanford.edu and this

652
00:32:57,409 --> 00:33:06,289
actually is a point that the the mapping

653
00:33:02,089 --> 00:33:08,509
between domain names and Internet

654
00:33:06,289 --> 00:33:10,729
addresses is not one-to-one you can have

655
00:33:08,509 --> 00:33:14,419
multiple domain names that refer to the

656
00:33:10,729 --> 00:33:20,349
same Internet address but you can also

657
00:33:14,419 --> 00:33:20,349
have multiple internet addresses

658
00:33:21,799 --> 00:33:24,909
excuse me

659
00:33:29,580 --> 00:33:32,539
that's weird

660
00:33:36,080 --> 00:33:41,600
oh so like twitter.com when I ask for it

661
00:33:39,529 --> 00:33:48,380
it comes back with four different

662
00:33:41,600 --> 00:33:54,019
addresses and if I do the exact same

663
00:33:48,380 --> 00:33:59,149
thing again mmm Kimba yeah you see it

664
00:33:54,019 --> 00:34:03,440
came back with the same no not even the

665
00:33:59,149 --> 00:34:07,309
same addresses it came back for example

666
00:34:03,440 --> 00:34:09,409
here the one that ends with dot six that

667
00:34:07,309 --> 00:34:11,599
wasn't in that first twist so it came

668
00:34:09,409 --> 00:34:13,190
back with a slightly different set of

669
00:34:11,599 --> 00:34:15,950
addresses and a somewhat different

670
00:34:13,190 --> 00:34:18,080
orders and the idea of that is that it

671
00:34:15,950 --> 00:34:20,629
actually has multiple servers so when I

672
00:34:18,080 --> 00:34:23,210
send to twitter.com or Google or any of

673
00:34:20,629 --> 00:34:24,980
these major servers there's not just one

674
00:34:23,210 --> 00:34:26,859
place in the internet that's handling

675
00:34:24,980 --> 00:34:29,000
everybody's Google traffic these

676
00:34:26,859 --> 00:34:32,889
thousands of places spread around the

677
00:34:29,000 --> 00:34:36,220
world and the way they get you there is

678
00:34:32,889 --> 00:34:39,050
by playing tricks with the DNS that

679
00:34:36,220 --> 00:34:42,320
Google is constantly sending updates to

680
00:34:39,050 --> 00:34:44,030
the it maintains its own DNS servers so

681
00:34:42,320 --> 00:34:44,960
it's constantly changing them and it

682
00:34:44,030 --> 00:34:46,550
will actually give you different

683
00:34:44,960 --> 00:34:49,129
addresses depending on where in the

684
00:34:46,550 --> 00:34:51,169
world you located as well to try and

685
00:34:49,129 --> 00:34:53,149
provide a server that's sort of

686
00:34:51,169 --> 00:34:56,990
reasonably close to you geographically

687
00:34:53,149 --> 00:34:59,630
so there's all just all kinds of tricks

688
00:34:56,990 --> 00:35:02,960
that happen through DNS that is part of

689
00:34:59,630 --> 00:35:08,599
the way they can sort of manage this

690
00:35:02,960 --> 00:35:11,300
huge set of addresses and then there's

691
00:35:08,599 --> 00:35:14,330
some other domain names that don't have

692
00:35:11,300 --> 00:35:16,369
any IP address that they're somewhere in

693
00:35:14,330 --> 00:35:18,349
the hierarchy that hierarchical naming

694
00:35:16,369 --> 00:35:21,760
system but they're not actually

695
00:35:18,349 --> 00:35:31,130
referring to a particular host so it's a

696
00:35:21,760 --> 00:35:33,940
Multi multi mapping then the the API so

697
00:35:31,130 --> 00:35:33,940
reflects that

698
00:35:39,099 --> 00:35:45,109
so this is just going what I told you

699
00:35:42,319 --> 00:35:47,440
they sometimes one-to-one sometimes many

700
00:35:45,109 --> 00:35:51,200
domain names refer to the same address

701
00:35:47,440 --> 00:35:54,079
sometimes of one name maps to multiple

702
00:35:51,200 --> 00:35:57,349
addresses that change over time and then

703
00:35:54,079 --> 00:35:59,180
there's some where it's a valid name but

704
00:35:57,349 --> 00:36:02,140
it doesn't have an IP address it doesn't

705
00:35:59,180 --> 00:36:05,359
have a host associated with a question

706
00:36:02,140 --> 00:36:07,700
the other is like given to a server for

707
00:36:05,359 --> 00:36:10,790
example let's say I create them how does

708
00:36:07,700 --> 00:36:12,670
that hold a number generator oh how do I

709
00:36:10,790 --> 00:36:15,500
get how do you get your own IP address

710
00:36:12,670 --> 00:36:18,410
well all you have to beg borrow or you

711
00:36:15,500 --> 00:36:21,410
have to either borrow or buy them so for

712
00:36:18,410 --> 00:36:23,420
example at CMU there is some number of

713
00:36:21,410 --> 00:36:26,059
what they call statically allocated IP

714
00:36:23,420 --> 00:36:27,530
addresses where it's just fixed assigned

715
00:36:26,059 --> 00:36:30,440
to that machine and you can register

716
00:36:27,530 --> 00:36:35,390
form and request them through computing

717
00:36:30,440 --> 00:36:37,460
services but most you don't have that

718
00:36:35,390 --> 00:36:39,520
most you get one that's I signed

719
00:36:37,460 --> 00:36:42,680
dynamically so there's a pool of

720
00:36:39,520 --> 00:36:44,510
addresses that you basically they call

721
00:36:42,680 --> 00:36:47,450
them leasing that you are assigned with

722
00:36:44,510 --> 00:36:51,760
for a while and then but it could

723
00:36:47,450 --> 00:36:51,760
possibly be reassigned to someone else

724
00:36:52,470 --> 00:36:57,060
and that's part of the way it can manage

725
00:36:54,420 --> 00:37:09,110
the somewhat limited set of IP addresses

726
00:36:57,060 --> 00:37:09,110
so the idea of like I said that the main

727
00:37:13,590 --> 00:37:20,580
a way we'll think about it is in terms

728
00:37:17,640 --> 00:37:22,410
of what's called TCP and it's this

729
00:37:20,580 --> 00:37:25,200
connection-oriented protocol where I

730
00:37:22,410 --> 00:37:27,120
establish a connection from one one host

731
00:37:25,200 --> 00:37:30,090
establishes a connection to another host

732
00:37:27,120 --> 00:37:33,300
and they they can communicate to each

733
00:37:30,090 --> 00:37:35,880
other sending arbitrarily long streams

734
00:37:33,300 --> 00:37:38,370
of bytes to each other and so the

735
00:37:35,880 --> 00:37:40,650
connection is then two hosts that can

736
00:37:38,370 --> 00:37:45,740
talk to each other and each of those

737
00:37:40,650 --> 00:37:49,350
endpoints is referred to as a socket and

738
00:37:45,740 --> 00:37:52,590
so I can and a socket is both an IP

739
00:37:49,350 --> 00:37:56,700
address and what's called a port number

740
00:37:52,590 --> 00:37:59,430
so there's a 16 by 16 bit number for

741
00:37:56,700 --> 00:38:02,100
every connection that's referred to as

742
00:37:59,430 --> 00:38:04,230
its port and the reason for that is just

743
00:38:02,100 --> 00:38:06,900
because I'm talking to a particular

744
00:38:04,230 --> 00:38:10,050
machine that that machine can support

745
00:38:06,900 --> 00:38:13,320
different services it can provide SSH

746
00:38:10,050 --> 00:38:16,050
connections it can provide FTP

747
00:38:13,320 --> 00:38:19,350
connections it can host a mail server it

748
00:38:16,050 --> 00:38:21,480
can host a web server so a particular

749
00:38:19,350 --> 00:38:23,520
machine might have a multitude of

750
00:38:21,480 --> 00:38:25,860
different services and so those are

751
00:38:23,520 --> 00:38:27,780
differentiated from each other with what

752
00:38:25,860 --> 00:38:30,060
are called port numbers and similarly

753
00:38:27,780 --> 00:38:32,610
Isaac client might have connections to

754
00:38:30,060 --> 00:38:36,360
dozens of hosts going at any given time

755
00:38:32,610 --> 00:38:39,300
I'm cruising the web I'm you know doing

756
00:38:36,360 --> 00:38:41,010
all that different stuff and that's all

757
00:38:39,300 --> 00:38:44,030
differentiated the client end that

758
00:38:41,010 --> 00:38:46,470
there's different ports associated with

759
00:38:44,030 --> 00:38:51,180
your different programs that are running

760
00:38:46,470 --> 00:38:54,830
and so a port then is a 16-bit integer

761
00:38:51,180 --> 00:38:57,840
that identifies which particular

762
00:38:54,830 --> 00:38:59,760
endpoint is is being communicated with

763
00:38:57,840 --> 00:39:02,310
it either the client side of the server

764
00:38:59,760 --> 00:39:04,650
side and typically at the client side

765
00:39:02,310 --> 00:39:06,240
these are assigned dynamically and the

766
00:39:04,650 --> 00:39:09,150
referred to as the ephemeral ports

767
00:39:06,240 --> 00:39:10,770
meaning they only are assigned for the

768
00:39:09,150 --> 00:39:13,380
limited duration that you have a

769
00:39:10,770 --> 00:39:14,550
connection with that that you're

770
00:39:13,380 --> 00:39:17,850
maintaining that connection

771
00:39:14,550 --> 00:39:21,750
and then there has to be some way if I'm

772
00:39:17,850 --> 00:39:24,600
going to contact and I want to know the

773
00:39:21,750 --> 00:39:27,540
DNS will tell me what the IP address is

774
00:39:24,600 --> 00:39:28,530
of say google.com but I have to know

775
00:39:27,540 --> 00:39:31,770
that

776
00:39:28,530 --> 00:39:36,570
am i communicating with its web service

777
00:39:31,770 --> 00:39:38,940
which is port 80 or HTTP secure socket

778
00:39:36,570 --> 00:39:41,520
is a different report number so which

779
00:39:38,940 --> 00:39:43,740
service I'm asking for and there's a

780
00:39:41,520 --> 00:39:48,900
standard list what are called well-known

781
00:39:43,740 --> 00:39:51,660
ports that are that I can contact at the

782
00:39:48,900 --> 00:39:54,780
server end to get the particular service

783
00:39:51,660 --> 00:39:59,240
I'm looking for and those are assigned

784
00:39:54,780 --> 00:40:04,560
there's a big list of port assignments

785
00:39:59,240 --> 00:40:08,340
and so the again that's part of the sort

786
00:40:04,560 --> 00:40:10,800
of a whole set of internet standards is

787
00:40:08,340 --> 00:40:13,890
the the identifiers for the different

788
00:40:10,800 --> 00:40:17,540
ports what services those are and how

789
00:40:13,890 --> 00:40:17,540
those particular protocols work

790
00:40:19,390 --> 00:40:24,300
so when I have a connection then

791
00:40:28,230 --> 00:40:33,600
as I mentioned think of it as a

792
00:40:30,090 --> 00:40:37,470
connection then is a link between two

793
00:40:33,600 --> 00:40:40,230
machines based on some known port

794
00:40:37,470 --> 00:40:42,690
typically at the server end and a

795
00:40:40,230 --> 00:40:45,840
dynamically assigned or ephemeral port

796
00:40:42,690 --> 00:40:47,550
assigned at the client in and I can

797
00:40:45,840 --> 00:40:49,440
refer to them that connection then is

798
00:40:47,550 --> 00:40:51,930
identified by the combination of the

799
00:40:49,440 --> 00:40:54,320
hosts at the two ends and the ports that

800
00:40:51,930 --> 00:40:54,320
they're using

801
00:40:57,800 --> 00:41:05,450
and in general then it's the job of the

802
00:41:02,150 --> 00:41:07,330
colonel to differentiate the different

803
00:41:05,450 --> 00:41:11,120
connections that are coming into a

804
00:41:07,330 --> 00:41:15,860
machine and figure out which software

805
00:41:11,120 --> 00:41:19,130
which process to wake up when a data you

806
00:41:15,860 --> 00:41:23,900
know when some data arrives from another

807
00:41:19,130 --> 00:41:25,730
machine in which actual program running

808
00:41:23,900 --> 00:41:30,350
on that machine will make use of that

809
00:41:25,730 --> 00:41:33,760
data and that's done by associating for

810
00:41:30,350 --> 00:41:36,710
each of the ports a particular process

811
00:41:33,760 --> 00:41:41,870
executing program that's going to handle

812
00:41:36,710 --> 00:41:45,440
those particular requests and it's

813
00:41:41,870 --> 00:41:49,670
totally possible for a client to be

814
00:41:45,440 --> 00:41:51,860
interacting with a single server over

815
00:41:49,670 --> 00:41:56,270
different ports but those are considered

816
00:41:51,860 --> 00:41:58,730
to be different connections and and so

817
00:41:56,270 --> 00:42:01,030
they don't really interfere with each

818
00:41:58,730 --> 00:42:01,030
other

819
00:42:04,010 --> 00:42:09,060
so that's what I mentioned is this is

820
00:42:07,020 --> 00:42:12,330
what we refer to as sockets programming

821
00:42:09,060 --> 00:42:14,490
or the sockets interface and it was

822
00:42:12,330 --> 00:42:19,280
developed sort of as the internet was

823
00:42:14,490 --> 00:42:19,280
evolving in the late 70s and early 80's

824
00:42:19,430 --> 00:42:25,410
so socket then as I said is certain

825
00:42:22,890 --> 00:42:28,290
logically one end one of the two ends of

826
00:42:25,410 --> 00:42:30,960
a connection and from an application

827
00:42:28,290 --> 00:42:34,350
point of view you'll see it as a file

828
00:42:30,960 --> 00:42:35,850
descriptor to the low-level file stuff

829
00:42:34,350 --> 00:42:41,280
that you've already seen that you can do

830
00:42:35,850 --> 00:42:44,730
reading and writing from um and and so

831
00:42:41,280 --> 00:42:50,640
that it's a sort of mental model that is

832
00:42:44,730 --> 00:42:52,380
provided by the socket interface but

833
00:42:50,640 --> 00:42:55,440
it's a very different you know the

834
00:42:52,380 --> 00:42:58,530
actual implementation of network when

835
00:42:55,440 --> 00:43:00,390
you write to a socket it's firing up all

836
00:42:58,530 --> 00:43:03,060
kinds of network stuff whereas you write

837
00:43:00,390 --> 00:43:05,190
to a disk it's operating or disk

838
00:43:03,060 --> 00:43:06,810
controller so at the hardware level and

839
00:43:05,190 --> 00:43:09,030
even at the lower levels of software

840
00:43:06,810 --> 00:43:10,650
they're very different beasts but you as

841
00:43:09,030 --> 00:43:11,990
an application programmers see some

842
00:43:10,650 --> 00:43:15,330
commonality there

843
00:43:11,990 --> 00:43:18,420
okay so let's jump right into the API

844
00:43:15,330 --> 00:43:20,100
and again this is a place where you

845
00:43:18,420 --> 00:43:24,540
you'll wish you were programming in a

846
00:43:20,100 --> 00:43:28,310
language that had a type hierarchy but

847
00:43:24,540 --> 00:43:31,410
you aren't you're programming in C so

848
00:43:28,310 --> 00:43:33,390
there's a type there's a zillion

849
00:43:31,410 --> 00:43:35,100
Struck's that you kind of have to get

850
00:43:33,390 --> 00:43:38,490
familiar with but one is called a sock

851
00:43:35,100 --> 00:43:41,700
adder and basically it's just a sixteen

852
00:43:38,490 --> 00:43:43,770
bytes worth of stuff where the the only

853
00:43:41,700 --> 00:43:47,070
thing that's special here is that the

854
00:43:43,770 --> 00:43:49,800
leading two bytes designate what type of

855
00:43:47,070 --> 00:43:53,730
socket this is particularly be different

856
00:43:49,800 --> 00:43:57,750
whether it's a TCP socket an ipv6 socket

857
00:43:53,730 --> 00:44:00,750
a UDP socket and all those will have

858
00:43:57,750 --> 00:44:03,060
different numbers a different constant

859
00:44:00,750 --> 00:44:05,450
in there that tells you which type of

860
00:44:03,060 --> 00:44:08,940
socket it is and then at the high level

861
00:44:05,450 --> 00:44:11,040
the sockets in a lot of the programs

862
00:44:08,940 --> 00:44:13,320
don't need to know you know which type

863
00:44:11,040 --> 00:44:15,810
of connection this is they can just deal

864
00:44:13,320 --> 00:44:16,890
with they basically call other software

865
00:44:15,810 --> 00:44:18,930
to deal with that

866
00:44:16,890 --> 00:44:23,400
so that's why it's referred to as being

867
00:44:18,930 --> 00:44:26,249
family specific and then the socket

868
00:44:23,400 --> 00:44:28,589
stuff isn't even necessarily referred to

869
00:44:26,249 --> 00:44:32,190
the internet the capital I under net and

870
00:44:28,589 --> 00:44:36,499
so there's a more specific one called a

871
00:44:32,190 --> 00:44:43,859
socket or underscore in that is used for

872
00:44:36,499 --> 00:44:46,499
ipv4 sockets oh not ipv6 and so in

873
00:44:43,859 --> 00:44:48,210
particular it fills in fields one is

874
00:44:46,499 --> 00:44:52,470
called the port which is I mentioned

875
00:44:48,210 --> 00:44:56,119
it's 16 bits and then the IP address the

876
00:44:52,470 --> 00:44:58,970
4 byte IP address both of which are in

877
00:44:56,119 --> 00:45:02,549
even if you're running the software on a

878
00:44:58,970 --> 00:45:06,180
x86 machine these should be in big

879
00:45:02,549 --> 00:45:08,069
endian order I'll and you'll see that

880
00:45:06,180 --> 00:45:11,160
this is what I mean that this is sort of

881
00:45:08,069 --> 00:45:14,579
a C's version of subtyping if you know

882
00:45:11,160 --> 00:45:17,279
something like C++ or Java for you know

883
00:45:14,579 --> 00:45:21,359
a language with type inheritance that

884
00:45:17,279 --> 00:45:25,859
you can think of it as a sock adder in a

885
00:45:21,359 --> 00:45:28,019
sort of a subclass of a sock adder it

886
00:45:25,859 --> 00:45:30,680
has more information it's compatible

887
00:45:28,019 --> 00:45:34,849
with but has more information than a

888
00:45:30,680 --> 00:45:38,789
socket and then there's another type of

889
00:45:34,849 --> 00:45:41,130
for ipv6 has a different kind of struct

890
00:45:38,789 --> 00:45:44,400
that they fill in for its information

891
00:45:41,130 --> 00:45:47,670
and then they they Pat it out with 8

892
00:45:44,400 --> 00:45:49,380
bytes of zeros just because this

893
00:45:47,670 --> 00:45:52,279
particular protocol doesn't require the

894
00:45:49,380 --> 00:45:52,279
full 16 bytes

895
00:45:53,290 --> 00:45:58,920
okay so this is sort of what it looks

896
00:45:55,840 --> 00:46:02,290
like to operate a full-blown

897
00:45:58,920 --> 00:46:05,860
client-server system from a programmers

898
00:46:02,290 --> 00:46:08,890
perspective and we're going to for the

899
00:46:05,860 --> 00:46:11,050
rest of today and all of Thursday go

900
00:46:08,890 --> 00:46:14,290
through all these steps and you as a

901
00:46:11,050 --> 00:46:16,240
programmer are actually going to have to

902
00:46:14,290 --> 00:46:19,240
understand each of these steps what they

903
00:46:16,240 --> 00:46:21,880
do what they mean and how to use them

904
00:46:19,240 --> 00:46:23,530
the good news is there's some pretty

905
00:46:21,880 --> 00:46:26,020
standard patterns here and so you can

906
00:46:23,530 --> 00:46:30,580
often grab some existing code say out of

907
00:46:26,020 --> 00:46:34,420
the book to use that will make this not

908
00:46:30,580 --> 00:46:36,730
as painful as it might look so but the

909
00:46:34,420 --> 00:46:40,240
overall idea of this this picture then

910
00:46:36,730 --> 00:46:45,610
is so I can't give you specifically

911
00:46:40,240 --> 00:46:47,890
remote doesn't work on the the

912
00:46:45,610 --> 00:46:50,350
right-hand side refers to the steps that

913
00:46:47,890 --> 00:46:52,270
the server has to go through and the

914
00:46:50,350 --> 00:46:55,600
left-hand side is what the client does

915
00:46:52,270 --> 00:47:00,130
so the upper right is what it takes to

916
00:46:55,600 --> 00:47:02,980
set up a server that is then a program

917
00:47:00,130 --> 00:47:06,130
that's running there ready to receive

918
00:47:02,980 --> 00:47:12,190
connections from a client and perform

919
00:47:06,130 --> 00:47:14,800
various services and so obviously before

920
00:47:12,190 --> 00:47:16,780
the client can do anything the server

921
00:47:14,800 --> 00:47:20,200
has to exist so that has to be the first

922
00:47:16,780 --> 00:47:23,370
step in setting things up and then we

923
00:47:20,200 --> 00:47:26,980
have to well fire for a client that will

924
00:47:23,370 --> 00:47:28,450
make use of this service and then

925
00:47:26,980 --> 00:47:30,310
there'll be what's referred to as this

926
00:47:28,450 --> 00:47:32,980
session meaning a kind of back and forth

927
00:47:30,310 --> 00:47:34,630
communication between the client and

928
00:47:32,980 --> 00:47:36,640
server doing whatever they're going to

929
00:47:34,630 --> 00:47:39,640
do this is not specific to any

930
00:47:36,640 --> 00:47:41,590
particular application and like I said

931
00:47:39,640 --> 00:47:43,300
it will involve you'll see Rio

932
00:47:41,590 --> 00:47:46,300
underscore remember those who are

933
00:47:43,300 --> 00:47:50,640
reliable i/o functions we talked about

934
00:47:46,300 --> 00:47:57,250
as part of the UNIX i/o so it's a way to

935
00:47:50,640 --> 00:47:59,710
read and write in a room and and handle

936
00:47:57,250 --> 00:48:01,210
some of the quirks of low-level i/o but

937
00:47:59,710 --> 00:48:03,580
basically this is sending and receiving

938
00:48:01,210 --> 00:48:08,050
messages over the Internet

939
00:48:03,580 --> 00:48:09,910
and then once that done typically then

940
00:48:08,050 --> 00:48:11,560
the client will close its connection

941
00:48:09,910 --> 00:48:15,550
sort of equivalent of hanging up its

942
00:48:11,560 --> 00:48:18,820
phone and say okay I'm done and then

943
00:48:15,550 --> 00:48:20,890
sometime later or maybe never depending

944
00:48:18,820 --> 00:48:24,070
on what kind of web you know service

945
00:48:20,890 --> 00:48:27,910
this is if the the server wants to shut

946
00:48:24,070 --> 00:48:31,650
down it has its own collection of calls

947
00:48:27,910 --> 00:48:34,300
that it makes to stop that service so

948
00:48:31,650 --> 00:48:38,400
anyways just to kind of give you the

949
00:48:34,300 --> 00:48:38,400
landscape of what this picture means

950
00:48:40,120 --> 00:48:49,800
so we're going to jump into the middle

951
00:48:45,340 --> 00:48:49,800
this the top level up and we'll focus

952
00:48:50,940 --> 00:48:57,150
actually which will we focus on well

953
00:48:54,430 --> 00:48:59,500
we'll talk to some level in parallel

954
00:48:57,150 --> 00:49:01,240
because there's a lot of commonality as

955
00:48:59,500 --> 00:49:02,680
you can see between what goes on with

956
00:49:01,240 --> 00:49:09,520
the server and what goes on with the

957
00:49:02,680 --> 00:49:11,680
client and so actually the top level

958
00:49:09,520 --> 00:49:19,300
called it's one called get adder info is

959
00:49:11,680 --> 00:49:23,410
the way that it sort of initiates things

960
00:49:19,300 --> 00:49:26,440
it actually does the the lookup to map

961
00:49:23,410 --> 00:49:28,900
from a domain name to a IP address so

962
00:49:26,440 --> 00:49:31,060
we'll cover that later so the first step

963
00:49:28,900 --> 00:49:34,300
in on either side then and creating a

964
00:49:31,060 --> 00:49:39,640
connection is a call to a function

965
00:49:34,300 --> 00:49:44,430
called socket and the reason I wanted to

966
00:49:39,640 --> 00:49:44,430
Blackboard was to help you keep track of

967
00:50:04,740 --> 00:50:11,950
so the first call is that doesn't do

968
00:50:08,530 --> 00:50:18,460
much oh and that's why the function call

969
00:50:11,950 --> 00:50:20,500
is socket but the it only happens within

970
00:50:18,460 --> 00:50:23,020
the application it doesn't make a use of

971
00:50:20,500 --> 00:50:25,120
any part of the operating system doesn't

972
00:50:23,020 --> 00:50:27,580
send anything over the network and the

973
00:50:25,120 --> 00:50:32,920
idea is to basically say hey I want to

974
00:50:27,580 --> 00:50:35,920
create a takut and it's given three

975
00:50:32,920 --> 00:50:38,230
arguments the first two which is AF

976
00:50:35,920 --> 00:50:42,340
underscore I net all these uppercase R

977
00:50:38,230 --> 00:50:45,580
names are constants that are built-in or

978
00:50:42,340 --> 00:50:47,890
included in the various H files that you

979
00:50:45,580 --> 00:50:50,820
include in writing this code and AF

980
00:50:47,890 --> 00:50:55,120
underscore I nut just means that say

981
00:50:50,820 --> 00:50:57,550
ipv4 so 32-bit addresses and then the

982
00:50:55,120 --> 00:51:00,310
second parameter is says you want a sock

983
00:50:57,550 --> 00:51:02,170
stream and that refers to a TCP

984
00:51:00,310 --> 00:51:04,030
connection it's referred to as a stream

985
00:51:02,170 --> 00:51:06,490
connection because like I said you get

986
00:51:04,030 --> 00:51:09,400
to send as many bytes as you like a

987
00:51:06,490 --> 00:51:13,140
stream of bytes to in either direction

988
00:51:09,400 --> 00:51:13,140
and then

989
00:51:15,480 --> 00:51:21,190
zero protocol well I guess it must not

990
00:51:19,630 --> 00:51:24,880
be very interesting because I said it to

991
00:51:21,190 --> 00:51:27,670
zero so we don't need to do anything in

992
00:51:24,880 --> 00:51:29,950
this particular case there are man pages

993
00:51:27,670 --> 00:51:31,600
on this by the way which if you just

994
00:51:29,950 --> 00:51:33,640
tried to learn all sockets programming

995
00:51:31,600 --> 00:51:35,410
by reading men pages you'd go crazy but

996
00:51:33,640 --> 00:51:40,360
once you kind of have the idea of it

997
00:51:35,410 --> 00:51:44,230
the men pages are pretty useful and then

998
00:51:40,360 --> 00:51:47,320
the next part you'll see we're looking

999
00:51:44,230 --> 00:51:50,670
only now on the server side it's called

1000
00:51:47,320 --> 00:51:50,670
bind and

1001
00:51:58,640 --> 00:52:04,760
what bind does then is that specific

1002
00:52:01,250 --> 00:52:07,990
then to a server and now this is a make

1003
00:52:04,760 --> 00:52:11,170
this interfaces to the kernel it says I

1004
00:52:07,990 --> 00:52:11,170
want to

1005
00:52:20,260 --> 00:52:30,320
designate which IP address and let me

1006
00:52:27,470 --> 00:52:31,670
just so I'm going to cheat a little bit

1007
00:52:30,320 --> 00:52:36,410
I'm making sure I don't see anything

1008
00:52:31,670 --> 00:52:42,220
that's not true yeah I'm like sorry I

1009
00:52:36,410 --> 00:52:42,220
just want to make sure bind actually

1010
00:52:42,730 --> 00:52:52,460
tells you oh excuse me you'll see that a

1011
00:52:49,610 --> 00:52:54,590
socket the call to socket returns an int

1012
00:52:52,460 --> 00:52:57,290
but it's what it's returning is a file

1013
00:52:54,590 --> 00:53:00,200
descriptor remember we said that if you

1014
00:52:57,290 --> 00:53:04,100
refer to a file a low-level file just by

1015
00:53:00,200 --> 00:53:06,410
an integer ID typically a small integer

1016
00:53:04,100 --> 00:53:08,360
value there's some standard ones for

1017
00:53:06,410 --> 00:53:10,040
standard in standard out standard air

1018
00:53:08,360 --> 00:53:12,860
and then beyond that they're just

1019
00:53:10,040 --> 00:53:16,370
assigned incrementally so socket will

1020
00:53:12,860 --> 00:53:21,920
return a number that you then refer used

1021
00:53:16,370 --> 00:53:26,030
to refer to this as a file so bind then

1022
00:53:21,920 --> 00:53:29,920
you pass in that the name of your socket

1023
00:53:26,030 --> 00:53:35,440
file descriptor and you provide a

1024
00:53:29,920 --> 00:53:35,440
whether is a socket adder ends

1025
00:53:37,480 --> 00:53:46,040
and si I'm using the the notation s si

1026
00:53:43,099 --> 00:53:51,050
as a shortcut for sock adder struct sock

1027
00:53:46,040 --> 00:53:52,880
adder and then you have to also say what

1028
00:53:51,050 --> 00:53:56,569
the length of the address is so in the

1029
00:53:52,880 --> 00:53:58,609
case of ipv4 that would be four but you

1030
00:53:56,569 --> 00:54:01,220
don't usually use that number directly

1031
00:53:58,609 --> 00:54:03,319
there's a we'll talk about it but that

1032
00:54:01,220 --> 00:54:06,530
top level call called gedit or header

1033
00:54:03,319 --> 00:54:09,290
info it's a relatively new API that was

1034
00:54:06,530 --> 00:54:11,930
created and is in this edition of the

1035
00:54:09,290 --> 00:54:13,700
book but not in previous ones is become

1036
00:54:11,930 --> 00:54:15,410
the now the standard way that you get

1037
00:54:13,700 --> 00:54:17,059
all the parameters that you're supposed

1038
00:54:15,410 --> 00:54:19,849
to pass into all these different calls

1039
00:54:17,059 --> 00:54:22,010
and the idea of it then is it's a pretty

1040
00:54:19,849 --> 00:54:28,790
small adjustment to then write code

1041
00:54:22,010 --> 00:54:30,140
that's good for either ipv4 or ipv6 so

1042
00:54:28,790 --> 00:54:32,390
you don't normally give the actual

1043
00:54:30,140 --> 00:54:35,410
number from that you get it from another

1044
00:54:32,390 --> 00:54:35,410
place in passages

1045
00:54:37,630 --> 00:54:49,390
so binding then is it's a kernel call

1046
00:55:01,060 --> 00:55:10,250
that designates which particular service

1047
00:55:05,780 --> 00:55:12,080
this program is going to be hosting or

1048
00:55:10,250 --> 00:55:15,400
which it will be the server for and

1049
00:55:12,080 --> 00:55:15,400
that's given by its port number

1050
00:55:22,140 --> 00:55:32,420
and then the next step is to to listen

1051
00:55:27,839 --> 00:55:32,420
and that's just a call that says

1052
00:55:40,060 --> 00:55:46,640
that will now convert this socket to a

1053
00:55:44,420 --> 00:55:56,300
listening socket which you need as a

1054
00:55:46,640 --> 00:56:00,619
server so it's a way of telling the

1055
00:55:56,300 --> 00:56:03,070
kernel that this will be it will be a

1056
00:56:00,619 --> 00:56:03,070
server-side

1057
00:56:06,760 --> 00:56:13,430
so obviously bind and listen our related

1058
00:56:11,000 --> 00:56:15,320
ideas but you have to do both steps and

1059
00:56:13,430 --> 00:56:20,560
in that particular order to create a

1060
00:56:15,320 --> 00:56:20,560
listening socket for one first server

1061
00:56:21,859 --> 00:56:29,079
and then the final part of that to

1062
00:56:24,559 --> 00:56:29,079
operate it is to say except

1063
00:56:32,079 --> 00:56:35,009
and

1064
00:56:38,250 --> 00:56:44,940
oh that means okay now we've established

1065
00:56:42,210 --> 00:56:47,280
this now I'm actually ready to receive

1066
00:56:44,940 --> 00:56:50,880
phone calls is essentially what it says

1067
00:56:47,280 --> 00:56:53,190
this is the final step to say okay this

1068
00:56:50,880 --> 00:57:03,060
one's ready to accept connection

1069
00:56:53,190 --> 00:57:06,360
requests and it has a similar set of

1070
00:57:03,060 --> 00:57:08,280
arguments to socket socket but slight

1071
00:57:06,360 --> 00:57:11,910
difference and now the interesting thing

1072
00:57:08,280 --> 00:57:15,900
is acceptable return yet another file

1073
00:57:11,910 --> 00:57:21,450
descriptor now so the first file

1074
00:57:15,900 --> 00:57:24,870
descriptor is the sort of generic accept

1075
00:57:21,450 --> 00:57:27,300
and basically accept we'll just hang

1076
00:57:24,870 --> 00:57:31,590
there and wait until some client makes a

1077
00:57:27,300 --> 00:57:37,260
connection and when it does then it will

1078
00:57:31,590 --> 00:57:39,530
set up a new socket and a new with a new

1079
00:57:37,260 --> 00:57:42,570
file descriptor that then the server

1080
00:57:39,530 --> 00:57:44,520
communicates to the client via that one

1081
00:57:42,570 --> 00:57:47,300
and I'll talk about why it's a different

1082
00:57:44,520 --> 00:57:51,830
file descriptor in just a second okay

1083
00:57:47,300 --> 00:57:54,660
over on the client side goes through

1084
00:57:51,830 --> 00:57:56,820
similar steps of socket but it doesn't

1085
00:57:54,660 --> 00:57:59,280
have to bind or listen or accept because

1086
00:57:56,820 --> 00:58:03,920
this is a client and instead what it

1087
00:57:59,280 --> 00:58:03,920
does is it it makes a call to connect

1088
00:58:05,520 --> 00:58:32,700
so let me do this yourself so these are

1089
00:58:22,830 --> 00:58:43,140
all on the server side and on the client

1090
00:58:32,700 --> 00:58:46,890
side it will make a call to connect and

1091
00:58:43,140 --> 00:58:51,020
that's its job of that is from a client

1092
00:58:46,890 --> 00:58:51,020
side is to set up a connection to server

1093
00:59:04,750 --> 00:59:08,070
and so

1094
00:59:15,289 --> 00:59:21,839
it's arguments it's a little easier to

1095
00:59:18,539 --> 00:59:25,559
understand how kynect works so in

1096
00:59:21,839 --> 00:59:27,809
particular the call to socket

1097
00:59:25,559 --> 00:59:31,259
that was made beforehand returns a file

1098
00:59:27,809 --> 00:59:32,999
descriptor and what this says is I want

1099
00:59:31,259 --> 00:59:36,089
to on that particularly using that

1100
00:59:32,999 --> 00:59:38,970
particular socket connect to this gives

1101
00:59:36,089 --> 00:59:41,759
a combination of an address and a port

1102
00:59:38,970 --> 00:59:43,950
number and it has to give this address

1103
00:59:41,759 --> 00:59:45,539
length which I said like I said as

1104
00:59:43,950 --> 00:59:49,319
before it's usually that number is

1105
00:59:45,539 --> 00:59:54,299
filled in using the return value of get

1106
00:59:49,319 --> 00:59:56,450
a tour info but that's sort of the

1107
00:59:54,299 --> 01:00:01,049
equivalent of poisoning the cauldron and

1108
00:59:56,450 --> 01:00:04,640
it returns just a code which is whether

1109
01:00:01,049 --> 01:00:04,640
the connection was successful or not

1110
01:00:05,369 --> 01:00:11,260
so let me just talk about these

1111
01:00:09,099 --> 01:00:15,030
different ports and what it all means

1112
01:00:11,260 --> 01:00:18,660
when you set up a connection so when the

1113
01:00:15,030 --> 01:00:22,559
the server went through bind and listen

1114
01:00:18,660 --> 01:00:25,480
it created a listening port from that

1115
01:00:22,559 --> 01:00:28,210
which is the one that it's listening for

1116
01:00:25,480 --> 01:00:31,119
connection requests on and then the

1117
01:00:28,210 --> 01:00:33,700
client when it called socket it was

1118
01:00:31,119 --> 01:00:38,559
given a particular file descriptor for

1119
01:00:33,700 --> 01:00:41,410
that net socket and it sends out a

1120
01:00:38,559 --> 01:00:45,790
connection request that goes out over

1121
01:00:41,410 --> 01:00:47,920
the network and lands at the server and

1122
01:00:45,790 --> 01:00:51,910
then the kernel hands that off to the

1123
01:00:47,920 --> 01:00:57,369
the the program that's running on that

1124
01:00:51,910 --> 01:01:00,099
particular port and hands it off to the

1125
01:00:57,369 --> 01:01:05,579
ik that call will be handled by the

1126
01:01:00,099 --> 01:01:09,910
accept call to accept by the server and

1127
01:01:05,579 --> 01:01:13,470
then as I mentioned except actually

1128
01:01:09,910 --> 01:01:17,049
returns a new file descriptor which the

1129
01:01:13,470 --> 01:01:19,569
server will then use as its connection

1130
01:01:17,049 --> 01:01:21,940
point to this particular client and the

1131
01:01:19,569 --> 01:01:25,780
theory of that is you want to be able to

1132
01:01:21,940 --> 01:01:28,540
in general as a server be handling

1133
01:01:25,780 --> 01:01:34,030
multiple clients at the same time but if

1134
01:01:28,540 --> 01:01:38,079
I'm communicating with with Google or

1135
01:01:34,030 --> 01:01:40,240
Amazon you should be able to do so at

1136
01:01:38,079 --> 01:01:42,670
the same time so you want a possibility

1137
01:01:40,240 --> 01:01:44,380
of from a single host to be able to

1138
01:01:42,670 --> 01:01:47,980
serve multiple clients and that's why

1139
01:01:44,380 --> 01:01:50,500
they're all assigned different file

1140
01:01:47,980 --> 01:01:52,630
descriptors at the server end for that

1141
01:01:50,500 --> 01:01:54,609
particular connection so you can think

1142
01:01:52,630 --> 01:01:56,740
of it as the listening file descriptor

1143
01:01:54,609 --> 01:01:59,500
is just listening for incoming requests

1144
01:01:56,740 --> 01:02:01,480
for connections but once it sets up a

1145
01:01:59,500 --> 01:02:03,970
session and communicates back and forth

1146
01:02:01,480 --> 01:02:05,890
those are going through different ports

1147
01:02:03,970 --> 01:02:07,920
on the server side of things or

1148
01:02:05,890 --> 01:02:10,799
different file descriptions I'm sorry

1149
01:02:07,920 --> 01:02:13,960
same port different file descriptors

1150
01:02:10,799 --> 01:02:16,230
from the software that's running on the

1151
01:02:13,960 --> 01:02:16,230
server

1152
01:02:21,580 --> 01:02:26,510
okay and then during the actual

1153
01:02:24,410 --> 01:02:29,510
communication then as I mentioned it

1154
01:02:26,510 --> 01:02:31,790
uses reads and writes as a way to send

1155
01:02:29,510 --> 01:02:35,990
and receive messages and that goes on

1156
01:02:31,790 --> 01:02:38,930
for as long as you know and according to

1157
01:02:35,990 --> 01:02:45,280
whatever lo of particular protocol is

1158
01:02:38,930 --> 01:02:51,370
being supported by this application and

1159
01:02:45,280 --> 01:02:54,940
then in the end then when the client the

1160
01:02:51,370 --> 01:02:59,360
client is done it closes the request and

1161
01:02:54,940 --> 01:03:01,970
what that looks like from the server end

1162
01:02:59,360 --> 01:03:05,080
is it tries to read from a file and it

1163
01:03:01,970 --> 01:03:09,080
receives an into file a signal instead

1164
01:03:05,080 --> 01:03:13,390
and that tells the server okay this

1165
01:03:09,080 --> 01:03:18,560
particular connection is is gone and so

1166
01:03:13,390 --> 01:03:23,060
now it will close that particular one as

1167
01:03:18,560 --> 01:03:27,320
this picture shows here potentially the

1168
01:03:23,060 --> 01:03:29,720
server could loop back around and accept

1169
01:03:27,320 --> 01:03:32,930
a connection from another program and in

1170
01:03:29,720 --> 01:03:38,360
fact this can be done this is what we

1171
01:03:32,930 --> 01:03:40,760
call a serial or entered a serial server

1172
01:03:38,360 --> 01:03:43,610
where it can only manage one connection

1173
01:03:40,760 --> 01:03:46,270
request at a time and when we get later

1174
01:03:43,610 --> 01:03:48,770
in the course and we talk talk about

1175
01:03:46,270 --> 01:03:51,320
multi-threading we'll be able to set it

1176
01:03:48,770 --> 01:03:53,960
up so this thing can start accepting

1177
01:03:51,320 --> 01:03:56,180
requests for another connection even

1178
01:03:53,960 --> 01:03:59,720
while it's handling one particular

1179
01:03:56,180 --> 01:04:02,780
client but anyways what it will look

1180
01:03:59,720 --> 01:04:04,400
like is the server will read the attempt

1181
01:04:02,780 --> 01:04:05,960
to read that will get an into file it

1182
01:04:04,400 --> 01:04:08,570
will close that particular connection

1183
01:04:05,960 --> 01:04:12,190
and it will go back and it will accept a

1184
01:04:08,570 --> 01:04:12,190
new connection from a new client

1185
01:04:12,640 --> 01:04:18,500
okay I'm going to jump ahead and

1186
01:04:16,340 --> 01:04:22,280
actually start talking about some slides

1187
01:04:18,500 --> 01:04:24,680
from that we're if you look online

1188
01:04:22,280 --> 01:04:26,510
they're actually from a Thursday's

1189
01:04:24,680 --> 01:04:28,040
lecture because there's a lot of ground

1190
01:04:26,510 --> 01:04:32,540
to cover in that lecture and I'd like to

1191
01:04:28,040 --> 01:04:36,170
get a little head start so I mentioned

1192
01:04:32,540 --> 01:04:39,800
this this function called get a door

1193
01:04:36,170 --> 01:04:42,980
info which is sort of the modern way in

1194
01:04:39,800 --> 01:04:45,590
C at least to find information about

1195
01:04:42,980 --> 01:04:48,260
that deals with all the funkiness of

1196
01:04:45,590 --> 01:04:50,690
host names host addresses all the

1197
01:04:48,260 --> 01:04:52,280
conventions about ports and some of

1198
01:04:50,690 --> 01:04:55,580
these various structures and things like

1199
01:04:52,280 --> 01:04:58,130
that and the advantage of doing it this

1200
01:04:55,580 --> 01:05:01,670
way instead of the old way is first of

1201
01:04:58,130 --> 01:05:04,700
all now it's 30 unifies ipv4 and ipv6

1202
01:05:01,670 --> 01:05:07,100
have very similar looking interfaces and

1203
01:05:04,700 --> 01:05:09,380
it's fairly easy to write code that can

1204
01:05:07,100 --> 01:05:11,180
handle either and the other words there

1205
01:05:09,380 --> 01:05:13,060
is problems with these old ones that

1206
01:05:11,180 --> 01:05:16,310
they were designed in an era before

1207
01:05:13,060 --> 01:05:18,970
multi-threading and so they have a very

1208
01:05:16,310 --> 01:05:22,280
aesthetically allocated buffers which

1209
01:05:18,970 --> 01:05:24,680
gave a lot of bad conditions that you

1210
01:05:22,280 --> 01:05:27,110
had to watch out for in writing code and

1211
01:05:24,680 --> 01:05:31,490
we're prone to errors of various sorts

1212
01:05:27,110 --> 01:05:35,440
and so this new new format it's actually

1213
01:05:31,490 --> 01:05:38,300
harder to use in many levels because it

1214
01:05:35,440 --> 01:05:39,890
can't hide away as many details as it

1215
01:05:38,300 --> 01:05:41,000
used to but it has the advantage it

1216
01:05:39,890 --> 01:05:43,850
works better in a multi-threaded

1217
01:05:41,000 --> 01:05:45,920
environment the other thing that makes

1218
01:05:43,850 --> 01:05:49,700
it hard is it's trying to be sort of the

1219
01:05:45,920 --> 01:05:52,400
kitchen sink of of protocol managers and

1220
01:05:49,700 --> 01:05:55,220
that makes it a little bit nasty and

1221
01:05:52,400 --> 01:05:57,260
messy and so we're only going to sort of

1222
01:05:55,220 --> 01:06:00,910
focus in on the parts that we really

1223
01:05:57,260 --> 01:06:00,910
need to make use of for this course

1224
01:06:01,740 --> 01:06:08,410
so in particular there's this function

1225
01:06:04,120 --> 01:06:10,800
called get a dirt info where the

1226
01:06:08,410 --> 01:06:14,320
information you're passing is a host

1227
01:06:10,800 --> 01:06:16,750
which can be either a it's a string as

1228
01:06:14,320 --> 01:06:20,260
it shows most these are care stars are

1229
01:06:16,750 --> 01:06:23,350
actual real strings not fake strings it

1230
01:06:20,260 --> 01:06:25,570
used to be back in the old days you use

1231
01:06:23,350 --> 01:06:27,040
care stars a generic pointer because

1232
01:06:25,570 --> 01:06:29,800
there weren't void stars but these are

1233
01:06:27,040 --> 01:06:32,470
actual strings so you give the name like

1234
01:06:29,800 --> 01:06:35,500
the the domain name of a host or you can

1235
01:06:32,470 --> 01:06:38,770
give the dotted decimal name but written

1236
01:06:35,500 --> 01:06:43,030
as you know sequence of characters one

1237
01:06:38,770 --> 01:06:47,680
two aches dot so forth a service for

1238
01:06:43,030 --> 01:06:50,440
example that this is ipv4 to TCP service

1239
01:06:47,680 --> 01:06:51,730
some other information that that's

1240
01:06:50,440 --> 01:06:53,800
associated with this particular

1241
01:06:51,730 --> 01:06:55,840
connection they refer to as hints

1242
01:06:53,800 --> 01:06:58,300
because again this is trying to be a

1243
01:06:55,840 --> 01:07:00,850
very generic looking call and then you

1244
01:06:58,300 --> 01:07:04,630
pass it in a pointer and it will fill in

1245
01:07:00,850 --> 01:07:07,420
and return back a pointer to a data

1246
01:07:04,630 --> 01:07:10,030
structure which is essentially the way

1247
01:07:07,420 --> 01:07:12,940
it's returning results back to you and

1248
01:07:10,030 --> 01:07:15,340
then associated with that is a call

1249
01:07:12,940 --> 01:07:19,510
called free adder info that will then

1250
01:07:15,340 --> 01:07:22,570
deallocate this face that's used by this

1251
01:07:19,510 --> 01:07:26,500
data structure from the result and then

1252
01:07:22,570 --> 01:07:29,020
there's one called get adder info string

1253
01:07:26,500 --> 01:07:31,180
error which lets you interpret the

1254
01:07:29,020 --> 01:07:33,610
various error code to get created by

1255
01:07:31,180 --> 01:07:37,340
this routine of the value that it

1256
01:07:33,610 --> 01:07:40,630
returns so

1257
01:07:37,340 --> 01:07:44,480
let's just look a little about this and

1258
01:07:40,630 --> 01:07:49,550
so the result that's returned by get a

1259
01:07:44,480 --> 01:07:52,160
door info is a linked list that is null

1260
01:07:49,550 --> 01:07:56,450
terminated which is like most linguists

1261
01:07:52,160 --> 01:08:06,320
are where it gives some combination of

1262
01:07:56,450 --> 01:08:09,050
the name of this particular some naming

1263
01:08:06,320 --> 01:08:10,850
information for the the first top-level

1264
01:08:09,050 --> 01:08:14,540
one is the what I showed you the

1265
01:08:10,850 --> 01:08:17,960
canonical name for this particular IP

1266
01:08:14,540 --> 01:08:23,650
address and then it gives some address

1267
01:08:17,960 --> 01:08:27,799
information which is you know an ipv4

1268
01:08:23,650 --> 01:08:30,080
them that will encode the IP address and

1269
01:08:27,799 --> 01:08:32,630
as a next pointer to change this link

1270
01:08:30,080 --> 01:08:34,520
both together and so this is actually

1271
01:08:32,630 --> 01:08:37,609
one interesting thing about this is it

1272
01:08:34,520 --> 01:08:43,670
sort of takes care of that many too many

1273
01:08:37,609 --> 01:08:46,880
mapping potentially of of names so if I

1274
01:08:43,670 --> 01:08:49,790
give for example google.com it will

1275
01:08:46,880 --> 01:08:51,170
return a link twist of all however many

1276
01:08:49,790 --> 01:08:52,609
or

1277
01:08:51,170 --> 01:08:54,380
you saw with Twitter it was returning

1278
01:08:52,609 --> 01:08:57,440
about four different addresses so this

1279
01:08:54,380 --> 01:08:59,330
will return actually five list entries

1280
01:08:57,440 --> 01:09:02,359
the first will be the canonical name and

1281
01:08:59,330 --> 01:09:05,930
then it will give each of the four IP

1282
01:09:02,359 --> 01:09:09,470
addresses that relevant at this

1283
01:09:05,930 --> 01:09:12,859
particular time and then you as a

1284
01:09:09,470 --> 01:09:15,799
programmer than to walk this list you

1285
01:09:12,859 --> 01:09:18,470
step down this list and typically try to

1286
01:09:15,799 --> 01:09:21,230
use each address one after the other and

1287
01:09:18,470 --> 01:09:22,819
if you fail on one then you try the next

1288
01:09:21,230 --> 01:09:24,470
and try the next until you hit the end

1289
01:09:22,819 --> 01:09:27,580
of the list and then you say whoops

1290
01:09:24,470 --> 01:09:27,580
can't do it

1291
01:09:27,939 --> 01:09:35,549
and that goes whether you're writing a

1292
01:09:29,859 --> 01:09:42,419
client or a server so that adder info

1293
01:09:35,549 --> 01:09:46,150
let's look back at what that is oh so

1294
01:09:42,419 --> 01:09:50,859
adder in fo then is what gets returned

1295
01:09:46,150 --> 01:09:53,049
is a list of adder info structs and so

1296
01:09:50,859 --> 01:10:01,380
the adder info struct contains various

1297
01:09:53,049 --> 01:10:01,380
fields which talks about what type of

1298
01:10:03,329 --> 01:10:11,919
data is here what type of socket is it

1299
01:10:07,889 --> 01:10:13,630
what its canonical name is how long are

1300
01:10:11,919 --> 01:10:17,650
its addresses you saw that it's an

1301
01:10:13,630 --> 01:10:21,039
argument to some of the calls a pointer

1302
01:10:17,650 --> 01:10:25,090
to a sock adder struct that's the way

1303
01:10:21,039 --> 01:10:27,099
that is encoded for IPV what we've

1304
01:10:25,090 --> 01:10:29,050
already seen sock adders is a sort of

1305
01:10:27,099 --> 01:10:31,630
low-level data structure that gets used

1306
01:10:29,050 --> 01:10:33,579
and then a next pointer to chain the

1307
01:10:31,630 --> 01:10:35,949
link twist together and so you'll see

1308
01:10:33,579 --> 01:10:38,320
some of these are the arguments that

1309
01:10:35,949 --> 01:10:40,479
then you will use to pass into the other

1310
01:10:38,320 --> 01:10:43,439
functions like bind and whitson and

1311
01:10:40,479 --> 01:10:43,439
connect

1312
01:10:46,619 --> 01:10:52,050
and then there's another version called

1313
01:10:48,900 --> 01:10:54,300
get name info which you use when you've

1314
01:10:52,050 --> 01:10:55,770
got an IP address and you want to find

1315
01:10:54,300 --> 01:10:58,290
what is it

1316
01:10:55,770 --> 01:11:00,270
domain name and because you remember

1317
01:10:58,290 --> 01:11:02,280
that mapping is also potentially a

1318
01:11:00,270 --> 01:11:07,770
one-to-many there can be multiple domain

1319
01:11:02,280 --> 01:11:12,119
names associated with it and so it has a

1320
01:11:07,770 --> 01:11:16,650
similar general thing we'll just look

1321
01:11:12,119 --> 01:11:20,179
right now it get editor info so just as

1322
01:11:16,650 --> 01:11:23,040
an example of how you'd write code to

1323
01:11:20,179 --> 01:11:27,719
make use of this and essentially just as

1324
01:11:23,040 --> 01:11:30,540
a way of probing the DNS server is I

1325
01:11:27,719 --> 01:11:34,380
want to set up an argument a call to get

1326
01:11:30,540 --> 01:11:37,679
adder info where the string I'm going to

1327
01:11:34,380 --> 01:11:46,219
pass the name is whatever I type in at

1328
01:11:37,679 --> 01:11:51,420
the to this application to main and it

1329
01:11:46,219 --> 01:11:56,489
just for hints just passes a bunch of

1330
01:11:51,420 --> 01:12:00,960
zeros and lists P again these are this

1331
01:11:56,489 --> 01:12:03,199
will just be a pointers that I haven't

1332
01:12:00,960 --> 01:12:03,199
actually

1333
01:12:07,460 --> 01:12:14,090
oh okay so you'll notice hints is

1334
01:12:11,030 --> 01:12:16,820
actually a struct itself whereas with T

1335
01:12:14,090 --> 01:12:18,530
and star P are just list P and P are

1336
01:12:16,820 --> 01:12:21,110
just pointers to structs they don't have

1337
01:12:18,530 --> 01:12:22,760
any allocated data so the hints I'm just

1338
01:12:21,110 --> 01:12:24,980
going to fill in that struct with all

1339
01:12:22,760 --> 01:12:28,310
zeros because I don't really need to

1340
01:12:24,980 --> 01:12:34,450
provide any hints I am telling it that I

1341
01:12:28,310 --> 01:12:37,520
want a an ipv6 TCP connection here and

1342
01:12:34,450 --> 01:12:38,770
then so what it will do is it will

1343
01:12:37,520 --> 01:12:42,140
return back

1344
01:12:38,770 --> 01:12:46,700
what returns an error code but it will

1345
01:12:42,140 --> 01:12:48,860
fill in return to me a pointer to a this

1346
01:12:46,700 --> 01:12:53,960
link twist data structure I showed

1347
01:12:48,860 --> 01:12:57,620
before and now I can step through that

1348
01:12:53,960 --> 01:13:00,920
list using standard linked list code and

1349
01:12:57,620 --> 01:13:04,840
make calls to the get name info function

1350
01:13:00,920 --> 01:13:04,840
which will return back domain names

1351
01:13:06,679 --> 01:13:10,070
and then when it's all done I have to

1352
01:13:08,360 --> 01:13:14,570
free up that whisk that got returned

1353
01:13:10,070 --> 01:13:18,040
otherwise I'll create memory stuff so

1354
01:13:14,570 --> 01:13:18,040
just as a demo

1355
01:13:26,270 --> 01:13:29,350
come on

1356
01:13:30,400 --> 01:13:44,060
so host in closer ah so you can think of

1357
01:13:38,870 --> 01:13:51,739
it this is like a not very fancy

1358
01:13:44,060 --> 01:13:55,780
implementation of nslookup so the kind

1359
01:13:51,739 --> 01:13:55,780
of stuff we already saw before but let's

1360
01:13:57,580 --> 01:14:01,489
all its returning are the different

1361
01:13:59,930 --> 01:14:04,970
addresses and one of the things that I

1362
01:14:01,489 --> 01:14:09,980
found curious is it returns them in the

1363
01:14:04,970 --> 01:14:12,470
same order all the time instead of

1364
01:14:09,980 --> 01:14:17,470
within its lookup it kept changing it

1365
01:14:12,470 --> 01:14:17,470
and I think that has to do with caching

1366
01:14:23,780 --> 01:14:32,900
no I changed I know it's kind of

1367
01:14:29,300 --> 01:14:34,790
interesting if it's you might want to

1368
01:14:32,900 --> 01:14:38,350
play with this code it's kind of you can

1369
01:14:34,790 --> 01:14:38,350
see what's going on in different places

1370
01:14:42,970 --> 01:14:49,250
and so you can see though that it's

1371
01:14:46,700 --> 01:14:52,130
basically getting the same kind of

1372
01:14:49,250 --> 01:14:54,950
information that you would from nslookup

1373
01:14:52,130 --> 01:14:58,010
Detroit is creating the DNS server to do

1374
01:14:54,950 --> 01:14:59,200
this but that's the start of what some

1375
01:14:58,010 --> 01:15:02,200
of this code looks like

1376
01:14:59,200 --> 01:15:02,200
and

1377
01:15:10,150 --> 01:15:14,170
one of the things you by the way when

1378
01:15:12,760 --> 01:15:16,690
you're writing your own code you often

1379
01:15:14,170 --> 01:15:19,150
make use of what's called localhost and

1380
01:15:16,690 --> 01:15:20,770
that's always just refers to the machine

1381
01:15:19,150 --> 01:15:23,500
that you're running on it always has

1382
01:15:20,770 --> 01:15:25,480
this particular IP address so that

1383
01:15:23,500 --> 01:15:28,270
address just refers to the machine and

1384
01:15:25,480 --> 01:15:30,670
as a programmer you do all your testing

1385
01:15:28,270 --> 01:15:31,960
on one machine you just set up both the

1386
01:15:30,670 --> 01:15:36,190
client and the server on the same

1387
01:15:31,960 --> 01:15:39,219
machine and play with it so localhost is

1388
01:15:36,190 --> 01:15:44,380
a very useful way of doing code

1389
01:15:39,219 --> 01:15:50,530
development and as this shows you can

1390
01:15:44,380 --> 01:15:54,060
request host info for others thanksgivin

1391
01:15:50,530 --> 01:15:54,060
and you can also by the way

1392
01:15:58,039 --> 01:16:02,509
always give a dotted decimal address

1393
01:16:07,710 --> 01:16:13,330
I'm just making it up here but it's not

1394
01:16:11,920 --> 01:16:17,770
very interesting because it returns back

1395
01:16:13,330 --> 01:16:21,660
to the same address it's more

1396
01:16:17,770 --> 01:16:21,660
interesting to to run nslookup on that

1397
01:16:26,700 --> 01:16:34,090
so that just gives you a sense and as

1398
01:16:31,930 --> 01:16:35,770
you've seen this code is pretty messy

1399
01:16:34,090 --> 01:16:38,260
stuff to work with there's a lot of

1400
01:16:35,770 --> 01:16:40,840
structs you have to initialize you don't

1401
01:16:38,260 --> 01:16:43,600
initialize your pass pointers and so the

1402
01:16:40,840 --> 01:16:46,360
code always looks a bit crusty but that

1403
01:16:43,600 --> 01:16:48,040
sort of the the interfaces it exists and

1404
01:16:46,360 --> 01:16:49,960
you'll just have to get somewhat

1405
01:16:48,040 --> 01:16:53,040
comfortable with it so that will do it

1406
01:16:49,960 --> 01:16:53,040
for today then thanks

