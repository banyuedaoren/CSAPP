1
00:00:00,000 --> 00:00:05,910
this comes this will be the last lecture

2
00:00:02,760 --> 00:00:08,340
on machine level programming we call it

3
00:00:05,910 --> 00:00:13,469
advanced topics but think of it more as

4
00:00:08,340 --> 00:00:14,790
miscellaneous topics and I think most to

5
00:00:13,469 --> 00:00:15,990
you of course you know that your bomb

6
00:00:14,790 --> 00:00:18,990
labs are due tonight

7
00:00:15,990 --> 00:00:22,500
so you most here probably well into that

8
00:00:18,990 --> 00:00:24,660
or hopefully through it and then at

9
00:00:22,500 --> 00:00:27,090
midnight tonight the next web will come

10
00:00:24,660 --> 00:00:28,859
out which is called a tack lab and there

11
00:00:27,090 --> 00:00:32,550
is a recitation about that yesterday but

12
00:00:28,859 --> 00:00:35,940
this is a lab that are new to the course

13
00:00:32,550 --> 00:00:38,010
it's a similar to one that we used to

14
00:00:35,940 --> 00:00:41,160
use at this point in the course but it's

15
00:00:38,010 --> 00:00:46,559
been updated and changed in significant

16
00:00:41,160 --> 00:00:48,989
ways so we're actually when you have

17
00:00:46,559 --> 00:00:50,579
labs like we do in this course with this

18
00:00:48,989 --> 00:00:53,190
many students there's a lot of things

19
00:00:50,579 --> 00:00:55,530
that go can go wrong so we're going to

20
00:00:53,190 --> 00:00:57,510
keep a close eye on on how things are

21
00:00:55,530 --> 00:00:59,190
going but I'd encourage you you only

22
00:00:57,510 --> 00:01:03,239
have a week and a half to do this next

23
00:00:59,190 --> 00:01:05,250
web to get started soon and partly by

24
00:01:03,239 --> 00:01:07,290
having some people start sooner you'll

25
00:01:05,250 --> 00:01:11,070
start breaking things for us that we can

26
00:01:07,290 --> 00:01:14,729
track down so today what we'll talk

27
00:01:11,070 --> 00:01:16,470
about is a couple like I said it's

28
00:01:14,729 --> 00:01:19,710
miscellaneous topics but important

29
00:01:16,470 --> 00:01:23,310
topics one is to sort of where what does

30
00:01:19,710 --> 00:01:26,759
the memory look like when you're running

31
00:01:23,310 --> 00:01:29,189
x86 64 programs the other is a very

32
00:01:26,759 --> 00:01:31,140
important topic on security

33
00:01:29,189 --> 00:01:33,420
vulnerability called buffer overflows

34
00:01:31,140 --> 00:01:36,509
and in fact at a collab we'll be

35
00:01:33,420 --> 00:01:38,670
precisely exploiting those security

36
00:01:36,509 --> 00:01:41,159
vulnerabilities and then we'll look at

37
00:01:38,670 --> 00:01:44,159
Union so far you've looked at arrays and

38
00:01:41,159 --> 00:01:49,649
structs and how they're organized and I

39
00:01:44,159 --> 00:01:52,229
want to compare that to unions so let's

40
00:01:49,649 --> 00:01:53,720
talk about memory then as I said at the

41
00:01:52,229 --> 00:01:56,820
beginning early in the course

42
00:01:53,720 --> 00:02:01,590
conceptually a memory is just a big

43
00:01:56,820 --> 00:02:04,020
array of bytes and that the view of this

44
00:02:01,590 --> 00:02:05,130
machine level programmer even though

45
00:02:04,020 --> 00:02:07,469
it's not the actual implementation

46
00:02:05,130 --> 00:02:10,349
there's a whole part that we'll talk

47
00:02:07,469 --> 00:02:12,550
about later in the course of this is

48
00:02:10,349 --> 00:02:15,100
called virtual memory

49
00:02:12,550 --> 00:02:17,290
this organization is very simple

50
00:02:15,100 --> 00:02:19,180
organization but the underlying

51
00:02:17,290 --> 00:02:22,480
implementation is this complex

52
00:02:19,180 --> 00:02:26,310
management of various different memory

53
00:02:22,480 --> 00:02:30,910
types from disk memories to solid state

54
00:02:26,310 --> 00:02:33,220
disks and to what's called DRAM which

55
00:02:30,910 --> 00:02:38,050
stands for dynamic Ram the when you buy

56
00:02:33,220 --> 00:02:41,100
memory for your processor is DRAM oh so

57
00:02:38,050 --> 00:02:45,160
as you know in x86 64 we're working with

58
00:02:41,100 --> 00:02:48,250
machines that nominally are have

59
00:02:45,160 --> 00:02:50,440
addresses can be up to 64 bits long and

60
00:02:48,250 --> 00:02:52,030
if you work out the numbers remember I

61
00:02:50,440 --> 00:02:55,270
told you at the beginning of the course

62
00:02:52,030 --> 00:02:58,780
you can estimate how big a number like

63
00:02:55,270 --> 00:03:02,020
to the 64 is by remembering that a

64
00:02:58,780 --> 00:03:04,120
thousand 24 and a thousand are very

65
00:03:02,020 --> 00:03:07,500
close to each other so two to the tenth

66
00:03:04,120 --> 00:03:11,740
is roughly the same as 10 to the third

67
00:03:07,500 --> 00:03:14,980
so you take 64 and you think 60 so how

68
00:03:11,740 --> 00:03:19,600
big is 2 to the 60 well that's 6 times

69
00:03:14,980 --> 00:03:23,680
10 and therefore it's 6 times 3 it's

70
00:03:19,600 --> 00:03:27,100
like 10 to the 18th and then you add the

71
00:03:23,680 --> 00:03:30,070
4 to that that's 2 to the 4th and 16 so

72
00:03:27,100 --> 00:03:36,220
it's around 16 times 10 to the 18th

73
00:03:30,070 --> 00:03:40,660
fight so if you were to go off and look

74
00:03:36,220 --> 00:03:43,570
online on Amazon for DRAM chips and try

75
00:03:40,660 --> 00:03:47,650
to buy that much memory you'd find

76
00:03:43,570 --> 00:03:50,440
you're spending a lot of money more than

77
00:03:47,650 --> 00:03:53,320
you I don't know the numbers but it

78
00:03:50,440 --> 00:03:56,230
would be a lot of memory money and so

79
00:03:53,320 --> 00:04:04,060
you basically can't do it nowadays tend

80
00:03:56,230 --> 00:04:06,880
to the and so right now the machines

81
00:04:04,060 --> 00:04:12,130
limit you to actually only 47 bits worth

82
00:04:06,880 --> 00:04:14,500
of address in the address space and so 2

83
00:04:12,130 --> 00:04:18,730
to the 47th again work that out that's

84
00:04:14,500 --> 00:04:23,350
like 10 to the 12th times 256 times 10

85
00:04:18,730 --> 00:04:25,390
to the 12th so it's 256 terabytes and as

86
00:04:23,350 --> 00:04:26,230
you know you can buy a disk drive now

87
00:04:25,390 --> 00:04:27,880
that has 8

88
00:04:26,230 --> 00:04:29,830
jeribai so it doesn't seem like that

89
00:04:27,880 --> 00:04:32,620
much but if you tried to buy that much

90
00:04:29,830 --> 00:04:39,550
DRAM again you'd have to have a pretty

91
00:04:32,620 --> 00:04:42,250
big credit-card limit and so even that's

92
00:04:39,550 --> 00:04:44,410
a huge number and modern supercomputer

93
00:04:42,250 --> 00:04:46,540
in situations actually will have almost

94
00:04:44,410 --> 00:04:50,410
that much memory but the point is that

95
00:04:46,540 --> 00:04:53,830
the hardware of today limits you to 47

96
00:04:50,410 --> 00:04:56,650
bits worth of address but that's not

97
00:04:53,830 --> 00:04:59,350
really a real limitation in terms of of

98
00:04:56,650 --> 00:05:01,750
actual machines and what will happen is

99
00:04:59,350 --> 00:05:03,940
is memory prices get cheaper and the

100
00:05:01,750 --> 00:05:06,550
technology gets better they'll slowly

101
00:05:03,940 --> 00:05:09,400
start adding as succeeding generations

102
00:05:06,550 --> 00:05:12,870
of processors come along let you have

103
00:05:09,400 --> 00:05:19,660
bigger and bigger range of addresses so

104
00:05:12,870 --> 00:05:22,120
all that is to say that's why this

105
00:05:19,660 --> 00:05:30,340
number shows up which is a seven

106
00:05:22,120 --> 00:05:32,110
followed by 11s I can tell I need to

107
00:05:30,340 --> 00:05:34,540
scribble some numbers you guys aren't

108
00:05:32,110 --> 00:05:40,020
just saying numbers in the air is not

109
00:05:34,540 --> 00:05:40,020
working here so let's try

110
00:05:52,639 --> 00:06:01,259
okay

111
00:05:54,320 --> 00:06:09,900
so remember I said before 264 is about

112
00:06:01,259 --> 00:06:19,259
equal to 16 times 10 to the 18th - to

113
00:06:09,900 --> 00:06:22,820
the 47th is 128 times 10 to the 12th so

114
00:06:19,259 --> 00:06:22,820
it's 128 terabytes

115
00:06:28,449 --> 00:06:39,009
so what's the number after a terabyte

116
00:06:31,250 --> 00:06:42,430
you know 10 to the 15th how many but yes

117
00:06:39,009 --> 00:06:42,430
petabytes right

118
00:06:44,190 --> 00:06:50,330
and you know what 10v 18th is exha

119
00:06:52,490 --> 00:07:02,250
so just as a reference a company like

120
00:06:57,690 --> 00:07:05,699
Google roughly it's probably a total

121
00:07:02,250 --> 00:07:09,289
storage across the whole enterprises

122
00:07:05,699 --> 00:07:14,610
measured in some small number of X bytes

123
00:07:09,289 --> 00:07:16,770
and it every day is getting several

124
00:07:14,610 --> 00:07:20,009
petabytes I don't know the numbers are

125
00:07:16,770 --> 00:07:23,400
of course secret but maybe 10 petabytes

126
00:07:20,009 --> 00:07:26,190
or more per day of new data that it's

127
00:07:23,400 --> 00:07:29,400
ingesting into its system so these

128
00:07:26,190 --> 00:07:30,810
numbers are pretty huge but not just

129
00:07:29,400 --> 00:07:35,699
totally off the charts do you know what

130
00:07:30,810 --> 00:07:40,490
10 to the 21st is it's called a

131
00:07:35,699 --> 00:07:40,490
zettabyte with two t's

132
00:07:40,940 --> 00:07:46,040
and it's estimated if you add up all the

133
00:07:43,880 --> 00:07:48,500
digital content in the world that gets

134
00:07:46,040 --> 00:07:52,850
created everybody's cell phone camera

135
00:07:48,500 --> 00:07:55,520
every video taken by anyone anywhere all

136
00:07:52,850 --> 00:07:58,430
year long is a couple of zettabytes a

137
00:07:55,520 --> 00:08:00,700
year so it'll be a while before we're

138
00:07:58,430 --> 00:08:04,930
really having to deal with that kind of

139
00:08:00,700 --> 00:08:09,440
memory so just just give you an idea so

140
00:08:04,930 --> 00:08:12,950
128 terabytes is the address limit on

141
00:08:09,440 --> 00:08:15,890
these systems and so that's why you have

142
00:08:12,950 --> 00:08:19,870
to have seven because you remember

143
00:08:15,890 --> 00:08:23,270
that's one two three and then there's F

144
00:08:19,870 --> 00:08:29,210
but there's 11 of them and this is one

145
00:08:23,270 --> 00:08:34,219
one one times 11 so that's 44 ones and

146
00:08:29,210 --> 00:08:40,849
this is three one and that's where you

147
00:08:34,219 --> 00:08:44,450
get 47 and that's the address of the in

148
00:08:40,849 --> 00:08:46,730
Linux that's where they put the stack is

149
00:08:44,450 --> 00:08:49,430
up at the very top of the address space

150
00:08:46,730 --> 00:08:51,410
and I should tell you this picture is

151
00:08:49,430 --> 00:08:53,740
not at all to scale it would be

152
00:08:51,410 --> 00:08:56,300
impossible to draw this picture to scale

153
00:08:53,740 --> 00:08:59,660
for example it shows that the stack

154
00:08:56,300 --> 00:09:03,470
starts way up at the top and remember

155
00:08:59,660 --> 00:09:06,470
stacks grow to smaller addresses when

156
00:09:03,470 --> 00:09:08,600
you're pushing and also we show the them

157
00:09:06,470 --> 00:09:14,750
upside down just to make everything

158
00:09:08,600 --> 00:09:17,000
confusing so the the stack starts there

159
00:09:14,750 --> 00:09:19,310
and it grows towards lower addresses and

160
00:09:17,000 --> 00:09:22,130
on a typical system it will be limited

161
00:09:19,310 --> 00:09:27,650
to 8 megabytes and you can tell that on

162
00:09:22,130 --> 00:09:33,860
a Linux system at least with the the

163
00:09:27,650 --> 00:09:36,260
limit command which used to be more

164
00:09:33,860 --> 00:09:37,880
interesting that it was it is now

165
00:09:36,260 --> 00:09:40,610
because a lot of things are unlimited

166
00:09:37,880 --> 00:09:43,760
but you see it says the stack size is

167
00:09:40,610 --> 00:09:47,830
limited 8192 K bytes to kilobytes so

168
00:09:43,760 --> 00:09:47,830
it's 8 megabytes

169
00:09:49,529 --> 00:10:00,350
and what that means is if you tried to

170
00:09:53,720 --> 00:10:00,350
access any memory via the stack pointer

171
00:10:00,740 --> 00:10:08,129
that was outside of the range of this 8

172
00:10:06,720 --> 00:10:12,509
megabyte range you'd get a segmentation

173
00:10:08,129 --> 00:10:15,509
fault and then down at the lower address

174
00:10:12,509 --> 00:10:17,490
is what comes in of what gets put into

175
00:10:15,509 --> 00:10:19,800
your program are the parts of the code

176
00:10:17,490 --> 00:10:22,680
that that come out of the executable

177
00:10:19,800 --> 00:10:24,389
file and so there's a section and we'll

178
00:10:22,680 --> 00:10:26,699
talk more when we talk about linking

179
00:10:24,389 --> 00:10:29,519
actually about the way out of the memory

180
00:10:26,699 --> 00:10:31,889
and the different regions of it but for

181
00:10:29,519 --> 00:10:34,079
some obscure reason they they call where

182
00:10:31,889 --> 00:10:37,620
the code is sitting the executable

183
00:10:34,079 --> 00:10:39,930
program the text segment I don't know

184
00:10:37,620 --> 00:10:42,809
why that's true but it's the way it is

185
00:10:39,930 --> 00:10:45,629
nets across many machines and then the

186
00:10:42,809 --> 00:10:48,149
data is first of all there'll be a

187
00:10:45,629 --> 00:10:51,269
section for the data that's allocated it

188
00:10:48,149 --> 00:10:54,149
the program begins so any global

189
00:10:51,269 --> 00:10:58,350
variables that you've declared will be

190
00:10:54,149 --> 00:11:01,470
in that section and then the heat is the

191
00:10:58,350 --> 00:11:03,839
part of memory that is X is allocated

192
00:11:01,470 --> 00:11:06,839
via call to malloc or one of its related

193
00:11:03,839 --> 00:11:09,689
functions and so that varies dynamically

194
00:11:06,839 --> 00:11:12,480
as the program runs it starts off with a

195
00:11:09,689 --> 00:11:13,579
very small allocation and every time you

196
00:11:12,480 --> 00:11:18,209
call malloc

197
00:11:13,579 --> 00:11:20,430
if you're not freeing memory and so your

198
00:11:18,209 --> 00:11:24,480
memory requirements keep growing it will

199
00:11:20,430 --> 00:11:27,209
crease keep up moving up larger and

200
00:11:24,480 --> 00:11:29,699
larger addresses and then somewhere in

201
00:11:27,209 --> 00:11:33,149
the code - and this can vary by system

202
00:11:29,699 --> 00:11:35,550
is the code that gets brought in that

203
00:11:33,149 --> 00:11:38,459
represents the library functions things

204
00:11:35,550 --> 00:11:40,889
like pretty and malloc itself our own

205
00:11:38,459 --> 00:11:43,350
library code they're stored off on disk

206
00:11:40,889 --> 00:11:45,089
and they get brought in they get linked

207
00:11:43,350 --> 00:11:47,519
into your program when it first starts

208
00:11:45,089 --> 00:11:49,529
executing by a process known as dynamic

209
00:11:47,519 --> 00:11:52,949
linking which we'll talk about later in

210
00:11:49,529 --> 00:11:54,949
the course - with the linking and what

211
00:11:52,949 --> 00:11:57,300
you'll find in general is that

212
00:11:54,949 --> 00:12:00,000
allocations will tend to be either at

213
00:11:57,300 --> 00:12:02,020
these very low addresses or these very

214
00:12:00,000 --> 00:12:07,660
high addresses

215
00:12:02,020 --> 00:12:11,260
as your program is running so just as an

216
00:12:07,660 --> 00:12:13,750
example here is some code that it's only

217
00:12:11,260 --> 00:12:16,149
value is to show you different where

218
00:12:13,750 --> 00:12:19,060
things get located and so you'll see I

219
00:12:16,149 --> 00:12:23,020
allocated some a fairly large arrays

220
00:12:19,060 --> 00:12:27,790
here this one is there all cares but

221
00:12:23,020 --> 00:12:31,930
this is 2 to the 24th so 16 a mega byte

222
00:12:27,790 --> 00:12:37,480
array and this one is 2 to the 31st so

223
00:12:31,930 --> 00:12:41,279
it's 2 gigabytes worth of array I found

224
00:12:37,480 --> 00:12:46,899
that if I tried to allocate larger ones

225
00:12:41,279 --> 00:12:49,899
the program wouldn't run and I also do

226
00:12:46,899 --> 00:12:53,620
some here's just a sort of global

227
00:12:49,899 --> 00:12:55,839
variable and here's a function and then

228
00:12:53,620 --> 00:12:57,730
there's a single function here with some

229
00:12:55,839 --> 00:12:59,649
local variable and that will be

230
00:12:57,730 --> 00:13:02,320
allocated somewhere on the stack and

231
00:12:59,649 --> 00:13:05,020
then there's several calls to milk some

232
00:13:02,320 --> 00:13:07,450
of which are for some very small chunks

233
00:13:05,020 --> 00:13:10,329
of memory and similarly where for some

234
00:13:07,450 --> 00:13:13,630
very large chunks of memory and so we

235
00:13:10,329 --> 00:13:16,839
can run this program and see what

236
00:13:13,630 --> 00:13:20,680
addresses pop out of it and what you'll

237
00:13:16,839 --> 00:13:23,470
see is the stack this local variable is

238
00:13:20,680 --> 00:13:26,050
somewhere up with an address in the

239
00:13:23,470 --> 00:13:27,790
range of the stack and you see the 7 and

240
00:13:26,050 --> 00:13:30,070
a couple FS and then it goes to

241
00:13:27,790 --> 00:13:33,490
something else and you'll see also

242
00:13:30,070 --> 00:13:37,000
interestingly enough that the codec and

243
00:13:33,490 --> 00:13:40,089
then looking down at the bottom of this

244
00:13:37,000 --> 00:13:42,490
yellow color is things get relegated to

245
00:13:40,089 --> 00:13:45,790
the text segment the main function and

246
00:13:42,490 --> 00:13:49,000
this function I called I declared called

247
00:13:45,790 --> 00:13:52,870
useless and then the predefined arrays

248
00:13:49,000 --> 00:13:55,270
that were in other words globally

249
00:13:52,870 --> 00:13:58,740
declared not declared by malloc they're

250
00:13:55,270 --> 00:14:02,700
declared as part of the program itself

251
00:13:58,740 --> 00:14:05,950
are down here in this data section and

252
00:14:02,700 --> 00:14:07,600
because it's a very large array the huge

253
00:14:05,950 --> 00:14:10,420
array you actually get some fairly large

254
00:14:07,600 --> 00:14:13,910
addresses and then interestingly enough

255
00:14:10,420 --> 00:14:17,300
or I don't know why it's interesting but

256
00:14:13,910 --> 00:14:20,840
for one reason or another it happens

257
00:14:17,300 --> 00:14:23,870
that the smaller chunks of memory

258
00:14:20,840 --> 00:14:25,370
allocations are down here at addresses

259
00:14:23,870 --> 00:14:28,790
that are actually just a little bit

260
00:14:25,370 --> 00:14:30,860
above the the pink section right and

261
00:14:28,790 --> 00:14:36,830
similarly the really big chunks of

262
00:14:30,860 --> 00:14:44,030
memory allocated are way up here near

263
00:14:36,830 --> 00:14:45,590
the the stack limit and they and so

264
00:14:44,030 --> 00:14:47,300
they're there and in general what's

265
00:14:45,590 --> 00:14:50,870
happening is if I were to try and

266
00:14:47,300 --> 00:14:53,510
reference a memory address in this empty

267
00:14:50,870 --> 00:14:56,860
range I'd get a segmentation fault it's

268
00:14:53,510 --> 00:14:58,940
a valid address in terms of its bit of

269
00:14:56,860 --> 00:15:01,400
properties but it hasn't actually been

270
00:14:58,940 --> 00:15:04,370
set up and allocated by the memory the

271
00:15:01,400 --> 00:15:07,160
virtual memory allocator so at any given

272
00:15:04,370 --> 00:15:09,740
time the valid addresses are just those

273
00:15:07,160 --> 00:15:12,380
in the lower portion or the upper

274
00:15:09,740 --> 00:15:14,630
portion of his address ranges and the

275
00:15:12,380 --> 00:15:16,700
middle is sort of no-man's land and then

276
00:15:14,630 --> 00:15:20,300
what happens is you keep allocating more

277
00:15:16,700 --> 00:15:22,550
with malloc and it will push the limits

278
00:15:20,300 --> 00:15:27,140
of what's addressable in toward it and

279
00:15:22,550 --> 00:15:30,740
in principle if you ever got too much of

280
00:15:27,140 --> 00:15:33,620
a memory request if these two would hit

281
00:15:30,740 --> 00:15:35,870
each other and if you and melech would

282
00:15:33,620 --> 00:15:40,520
return zero at that point but it's

283
00:15:35,870 --> 00:15:43,090
highly unlikely given that you have 128

284
00:15:40,520 --> 00:15:45,530
terabytes of memory address range here

285
00:15:43,090 --> 00:15:48,650
so that's just and you've probably seen

286
00:15:45,530 --> 00:15:50,630
this when you're running you're looking

287
00:15:48,650 --> 00:15:52,820
at disassembled code with gdb you're

288
00:15:50,630 --> 00:15:55,700
seeing some addresses that are way up

289
00:15:52,820 --> 00:15:58,750
here with the seven and some episodes or

290
00:15:55,700 --> 00:16:01,310
stack addresses and you see these fours

291
00:15:58,750 --> 00:16:03,320
you know a lot of zeros and some fours

292
00:16:01,310 --> 00:16:06,730
those tend to be where the code is going

293
00:16:03,320 --> 00:16:06,730
to question

294
00:16:08,500 --> 00:16:13,250
so why doesn't the heat proceed in one

295
00:16:10,850 --> 00:16:15,800
direction I actually don't know I'll

296
00:16:13,250 --> 00:16:17,660
just observe that it was had a strategy

297
00:16:15,800 --> 00:16:19,190
of putting big things here in small

298
00:16:17,660 --> 00:16:21,050
things here and it probably uses

299
00:16:19,190 --> 00:16:24,430
different slightly different management

300
00:16:21,050 --> 00:16:24,430
strategies for those two

301
00:16:32,629 --> 00:16:37,680
okay so that but I think you'll find

302
00:16:35,819 --> 00:16:39,389
that kind of useful to have some sense

303
00:16:37,680 --> 00:16:41,639
when you're looking at when you're

304
00:16:39,389 --> 00:16:43,560
running gdb it helps to just have some

305
00:16:41,639 --> 00:16:46,759
idea of what's going on when you're

306
00:16:43,560 --> 00:16:49,410
looking at these different addresses

307
00:16:46,759 --> 00:16:53,100
okay now let's talk about buffer

308
00:16:49,410 --> 00:16:55,529
overflow and we'll start this you

309
00:16:53,100 --> 00:16:57,600
remember on the very first class and I

310
00:16:55,529 --> 00:17:00,360
think we might have reviewed this part

311
00:16:57,600 --> 00:17:03,029
way along we showed this example of some

312
00:17:00,360 --> 00:17:07,679
programs where if you do an

313
00:17:03,029 --> 00:17:09,780
out-of-bounds reference and write a

314
00:17:07,679 --> 00:17:14,130
value that's out of bounds in particular

315
00:17:09,780 --> 00:17:16,980
I only have a array of two elements here

316
00:17:14,130 --> 00:17:20,130
but this function will take an arbitrary

317
00:17:16,980 --> 00:17:24,630
value of I and assign some magic number

318
00:17:20,130 --> 00:17:29,549
to omotte i of the array and it has the

319
00:17:24,630 --> 00:17:33,289
possibility of and we saw that when you

320
00:17:29,549 --> 00:17:38,220
do that if I get too big it will first

321
00:17:33,289 --> 00:17:40,289
corrupt the double that stored as part

322
00:17:38,220 --> 00:17:44,010
of the struct and then when it gets

323
00:17:40,289 --> 00:17:46,110
bigger it seems to not have any effect

324
00:17:44,010 --> 00:17:48,809
until it gets too big and then you start

325
00:17:46,110 --> 00:17:52,110
corrupting memory so the basic point is

326
00:17:48,809 --> 00:17:55,500
that it's very easy in a program of C

327
00:17:52,110 --> 00:17:58,230
program in particular to a reference

328
00:17:55,500 --> 00:18:05,120
memory that's not part of the sort of

329
00:17:58,230 --> 00:18:07,650
intent of the program and this can

330
00:18:05,120 --> 00:18:12,090
happen in programs that aren't properly

331
00:18:07,650 --> 00:18:14,250
written that and it becomes a security

332
00:18:12,090 --> 00:18:20,340
vulnerability if there's some way for an

333
00:18:14,250 --> 00:18:21,720
outsider to overflow a buffer for

334
00:18:20,340 --> 00:18:24,240
example if there is some way for an

335
00:18:21,720 --> 00:18:27,000
outsider to give a larger value of I and

336
00:18:24,240 --> 00:18:29,760
ask that that value be stored there it

337
00:18:27,000 --> 00:18:31,380
could crash the program and so in

338
00:18:29,760 --> 00:18:33,270
general when you write in code you try

339
00:18:31,380 --> 00:18:36,450
to think about you know can I trust this

340
00:18:33,270 --> 00:18:38,549
value is this a value that's been

341
00:18:36,450 --> 00:18:40,980
computed by my program and I'm sure that

342
00:18:38,549 --> 00:18:41,490
it's within bounds or is it something

343
00:18:40,980 --> 00:18:43,409
that

344
00:18:41,490 --> 00:18:47,100
so come from an external source and

345
00:18:43,409 --> 00:18:50,610
there's potentially at risk of being a

346
00:18:47,100 --> 00:18:53,010
vulnerability so and so in particular

347
00:18:50,610 --> 00:18:56,490
there's a lot a huge class of errors

348
00:18:53,010 --> 00:19:00,240
that have to do with overflowing buffers

349
00:18:56,490 --> 00:19:03,090
where where they're trying to store a

350
00:19:00,240 --> 00:19:08,220
string of some type that's been read

351
00:19:03,090 --> 00:19:10,620
from a message and without knowing in

352
00:19:08,220 --> 00:19:13,380
advance how big that string is it's

353
00:19:10,620 --> 00:19:15,929
possible that it will be too big for the

354
00:19:13,380 --> 00:19:17,580
buffer that's been allocated and so one

355
00:19:15,929 --> 00:19:23,779
of the culprits is there's a whole class

356
00:19:17,580 --> 00:19:26,370
of of library functions that let you

357
00:19:23,779 --> 00:19:29,070
store something a string somewhere

358
00:19:26,370 --> 00:19:33,270
without any kind of bounds checking even

359
00:19:29,070 --> 00:19:35,909
being possible so the sort of worst one

360
00:19:33,270 --> 00:19:38,279
is one called get F and the purpose of

361
00:19:35,909 --> 00:19:43,169
get S is normally it's used to read a

362
00:19:38,279 --> 00:19:44,730
string from an input from a terminal

363
00:19:43,169 --> 00:19:47,130
input something that somebody's typed

364
00:19:44,730 --> 00:19:50,100
into a terminal and so what it's doing

365
00:19:47,130 --> 00:19:52,950
is it's scanning this input string and

366
00:19:50,100 --> 00:19:56,299
looking for a character that represents

367
00:19:52,950 --> 00:20:00,000
the end of the line which we write in of

368
00:19:56,299 --> 00:20:05,610
CEA's is backslash n and it has the

369
00:20:00,000 --> 00:20:08,580
character code in hex of zero a and so

370
00:20:05,610 --> 00:20:10,409
get F this is sort of an approximate

371
00:20:08,580 --> 00:20:13,830
version of what the code forgetteth

372
00:20:10,409 --> 00:20:15,539
looks like that and it as an argument

373
00:20:13,830 --> 00:20:18,330
it's just given a destination of where

374
00:20:15,539 --> 00:20:21,419
to store the result and all it does is

375
00:20:18,330 --> 00:20:24,059
it reads one character at a time looks

376
00:20:21,419 --> 00:20:27,559
for an into file meaning that the input

377
00:20:24,059 --> 00:20:30,090
stream is closed or an end-of-line

378
00:20:27,559 --> 00:20:33,600
but as long as it until it sees that it

379
00:20:30,090 --> 00:20:40,610
just keeps adding more things to the end

380
00:20:33,600 --> 00:20:40,610
of this buffer and so typically

381
00:20:43,139 --> 00:20:49,690
when somebody calls get us they'll pass

382
00:20:46,179 --> 00:20:53,169
it a pointer to some buffer that they've

383
00:20:49,690 --> 00:20:55,480
allocated but the function and it will

384
00:20:53,169 --> 00:20:58,240
just get us we'll just fill that buffer

385
00:20:55,480 --> 00:21:00,490
up but it can potentially just keep

386
00:20:58,240 --> 00:21:02,529
going there is nothing in the function

387
00:21:00,490 --> 00:21:06,730
there's not even an argument to the

388
00:21:02,529 --> 00:21:09,159
function that tells the function when

389
00:21:06,730 --> 00:21:11,649
when it has to stop when it's reached

390
00:21:09,159 --> 00:21:14,289
the limit of it so it was written that

391
00:21:11,649 --> 00:21:16,240
actually get at is if you try to compile

392
00:21:14,289 --> 00:21:18,369
code would get us it will flash up a big

393
00:21:16,240 --> 00:21:20,080
warning that says this is really an

394
00:21:18,369 --> 00:21:24,639
unsafe function you probably shouldn't

395
00:21:20,080 --> 00:21:28,840
even be using it because it it has it

396
00:21:24,639 --> 00:21:31,059
was written in an era in the 1970s when

397
00:21:28,840 --> 00:21:33,009
the early UNIX distributions were coming

398
00:21:31,059 --> 00:21:35,769
out where people just weren't worried

399
00:21:33,009 --> 00:21:39,909
about security vulnerabilities and they

400
00:21:35,769 --> 00:21:43,419
just assumed that if you allocated a big

401
00:21:39,909 --> 00:21:45,490
enough buffer that there's no reason why

402
00:21:43,419 --> 00:21:50,139
a string should be bigger than what

403
00:21:45,490 --> 00:21:52,799
you've allocated and that's actually

404
00:21:50,139 --> 00:21:58,749
true with other functions like stir copy

405
00:21:52,799 --> 00:22:03,090
you recall stir copy has two arguments

406
00:21:58,749 --> 00:22:06,220
excuse me a destination and a source and

407
00:22:03,090 --> 00:22:09,460
its purpose is to copy the string at the

408
00:22:06,220 --> 00:22:11,139
source into the destination and the way

409
00:22:09,460 --> 00:22:12,429
it determines the end of the string and

410
00:22:11,139 --> 00:22:15,519
the source is when it hits a null

411
00:22:12,429 --> 00:22:18,820
character that just keeps copying one by

412
00:22:15,519 --> 00:22:20,679
one wall until it hits it but it has no

413
00:22:18,820 --> 00:22:23,049
way of knowing there's nothing no

414
00:22:20,679 --> 00:22:26,379
information there about how much how big

415
00:22:23,049 --> 00:22:29,110
is the buffer allocated at the

416
00:22:26,379 --> 00:22:31,929
destination and so it can easily overrun

417
00:22:29,110 --> 00:22:34,210
that a similar one called stir cat which

418
00:22:31,929 --> 00:22:38,350
is used to concatenate two strings and

419
00:22:34,210 --> 00:22:43,240
copy them to another destination and the

420
00:22:38,350 --> 00:22:44,980
scanf function of also have possible in

421
00:22:43,240 --> 00:22:48,669
the format string you can give the

422
00:22:44,980 --> 00:22:51,940
percent F directive to the format string

423
00:22:48,669 --> 00:22:53,130
which says read in a string and store it

424
00:22:51,940 --> 00:22:55,590
someplace

425
00:22:53,130 --> 00:22:57,659
and it doesn't say how long the string

426
00:22:55,590 --> 00:22:59,789
is limited to be and it doesn't say how

427
00:22:57,659 --> 00:23:02,220
much memory is available at the

428
00:22:59,789 --> 00:23:06,299
destination so again it can easily just

429
00:23:02,220 --> 00:23:08,909
write over that a buffer so these are

430
00:23:06,299 --> 00:23:11,700
real vulnerabilities and we will talk in

431
00:23:08,909 --> 00:23:14,070
a minute a little later about how you as

432
00:23:11,700 --> 00:23:17,539
a programmer can be a little smarter

433
00:23:14,070 --> 00:23:20,659
than this but in their suit of raw form

434
00:23:17,539 --> 00:23:24,360
as presented they have this

435
00:23:20,659 --> 00:23:28,529
vulnerability to them so let's look at

436
00:23:24,360 --> 00:23:31,259
an example of what this can what can

437
00:23:28,529 --> 00:23:35,070
happen there so imagine for example we

438
00:23:31,259 --> 00:23:36,929
want a to implement echo function so an

439
00:23:35,070 --> 00:23:39,690
echo function is one that you just type

440
00:23:36,929 --> 00:23:42,059
something in and it prints it back out

441
00:23:39,690 --> 00:23:43,669
it's very uninteresting function except

442
00:23:42,059 --> 00:23:47,070
it's very useful to demonstrate things

443
00:23:43,669 --> 00:23:49,110
so the idea is it has this little buffer

444
00:23:47,070 --> 00:23:53,070
it's only enough to hold four characters

445
00:23:49,110 --> 00:23:56,220
it caused geta to read a string from the

446
00:23:53,070 --> 00:24:01,850
input and then it calls put s which

447
00:23:56,220 --> 00:24:01,850
simply writes back out the output and

448
00:24:08,790 --> 00:24:15,800
and so let me just download this not

449
00:24:12,450 --> 00:24:15,800
very interesting function

450
00:24:20,310 --> 00:24:29,110
so I call it here buff demo - NST mean

451
00:24:26,890 --> 00:24:31,510
it has no stack protector and we'll see

452
00:24:29,110 --> 00:24:33,730
in a minute what its deck protectors but

453
00:24:31,510 --> 00:24:45,730
you see if you type a reasonably smoke

454
00:24:33,730 --> 00:24:48,790
strong small string very rare it can

455
00:24:45,730 --> 00:24:50,500
handle more than four actually as

456
00:24:48,790 --> 00:24:52,330
written it can't handle more than three

457
00:24:50,500 --> 00:25:02,590
right because there should be room for

458
00:24:52,330 --> 00:25:04,600
the null character - on terminator so it

459
00:25:02,590 --> 00:25:10,240
turns out with this particular one if I

460
00:25:04,600 --> 00:25:12,630
type in a string of 24 characters it'll

461
00:25:10,240 --> 00:25:12,630
be okay

462
00:25:21,400 --> 00:25:28,550
but if I type in a string of 24

463
00:25:24,020 --> 00:25:30,760
characters it will hit a segmentation

464
00:25:28,550 --> 00:25:30,760
fault

465
00:25:32,300 --> 00:25:37,520
so where do those numbers 23 and 24 come

466
00:25:35,690 --> 00:25:40,690
in well that's something we can learn by

467
00:25:37,520 --> 00:25:40,690
looking at the assembly code

468
00:25:55,720 --> 00:26:03,500
so here's and we'll go through the code

469
00:25:59,140 --> 00:26:07,580
so first of all this is the code for

470
00:26:03,500 --> 00:26:13,970
echo then and you see the echo calls get

471
00:26:07,580 --> 00:26:16,280
s and it calls put it and here's the

472
00:26:13,970 --> 00:26:19,430
part of the code where you can tell how

473
00:26:16,280 --> 00:26:36,760
much memory got allocated for the buffer

474
00:26:19,430 --> 00:26:36,760
and x18 is what in decimal X 24 right

475
00:26:37,300 --> 00:26:45,470
and you just saw that the thing actually

476
00:26:41,030 --> 00:26:46,960
seg faults with a input string of 24 so

477
00:26:45,470 --> 00:26:50,120
we'll see that in a minute

478
00:26:46,960 --> 00:26:54,680
but anyways you can see here that it's

479
00:26:50,120 --> 00:27:01,640
allocating on the stack a region of 24

480
00:26:54,680 --> 00:27:03,170
bytes and it's copying that into RDI

481
00:27:01,640 --> 00:27:05,570
which is of course the argument

482
00:27:03,170 --> 00:27:11,380
forgetteth so get us is being called

483
00:27:05,570 --> 00:27:14,240
with a pointer to a buffer of size 24

484
00:27:11,380 --> 00:27:16,630
maximum 24 even though you saw the

485
00:27:14,240 --> 00:27:24,710
original declaration was just four for

486
00:27:16,630 --> 00:27:27,920
all and then it calls get s and then get

487
00:27:24,710 --> 00:27:32,270
us does it thing in just one last little

488
00:27:27,920 --> 00:27:39,170
bit to keep in mind is we'll get back to

489
00:27:32,270 --> 00:27:40,880
them oh yes and remember echo that

490
00:27:39,170 --> 00:27:42,910
there's a function called call echo

491
00:27:40,880 --> 00:27:46,130
which is the thing that calls echo and

492
00:27:42,910 --> 00:27:50,480
just to keep in mind this read is the

493
00:27:46,130 --> 00:27:53,530
return address for call echo and that's

494
00:27:50,480 --> 00:27:53,530
going to be important

495
00:27:55,080 --> 00:28:04,630
so what we see then is the memory layout

496
00:27:58,330 --> 00:28:07,720
is the buff is normally big enough for

497
00:28:04,630 --> 00:28:10,450
four characters there's a sort of 20

498
00:28:07,720 --> 00:28:12,880
bytes of unused or wasted space here and

499
00:28:10,450 --> 00:28:15,670
then the actual return address which is

500
00:28:12,880 --> 00:28:24,100
the return address for back to call echo

501
00:28:15,670 --> 00:28:27,309
is stored on the stack so when this

502
00:28:24,100 --> 00:28:29,770
program int begins running when echo

503
00:28:27,309 --> 00:28:33,550
starts to run we'll find that this is

504
00:28:29,770 --> 00:28:40,240
the value on the stack for the return

505
00:28:33,550 --> 00:28:44,559
pointer and if we type in a string of up

506
00:28:40,240 --> 00:28:47,260
here of 23 characters you'll see that it

507
00:28:44,559 --> 00:28:51,460
uses up this entire buffer and remember

508
00:28:47,260 --> 00:28:54,220
a string is terminated with a 0 0 but it

509
00:28:51,460 --> 00:28:56,350
still hasn't it's still within the

510
00:28:54,220 --> 00:29:00,220
region that was allocated on the stack

511
00:28:56,350 --> 00:29:04,690
for that so it just barely fits into the

512
00:29:00,220 --> 00:29:06,610
the stack and that's why we technically

513
00:29:04,690 --> 00:29:08,530
we overflowed the buffer but we didn't

514
00:29:06,610 --> 00:29:11,679
really cause any harm because there was

515
00:29:08,530 --> 00:29:14,320
this extra space available and so that's

516
00:29:11,679 --> 00:29:18,940
why I could type in that string of 23

517
00:29:14,320 --> 00:29:22,900
characters and and it worked fine but

518
00:29:18,940 --> 00:29:25,559
now if I type in this is an example

519
00:29:22,900 --> 00:29:25,559
showing

520
00:29:28,150 --> 00:29:39,040
I actually 25 characters so once I go

521
00:29:34,810 --> 00:29:40,600
beyond the 23 characters plus the null

522
00:29:39,040 --> 00:29:46,300
character you'll see what I'm slowly

523
00:29:40,600 --> 00:29:49,060
starting to do is is corrupt the the the

524
00:29:46,300 --> 00:29:51,670
byte representation of the return

525
00:29:49,060 --> 00:29:54,490
address and so what happens for example

526
00:29:51,670 --> 00:29:58,750
here is that rather than trying to

527
00:29:54,490 --> 00:30:00,040
return back to the where call echo was

528
00:29:58,750 --> 00:30:02,680
supposed to where it was supposed to go

529
00:30:00,040 --> 00:30:06,070
back to it goes back to some other part

530
00:30:02,680 --> 00:30:08,950
of your code that may or may not be a

531
00:30:06,070 --> 00:30:10,510
valid address or might not have anything

532
00:30:08,950 --> 00:30:14,530
to do with the program you're trying to

533
00:30:10,510 --> 00:30:17,670
run so this example shows it and if I

534
00:30:14,530 --> 00:30:17,670
typed in the 24

535
00:30:21,200 --> 00:30:28,260
let's see before I got it to run like

536
00:30:26,100 --> 00:30:32,190
this you know this thing depends on the

537
00:30:28,260 --> 00:30:41,730
what happens how the code happens to get

538
00:30:32,190 --> 00:30:45,810
compiled oh yeah so okay so actually you

539
00:30:41,730 --> 00:30:48,150
see here this first string I typed is

540
00:30:45,810 --> 00:30:52,050
actually 24 characters long plus the

541
00:30:48,150 --> 00:30:54,630
null pointer so and we'll see why it

542
00:30:52,050 --> 00:30:56,880
didn't it should have crashed because we

543
00:30:54,630 --> 00:31:00,330
actually over I wrote the low order byte

544
00:30:56,880 --> 00:31:02,640
of the return address here we typed in

545
00:31:00,330 --> 00:31:03,960
this is 25 characters and so that's the

546
00:31:02,640 --> 00:31:06,780
one I just showed where it really

547
00:31:03,960 --> 00:31:09,480
whacked the two bytes of the return

548
00:31:06,780 --> 00:31:12,210
address so here we actually did overflow

549
00:31:09,480 --> 00:31:16,290
the buffer and let's try and figure out

550
00:31:12,210 --> 00:31:23,250
why that didn't harm the the program

551
00:31:16,290 --> 00:31:24,510
execution I see a question yes it could

552
00:31:23,250 --> 00:31:27,150
have been various other things could

553
00:31:24,510 --> 00:31:29,130
have there's nothing it hit a

554
00:31:27,150 --> 00:31:30,720
segmentation fault because it probably

555
00:31:29,130 --> 00:31:32,520
went to some weird part of the code and

556
00:31:30,720 --> 00:31:35,580
just started executing some random stuff

557
00:31:32,520 --> 00:31:38,040
and it just got itself into trouble but

558
00:31:35,580 --> 00:31:39,990
that's the point is it's not predictable

559
00:31:38,040 --> 00:31:42,200
exactly what will happen when you do

560
00:31:39,990 --> 00:31:42,200
this

561
00:31:51,760 --> 00:31:56,470
so this is that the example of what

562
00:31:54,430 --> 00:31:59,290
actually happened the first time when I

563
00:31:56,470 --> 00:32:01,720
typed in a string that had 24 characters

564
00:31:59,290 --> 00:32:05,040
and so this null byte at the end

565
00:32:01,720 --> 00:32:08,890
actually corrupted the return address

566
00:32:05,040 --> 00:32:13,570
and so it was supposed to return back to

567
00:32:08,890 --> 00:32:18,010
this address 400 6f6 and instead it will

568
00:32:13,570 --> 00:32:19,930
return back to the address 400 600 which

569
00:32:18,010 --> 00:32:22,360
happens to be in some other weird

570
00:32:19,930 --> 00:32:26,470
function that's there and it just sort

571
00:32:22,360 --> 00:32:29,530
of landed at some place here and it's

572
00:32:26,470 --> 00:32:32,680
doing various things but somehow it

573
00:32:29,530 --> 00:32:34,330
didn't really didn't crash the program

574
00:32:32,680 --> 00:32:37,180
and that's one of the frustrating things

575
00:32:34,330 --> 00:32:41,050
about this is that things can go wrong

576
00:32:37,180 --> 00:32:43,390
in a program and they don't always cause

577
00:32:41,050 --> 00:32:45,340
a crash and so often a bug that's

578
00:32:43,390 --> 00:32:51,310
working there might be doing some weird

579
00:32:45,340 --> 00:32:54,510
stuff that you don't even know about so

580
00:32:51,310 --> 00:32:58,330
that's all a fine if it's just a way of

581
00:32:54,510 --> 00:32:59,890
crashing programs and I mean that's not

582
00:32:58,330 --> 00:33:03,910
great if it's controlling your pacemaker

583
00:32:59,890 --> 00:33:06,040
or something like that but if it's just

584
00:33:03,910 --> 00:33:11,920
a homework assignment it's like not a

585
00:33:06,040 --> 00:33:15,660
big deal so uh but what actually and

586
00:33:11,920 --> 00:33:19,600
this is sort of only happened since

587
00:33:15,660 --> 00:33:22,900
attacking became a normal activity which

588
00:33:19,600 --> 00:33:25,300
has only been the last 30 years is that

589
00:33:22,900 --> 00:33:29,970
it gives an opportunity for a hacker or

590
00:33:25,300 --> 00:33:33,100
a attacker to inject code into the

591
00:33:29,970 --> 00:33:36,460
program and execute it and that's what's

592
00:33:33,100 --> 00:33:39,370
called a code injection attack and so

593
00:33:36,460 --> 00:33:41,530
the the general scheme of it is I have

594
00:33:39,370 --> 00:33:44,230
this buffer that I can fill up with

595
00:33:41,530 --> 00:33:46,450
whatever bytes I want by feeding them to

596
00:33:44,230 --> 00:33:49,420
get s or whatever function is doing this

597
00:33:46,450 --> 00:33:52,990
copying and what I can do then is set up

598
00:33:49,420 --> 00:33:56,110
and pass to it some bytes of actually

599
00:33:52,990 --> 00:33:58,420
that encode an executable a little bit

600
00:33:56,110 --> 00:34:00,850
of executable code you've seen an object

601
00:33:58,420 --> 00:34:03,280
dump it's printing out these bytecode

602
00:34:00,850 --> 00:34:05,830
representations of instructions so

603
00:34:03,280 --> 00:34:10,210
imagine you said some of those byte

604
00:34:05,830 --> 00:34:14,080
into your string you encoded them in the

605
00:34:10,210 --> 00:34:18,450
string that you pass to get us and then

606
00:34:14,080 --> 00:34:21,340
you might have to add some more sort of

607
00:34:18,450 --> 00:34:23,590
padding characters that characters whose

608
00:34:21,340 --> 00:34:27,399
value doesn't matter in order to then

609
00:34:23,590 --> 00:34:29,530
get a number back into the position

610
00:34:27,399 --> 00:34:32,500
where the return pointer is supposed to

611
00:34:29,530 --> 00:34:34,750
be and so what's call that number B it's

612
00:34:32,500 --> 00:34:37,659
going to be an address one of these ones

613
00:34:34,750 --> 00:34:41,560
with the you know that represents a

614
00:34:37,659 --> 00:34:44,740
stack location and that value B then is

615
00:34:41,560 --> 00:34:47,440
the starting address of the buffer which

616
00:34:44,740 --> 00:34:49,510
happens to be where your exploit code

617
00:34:47,440 --> 00:34:53,889
remember this is just executable

618
00:34:49,510 --> 00:34:55,800
instructions of were stored here so now

619
00:34:53,889 --> 00:35:02,380
what will happen is when the program

620
00:34:55,800 --> 00:35:04,990
does its return here it was supposed to

621
00:35:02,380 --> 00:35:07,619
return back to wherever it got called

622
00:35:04,990 --> 00:35:07,619
from P

623
00:35:10,710 --> 00:35:23,910
this is a typo P calls Q not far so it's

624
00:35:18,480 --> 00:35:25,740
supposed to return back to P and we're

625
00:35:23,910 --> 00:35:26,520
and the address the return address was

626
00:35:25,740 --> 00:35:28,560
stored here

627
00:35:26,520 --> 00:35:31,710
but now I've overwritten that return

628
00:35:28,560 --> 00:35:35,130
address with this buffer position so

629
00:35:31,710 --> 00:35:37,109
what will happen is the the program

630
00:35:35,130 --> 00:35:39,660
counter will happily jump to this spot

631
00:35:37,109 --> 00:35:41,880
and see start executing whatever it

632
00:35:39,660 --> 00:35:44,880
encounters which are the instructions

633
00:35:41,880 --> 00:35:48,690
that you've inserted and by that means

634
00:35:44,880 --> 00:35:51,420
then you can inject code into a machine

635
00:35:48,690 --> 00:35:53,430
potentially somewhere up in the Internet

636
00:35:51,420 --> 00:35:57,390
if you could set up a scheme like this

637
00:35:53,430 --> 00:35:59,609
that would feed these bytes into that

638
00:35:57,390 --> 00:36:02,010
machine and it would read it in with a

639
00:35:59,609 --> 00:36:04,050
function like get us and then it would

640
00:36:02,010 --> 00:36:06,839
try to do its return but it would start

641
00:36:04,050 --> 00:36:09,660
executing your code so that's the

642
00:36:06,839 --> 00:36:11,910
classic code injection attack and in

643
00:36:09,660 --> 00:36:14,700
fact in this lab that you're going to

644
00:36:11,910 --> 00:36:17,880
start it comes out at midnight called

645
00:36:14,700 --> 00:36:24,599
the attack lab because you're going to

646
00:36:17,880 --> 00:36:25,980
do this yourself for part of the lab and

647
00:36:24,599 --> 00:36:33,300
I think you'll find it pretty

648
00:36:25,980 --> 00:36:38,790
interesting so this used to be a huge

649
00:36:33,300 --> 00:36:42,359
problem on programs yet so when you're

650
00:36:38,790 --> 00:36:45,210
trying to replace read I make sure that

651
00:36:42,359 --> 00:36:47,700
your new submitted read overrides that

652
00:36:45,210 --> 00:36:50,130
exactly well that's part of the cover

653
00:36:47,700 --> 00:36:51,450
nets of being a hacker you have to make

654
00:36:50,130 --> 00:36:53,760
sure it's in the right spot

655
00:36:51,450 --> 00:36:56,910
but it's actually one of the easier

656
00:36:53,760 --> 00:37:01,500
parts because for example we do know you

657
00:36:56,910 --> 00:37:04,589
have to know the binary code to be able

658
00:37:01,500 --> 00:37:06,330
to do this or be able to guess so for

659
00:37:04,589 --> 00:37:08,580
example in that previous one I could

660
00:37:06,330 --> 00:37:11,400
tell that it was allocating 24 bytes for

661
00:37:08,580 --> 00:37:13,349
that buffer and so if I just made sure

662
00:37:11,400 --> 00:37:17,430
that the length of my exploit code plus

663
00:37:13,349 --> 00:37:18,990
the padding is 24 bytes then right after

664
00:37:17,430 --> 00:37:20,640
that comes to the return address so

665
00:37:18,990 --> 00:37:21,070
that's actually pretty easy to do there

666
00:37:20,640 --> 00:37:22,930
was

667
00:37:21,070 --> 00:37:25,630
certainly how much memory programs uh no

668
00:37:22,930 --> 00:37:31,660
you have to have access you have to what

669
00:37:25,630 --> 00:37:33,250
the reason why this works is it works if

670
00:37:31,660 --> 00:37:35,050
you have enough knowledge about the

671
00:37:33,250 --> 00:37:37,210
operating system that's running at the

672
00:37:35,050 --> 00:37:40,420
other end for example you know it's

673
00:37:37,210 --> 00:37:43,900
Linux you know that you can look at

674
00:37:40,420 --> 00:37:45,790
either what GCC tends to allocate for it

675
00:37:43,900 --> 00:37:51,840
you somehow have access to information

676
00:37:45,790 --> 00:37:51,840
about the code itself lets you do this

677
00:37:55,840 --> 00:38:00,890
so anyways this used to be a huge

678
00:37:58,160 --> 00:38:04,190
problem and it started way back in 1988

679
00:38:00,890 --> 00:38:08,480
the first internet attack was called the

680
00:38:04,190 --> 00:38:11,240
Morris worm and it at the time the

681
00:38:08,480 --> 00:38:12,740
internet was not a very big place and it

682
00:38:11,240 --> 00:38:15,320
basically brought down a huge fraction

683
00:38:12,740 --> 00:38:16,720
of the machines that were on the

684
00:38:15,320 --> 00:38:20,720
internet at the time

685
00:38:16,720 --> 00:38:22,370
interestingly enough CMU did not fall

686
00:38:20,720 --> 00:38:25,730
victim to this attack because we'd

687
00:38:22,370 --> 00:38:32,420
patched already the vulnerabilities that

688
00:38:25,730 --> 00:38:34,370
this particular program exploited and

689
00:38:32,420 --> 00:38:35,840
that was the cause that the software

690
00:38:34,370 --> 00:38:38,210
engineering Institute runs an

691
00:38:35,840 --> 00:38:41,000
organization called cert the computer

692
00:38:38,210 --> 00:38:45,200
emergency response team and that team

693
00:38:41,000 --> 00:38:50,330
was set up in response to this attack

694
00:38:45,200 --> 00:38:52,760
the Morris worm attack will also see an

695
00:38:50,330 --> 00:38:55,880
interesting example between two

696
00:38:52,760 --> 00:38:59,290
companies in in messaging services and

697
00:38:55,880 --> 00:39:02,270
many others it's been the sort of

698
00:38:59,290 --> 00:39:04,820
standard attack mechanism for many years

699
00:39:02,270 --> 00:39:07,550
and fortunately nowadays there's a few

700
00:39:04,820 --> 00:39:10,340
things that make the attacking of less

701
00:39:07,550 --> 00:39:12,560
likely to be successful and so it's not

702
00:39:10,340 --> 00:39:14,090
as huge a problem as it used to be but

703
00:39:12,560 --> 00:39:20,660
still it's a source of many

704
00:39:14,090 --> 00:39:22,850
vulnerabilities in programs so let's see

705
00:39:20,660 --> 00:39:23,660
I won't talk too much about this but it

706
00:39:22,850 --> 00:39:25,870
used to be

707
00:39:23,660 --> 00:39:29,570
in the original implementation of

708
00:39:25,870 --> 00:39:31,640
there's a command that most systems have

709
00:39:29,570 --> 00:39:33,610
now disabled that you could finger you

710
00:39:31,640 --> 00:39:36,350
could across the information about

711
00:39:33,610 --> 00:39:38,060
somebody in some remote location it

712
00:39:36,350 --> 00:39:42,320
would send a message to that location

713
00:39:38,060 --> 00:39:44,750
and then it would reply back and it used

714
00:39:42,320 --> 00:39:47,780
get assets on the actual original

715
00:39:44,750 --> 00:39:50,840
implementation called get s to read the

716
00:39:47,780 --> 00:39:53,050
input string from that was being sent to

717
00:39:50,840 --> 00:39:53,050
it

718
00:39:55,150 --> 00:40:00,190
and then there is an interesting one you

719
00:39:57,999 --> 00:40:04,329
guys don't remember messaging instant

720
00:40:00,190 --> 00:40:06,069
messaging but before it used to be that

721
00:40:04,329 --> 00:40:09,160
people would talk to each other on their

722
00:40:06,069 --> 00:40:12,279
computers by sending messages sort of

723
00:40:09,160 --> 00:40:15,390
like you send text messages today but

724
00:40:12,279 --> 00:40:19,799
there is an interesting thing that

725
00:40:15,390 --> 00:40:22,599
there's a company still exist but it's a

726
00:40:19,799 --> 00:40:25,359
shadow of its former self called AOL

727
00:40:22,599 --> 00:40:27,249
which ran the most popular Internet

728
00:40:25,359 --> 00:40:29,950
services and had the most popular

729
00:40:27,249 --> 00:40:32,920
instant messaging program and Microsoft

730
00:40:29,950 --> 00:40:34,299
came out with its own client its own

731
00:40:32,920 --> 00:40:36,999
program that you could run on your

732
00:40:34,299 --> 00:40:40,180
machine and communicate to other people

733
00:40:36,999 --> 00:40:41,650
on this messaging system so the

734
00:40:40,180 --> 00:40:44,920
Microsoft code was running on your

735
00:40:41,650 --> 00:40:47,859
machine but it would use the servers

736
00:40:44,920 --> 00:40:53,710
that were being run by AOL to manage

737
00:40:47,859 --> 00:40:59,859
this messaging traffic and the funny

738
00:40:53,710 --> 00:41:03,009
story was over that the this Microsoft

739
00:40:59,859 --> 00:41:05,170
program would work fine you can

740
00:41:03,009 --> 00:41:07,359
communicate with your friends who had

741
00:41:05,170 --> 00:41:09,729
different messaging clients and it all

742
00:41:07,359 --> 00:41:11,289
seemed compatible but then suddenly the

743
00:41:09,729 --> 00:41:13,690
people that were running the Microsoft

744
00:41:11,289 --> 00:41:15,940
version of the software it wouldn't work

745
00:41:13,690 --> 00:41:18,609
and then Microsoft people figured out

746
00:41:15,940 --> 00:41:19,749
how to patch it and then it would work

747
00:41:18,609 --> 00:41:22,269
for a while and then it wouldn't work

748
00:41:19,749 --> 00:41:25,450
and the way what was happening was a o/l

749
00:41:22,269 --> 00:41:29,469
was using a bug in its own code to be

750
00:41:25,450 --> 00:41:33,279
able to determine who's basically peek

751
00:41:29,469 --> 00:41:37,329
into the the machines on the client side

752
00:41:33,279 --> 00:41:39,039
and do a buffer overflow attack on your

753
00:41:37,329 --> 00:41:41,469
code that were you running on your

754
00:41:39,039 --> 00:41:44,680
machine and then basically peek around

755
00:41:41,469 --> 00:41:46,269
and see does this look like AOL coders

756
00:41:44,680 --> 00:41:49,150
it's something or is it some foreign

757
00:41:46,269 --> 00:41:53,529
code and so is basically able to use its

758
00:41:49,150 --> 00:41:57,759
own security weakness to figure out this

759
00:41:53,529 --> 00:42:04,329
information and that got disclosed by a

760
00:41:57,759 --> 00:42:07,930
sort of funny message from somebody who

761
00:42:04,329 --> 00:42:08,859
called himself filled buckin and it was

762
00:42:07,930 --> 00:42:11,170
determined that

763
00:42:08,859 --> 00:42:17,470
this email originated from somewhere

764
00:42:11,170 --> 00:42:19,029
within Microsoft so anyways that the and

765
00:42:17,470 --> 00:42:21,880
you can read more about it in the book

766
00:42:19,029 --> 00:42:23,710
around the slide so fun stories so in

767
00:42:21,880 --> 00:42:25,509
general in the security world you're

768
00:42:23,710 --> 00:42:27,160
supposed to distinguish between the idea

769
00:42:25,509 --> 00:42:28,509
of a worm and a virus although people

770
00:42:27,160 --> 00:42:31,660
aren't very good at doing that

771
00:42:28,509 --> 00:42:34,029
so worm is a program that can run on its

772
00:42:31,660 --> 00:42:36,940
own and propagate itself from one place

773
00:42:34,029 --> 00:42:39,910
to the other replicated a virus is like

774
00:42:36,940 --> 00:42:42,609
a biological virus it doesn't live on

775
00:42:39,910 --> 00:42:44,829
its own it works by attacking a program

776
00:42:42,609 --> 00:42:53,440
and basically modifying that program's

777
00:42:44,829 --> 00:42:55,450
behavior so that can see the basic idea

778
00:42:53,440 --> 00:42:57,759
of buffer overflows and you'll see it

779
00:42:55,450 --> 00:43:01,509
more first hand so let's look at

780
00:42:57,759 --> 00:43:03,819
techniques that machines can use to

781
00:43:01,509 --> 00:43:06,819
avoid to make themselves less vulnerable

782
00:43:03,819 --> 00:43:10,119
to these attacks well first of all you

783
00:43:06,819 --> 00:43:12,549
the application or the writer on the

784
00:43:10,119 --> 00:43:16,150
server side can write code that's more

785
00:43:12,549 --> 00:43:18,999
secure so for example what you're

786
00:43:16,150 --> 00:43:21,759
supposed to do instead of get ass as use

787
00:43:18,999 --> 00:43:25,029
a function called F get us an F getta

788
00:43:21,759 --> 00:43:27,880
has the property that it passes a

789
00:43:25,029 --> 00:43:31,299
parameter which is the maximum number of

790
00:43:27,880 --> 00:43:34,989
bytes that the program should read and

791
00:43:31,299 --> 00:43:38,559
it's there's more bytes than that in the

792
00:43:34,989 --> 00:43:41,680
input it will just truncate the input so

793
00:43:38,559 --> 00:43:45,339
on you're really supposed to use F get

794
00:43:41,680 --> 00:43:47,230
us and give a limit similarly stur copy

795
00:43:45,339 --> 00:43:50,289
there is a version of it called stern

796
00:43:47,230 --> 00:43:53,470
copy where you can give a limit and with

797
00:43:50,289 --> 00:43:55,779
a scanf you're supposed to be careful

798
00:43:53,470 --> 00:43:57,910
about using the percent s and there's

799
00:43:55,779 --> 00:44:02,170
even a terminology you can say percent

800
00:43:57,910 --> 00:44:03,730
give a number that the maximum length of

801
00:44:02,170 --> 00:44:05,710
the string it should read so these

802
00:44:03,730 --> 00:44:09,239
various places you can protect your code

803
00:44:05,710 --> 00:44:12,880
to make sure it won't overflow buffers

804
00:44:09,239 --> 00:44:16,390
unfortunately and a lot of code has been

805
00:44:12,880 --> 00:44:18,549
you'd call it hardening it's been people

806
00:44:16,390 --> 00:44:20,470
have gone through it and it's a lot of

807
00:44:18,549 --> 00:44:22,210
work because there's a lot of places in

808
00:44:20,470 --> 00:44:22,880
programs where you're copying strings

809
00:44:22,210 --> 00:44:24,829
from one point

810
00:44:22,880 --> 00:44:26,420
to another and there are a lot of real

811
00:44:24,829 --> 00:44:31,609
subtleties like when you're converting

812
00:44:26,420 --> 00:44:32,990
from Unicode to bytes and so forth that

813
00:44:31,609 --> 00:44:36,140
you're going back and forth between

814
00:44:32,990 --> 00:44:38,569
different character encodings but for

815
00:44:36,140 --> 00:44:40,819
the large part and these tools that the

816
00:44:38,569 --> 00:44:44,269
code developers have created to help

817
00:44:40,819 --> 00:44:46,369
track down these bugs so it's become a

818
00:44:44,269 --> 00:44:48,890
little bit safer out there but there's

819
00:44:46,369 --> 00:44:51,500
still vulnerabilities so then there's

820
00:44:48,890 --> 00:44:54,410
other parts where you just try to build

821
00:44:51,500 --> 00:44:56,809
in safeguards into the system that would

822
00:44:54,410 --> 00:44:59,240
make it much harder to do a buffer

823
00:44:56,809 --> 00:45:01,910
overflow exploit like I showed you and

824
00:44:59,240 --> 00:45:04,579
so one of them is called stack

825
00:45:01,910 --> 00:45:11,920
randomization or it goes by a more

826
00:45:04,579 --> 00:45:18,230
general term that's abbreviated aslr

827
00:45:11,920 --> 00:45:20,440
which stands for address space layout

828
00:45:18,230 --> 00:45:20,440
randomization

829
00:45:24,040 --> 00:45:31,170
and the idea that is to make it so every

830
00:45:27,490 --> 00:45:36,070
time a program run the addresses change

831
00:45:31,170 --> 00:45:38,500
a little bit or a lot so that you can't

832
00:45:36,070 --> 00:45:41,080
reliably know where things are going to

833
00:45:38,500 --> 00:45:44,400
be in the code so imagine for example

834
00:45:41,080 --> 00:45:47,620
the and the way it's implemented is

835
00:45:44,400 --> 00:45:50,320
before in the sort of run-up of your

836
00:45:47,620 --> 00:45:53,770
program when it first starts up but

837
00:45:50,320 --> 00:45:56,380
before your main routine gets called it

838
00:45:53,770 --> 00:45:58,390
will just do allocation on the stack of

839
00:45:56,380 --> 00:46:01,200
some random number of bytes and storage

840
00:45:58,390 --> 00:46:03,940
a fair amount like maybe a megabyte

841
00:46:01,200 --> 00:46:07,030
roughly of storage where the exact

842
00:46:03,940 --> 00:46:10,210
number is randomly chosen and what that

843
00:46:07,030 --> 00:46:13,330
means is that the the dress of the stack

844
00:46:10,210 --> 00:46:16,900
of all the different positions of your

845
00:46:13,330 --> 00:46:19,450
ear all the local storage on the stack

846
00:46:16,900 --> 00:46:24,240
will shift up and down from one run to

847
00:46:19,450 --> 00:46:28,440
another and we can actually see that in

848
00:46:24,240 --> 00:46:28,440
this example I showed

849
00:46:32,839 --> 00:46:39,540
so I have a program here it's not a very

850
00:46:36,420 --> 00:46:42,890
interesting program I'll show you except

851
00:46:39,540 --> 00:46:42,890
to demonstrate these ideas

852
00:46:44,849 --> 00:46:51,160
all it's doing is there's some code it's

853
00:46:48,609 --> 00:46:53,559
based on that one I already showed code

854
00:46:51,160 --> 00:46:58,000
locate but this one there's a global

855
00:46:53,559 --> 00:47:00,160
variable there's some functions there's

856
00:46:58,000 --> 00:47:03,369
something that gets allocated by malloc

857
00:47:00,160 --> 00:47:05,980
and there's something that is a local

858
00:47:03,369 --> 00:47:08,170
variable stored on the stack and so what

859
00:47:05,980 --> 00:47:11,500
I'll do is show addresses that are

860
00:47:08,170 --> 00:47:14,530
chosen the address of this variable then

861
00:47:11,500 --> 00:47:17,589
will be a stack address a local of a

862
00:47:14,530 --> 00:47:20,319
local variable global will be this one

863
00:47:17,589 --> 00:47:23,020
that gets allocated globally the heap is

864
00:47:20,319 --> 00:47:26,440
something allocated with malloc and then

865
00:47:23,020 --> 00:47:31,980
the this function useless will count as

866
00:47:26,440 --> 00:47:31,980
a code address and now when I run it

867
00:47:33,569 --> 00:47:38,500
you'll see from one run to another that

868
00:47:36,490 --> 00:47:41,200
if some of these stay the same and some

869
00:47:38,500 --> 00:47:45,579
of them change so in particular the

870
00:47:41,200 --> 00:47:52,809
global variable is the same 600 102 C

871
00:47:45,579 --> 00:47:56,650
and the code is the same for double O 5

872
00:47:52,809 --> 00:47:59,530
900 is the same every execution but

873
00:47:56,650 --> 00:48:02,790
you'll see this local variable it's on a

874
00:47:59,530 --> 00:48:05,290
stack address but you see that the lower

875
00:48:02,790 --> 00:48:09,339
half dozen or so bikes are actually

876
00:48:05,290 --> 00:48:17,170
changing from one run to another 1 2 3 4

877
00:48:09,339 --> 00:48:21,010
5 so 5 bytes of it but 5 hex digits I'm

878
00:48:17,170 --> 00:48:23,380
sorry so that's 2 to the 20th so roughly

879
00:48:21,010 --> 00:48:26,230
a megabyte of variation is going on in

880
00:48:23,380 --> 00:48:28,780
stack addresses there and similarly

881
00:48:26,230 --> 00:48:32,230
you'll see that the heap addresses are

882
00:48:28,780 --> 00:48:34,420
also varying from one to another from

883
00:48:32,230 --> 00:48:36,880
one execution to the other so malloc has

884
00:48:34,420 --> 00:48:40,720
built into it some amount of randomness

885
00:48:36,880 --> 00:48:44,670
to in its allocation so what why setec

886
00:48:40,720 --> 00:48:47,790
you know what's the purpose of that well

887
00:48:44,670 --> 00:48:52,839
as I told you this code injection

888
00:48:47,790 --> 00:48:55,720
vulnerability relies on the fact that

889
00:48:52,839 --> 00:48:57,380
you can you can load up this buffer with

890
00:48:55,720 --> 00:49:01,550
some executable code

891
00:48:57,380 --> 00:49:04,730
but somehow you have to know how to get

892
00:49:01,550 --> 00:49:07,580
to the start of that code and this is

893
00:49:04,730 --> 00:49:09,500
relying the attack is relying on the

894
00:49:07,580 --> 00:49:15,140
fact that it can somehow predict what

895
00:49:09,500 --> 00:49:16,790
the this address of the buffer is and so

896
00:49:15,140 --> 00:49:19,310
that it can store it in the right part

897
00:49:16,790 --> 00:49:20,810
of the string put it encoded in the

898
00:49:19,310 --> 00:49:22,340
right part of the string so it will show

899
00:49:20,810 --> 00:49:25,640
up where the return pointer is supposed

900
00:49:22,340 --> 00:49:28,310
to be and and have it jumped to that

901
00:49:25,640 --> 00:49:32,900
location but now with this randomization

902
00:49:28,310 --> 00:49:36,140
this number is varying by quite a bit

903
00:49:32,900 --> 00:49:38,420
sort of million over a range of a

904
00:49:36,140 --> 00:49:40,970
million or so values so there's no way

905
00:49:38,420 --> 00:49:43,220
in advance even if I have an exact copy

906
00:49:40,970 --> 00:49:47,330
of the code not even had access to the

907
00:49:43,220 --> 00:49:49,070
system itself and could run it I can't

908
00:49:47,330 --> 00:49:52,220
predict from one run to the next where

909
00:49:49,070 --> 00:49:55,850
it's going to be so that gives it sort

910
00:49:52,220 --> 00:50:01,390
of fort this particular attack to to

911
00:49:55,850 --> 00:50:01,390
make it using this randomization

912
00:50:02,770 --> 00:50:08,930
another idea that fairly straightforward

913
00:50:07,040 --> 00:50:14,510
but it took a long time for the hardware

914
00:50:08,930 --> 00:50:16,160
people to implement this is well why why

915
00:50:14,510 --> 00:50:18,290
is there supposed to be code on the

916
00:50:16,160 --> 00:50:20,420
stack in the first place isn't the code

917
00:50:18,290 --> 00:50:23,780
supposed to be located down in the text

918
00:50:20,420 --> 00:50:27,320
segment where it can be sued especially

919
00:50:23,780 --> 00:50:31,400
identified as being executable so in the

920
00:50:27,320 --> 00:50:34,730
original x86 there's a one bit flag for

921
00:50:31,400 --> 00:50:38,810
each region of memory saying is it

922
00:50:34,730 --> 00:50:42,470
actually - one bit flags one is can this

923
00:50:38,810 --> 00:50:44,540
be written to so that you can prevent

924
00:50:42,470 --> 00:50:49,100
overwrite so things like string

925
00:50:44,540 --> 00:50:52,280
constants and so and then the other is

926
00:50:49,100 --> 00:50:54,530
am I can I read it and read means access

927
00:50:52,280 --> 00:50:56,450
those bytes and it was interpreted that

928
00:50:54,530 --> 00:50:59,960
readable and executable were the same

929
00:50:56,450 --> 00:51:04,520
thing I can read it I can execute it and

930
00:50:59,960 --> 00:51:07,460
that was the rule in a sort of last 10

931
00:51:04,520 --> 00:51:10,460
years or so starting first with AMD and

932
00:51:07,460 --> 00:51:13,190
then Intel have added a third bit that

933
00:51:10,460 --> 00:51:15,440
says is this executable or not similarly

934
00:51:13,190 --> 00:51:17,960
to the permissions you have on a file on

935
00:51:15,440 --> 00:51:20,300
UNIX is it readable writable executable

936
00:51:17,960 --> 00:51:24,560
those are three separate permission bits

937
00:51:20,300 --> 00:51:27,770
that are alone so by simply marking the

938
00:51:24,560 --> 00:51:29,810
stack is not executable it'll also port

939
00:51:27,770 --> 00:51:31,880
this particular attack because I have to

940
00:51:29,810 --> 00:51:35,290
be able to execute these bytes as I've

941
00:51:31,880 --> 00:51:35,290
injected into the system

942
00:51:36,590 --> 00:51:42,470
and then there's the final idea which is

943
00:51:39,650 --> 00:51:45,020
actually fairly effective - which they

944
00:51:42,470 --> 00:51:46,250
call a canary that they built into the

945
00:51:45,020 --> 00:51:47,960
stack and some of you actually

946
00:51:46,250 --> 00:51:49,610
encountered this code already and

947
00:51:47,960 --> 00:51:53,240
looking at your bombs because we've been

948
00:51:49,610 --> 00:51:56,950
getting some questions about it so let

949
00:51:53,240 --> 00:51:56,950
me just give you an example here

950
00:52:04,760 --> 00:52:09,960
and this one's called buff demo - SP

951
00:52:07,890 --> 00:52:17,880
because it's been compiled with what

952
00:52:09,960 --> 00:52:20,550
they call stack protector and this one

953
00:52:17,880 --> 00:52:22,250
now it's the same code as before it's

954
00:52:20,550 --> 00:52:24,990
just compiled a little bit differently

955
00:52:22,250 --> 00:52:29,040
what you'll find is I can give a string

956
00:52:24,990 --> 00:52:35,730
of length 8 and not have a problem but

957
00:52:29,040 --> 00:52:37,980
if I now have 9 characters it will dump

958
00:52:35,730 --> 00:52:45,740
out with this very strange exit error

959
00:52:37,980 --> 00:52:49,680
message that is an indication that it

960
00:52:45,740 --> 00:52:51,390
detected a attempt to smash the stack so

961
00:52:49,680 --> 00:52:54,930
buffer overflow is sometimes called

962
00:52:51,390 --> 00:52:57,510
stack smashing so it detected somehow

963
00:52:54,930 --> 00:53:00,990
that even though I my code was still the

964
00:52:57,510 --> 00:53:03,090
same old crappy code from before of a

965
00:53:00,990 --> 00:53:06,570
very small buffer allocation and no

966
00:53:03,090 --> 00:53:11,130
protection somehow the the system

967
00:53:06,570 --> 00:53:13,980
protected me from myself and that's a

968
00:53:11,130 --> 00:53:18,840
via a relatively simple trick that's

969
00:53:13,980 --> 00:53:22,920
fairly clever though what they call step

970
00:53:18,840 --> 00:53:26,040
canary so that the term canary comes

971
00:53:22,920 --> 00:53:29,790
back from a back in the coal mining days

972
00:53:26,040 --> 00:53:31,890
of old before they had very good ways of

973
00:53:29,790 --> 00:53:34,830
measuring things they take a bird down

974
00:53:31,890 --> 00:53:38,630
with them in a cage and a canary is a

975
00:53:34,830 --> 00:53:43,380
property that's very susceptible to

976
00:53:38,630 --> 00:53:46,230
dying if there's nothing if there's

977
00:53:43,380 --> 00:53:47,610
methane gas present so these miners

978
00:53:46,230 --> 00:53:50,970
would be down there working and they'd

979
00:53:47,610 --> 00:53:53,480
see their bird keel over and say oh we

980
00:53:50,970 --> 00:53:55,950
got a problem here what get out fast so

981
00:53:53,480 --> 00:53:57,720
that's why they call it a canary in a

982
00:53:55,950 --> 00:53:59,760
coal mine sometimes some kind of warning

983
00:53:57,720 --> 00:54:04,500
signal that that something's not not

984
00:53:59,760 --> 00:54:08,010
right here and in general we see a GCC

985
00:54:04,500 --> 00:54:11,760
if you invoke it with a stack protector

986
00:54:08,010 --> 00:54:13,450
nowadays that's the default so even

987
00:54:11,760 --> 00:54:18,940
without you saying anything

988
00:54:13,450 --> 00:54:21,070
this code will get built into it and so

989
00:54:18,940 --> 00:54:22,599
let's look at what that canary code

990
00:54:21,070 --> 00:54:24,670
looks like and how it does its thing

991
00:54:22,599 --> 00:54:26,829
it's really pretty clever as I said and

992
00:54:24,670 --> 00:54:30,900
some of you have already observed this

993
00:54:26,829 --> 00:54:33,460
strange kind of memory reference in a

994
00:54:30,900 --> 00:54:35,950
register reference in the code and your

995
00:54:33,460 --> 00:54:37,930
BOM labs because it it was compiled with

996
00:54:35,950 --> 00:54:40,960
this deck protecting enabled because

997
00:54:37,930 --> 00:54:45,730
that's the default and so in particular

998
00:54:40,960 --> 00:54:49,420
what this code shows is it allocating as

999
00:54:45,730 --> 00:54:52,000
before 24 bytes on the stack but now

1000
00:54:49,420 --> 00:54:54,970
it's getting some number and we'll talk

1001
00:54:52,000 --> 00:55:00,460
in a second what that means and storing

1002
00:54:54,970 --> 00:55:02,829
it at position 8 offset from the stack

1003
00:55:00,460 --> 00:55:05,650
pointer and then the rest of the code

1004
00:55:02,829 --> 00:55:08,740
and then it zeros it out that's not to

1005
00:55:05,650 --> 00:55:11,020
worry and then it looks like the your

1006
00:55:08,740 --> 00:55:13,599
previous code that it's passing a

1007
00:55:11,020 --> 00:55:18,369
pointer to the stack the top of the

1008
00:55:13,599 --> 00:55:20,859
stack as the argument to get us and get

1009
00:55:18,369 --> 00:55:23,380
us it gets called and then put s gets

1010
00:55:20,859 --> 00:55:26,890
called but now there's some more code

1011
00:55:23,380 --> 00:55:29,349
here that is it involves this

1012
00:55:26,890 --> 00:55:31,030
strange-looking register and then

1013
00:55:29,349 --> 00:55:37,599
there's some kind of test and then if

1014
00:55:31,030 --> 00:55:40,150
that tests fail it will call this a code

1015
00:55:37,599 --> 00:55:44,200
that you just saw printed out this error

1016
00:55:40,150 --> 00:55:49,359
message so let's see what that all means

1017
00:55:44,200 --> 00:55:52,240
what that means is that it offset 8 from

1018
00:55:49,359 --> 00:55:56,800
the stack pointer it's putting in 8

1019
00:55:52,240 --> 00:56:02,050
bytes of value that it's retrieving from

1020
00:55:56,800 --> 00:56:05,200
a special register so FS is a reference

1021
00:56:02,050 --> 00:56:08,140
to a type of register that was created

1022
00:56:05,200 --> 00:56:10,210
for the original 8086 and is now

1023
00:56:08,140 --> 00:56:12,970
completely obsolete but it's still there

1024
00:56:10,210 --> 00:56:15,550
for backward compatibility mode but what

1025
00:56:12,970 --> 00:56:17,349
it is is and I actually I looked and

1026
00:56:15,550 --> 00:56:20,200
I've never fully been able to find the

1027
00:56:17,349 --> 00:56:22,810
documentation on it it's able to read

1028
00:56:20,200 --> 00:56:27,750
from a part of memory a set of values

1029
00:56:22,810 --> 00:56:31,990
that you can't otherwise get to

1030
00:56:27,750 --> 00:56:34,810
and so that the Khmer canary is getting

1031
00:56:31,990 --> 00:56:37,780
a somehow its grabbing eight bytes from

1032
00:56:34,810 --> 00:56:42,580
somewhere storing it as this canary

1033
00:56:37,780 --> 00:56:46,270
value and then if you give like a seven

1034
00:56:42,580 --> 00:56:48,580
character input so you would affect the

1035
00:56:46,270 --> 00:56:54,940
canary and so what happens when it

1036
00:56:48,580 --> 00:56:57,850
returns from the two calls from get us

1037
00:56:54,940 --> 00:57:01,990
and put us before it exits what it's

1038
00:56:57,850 --> 00:57:05,220
trying to detect is has anything as this

1039
00:57:01,990 --> 00:57:08,290
buffer somehow overflowed and

1040
00:57:05,220 --> 00:57:10,200
potentially at risk of of corrupting

1041
00:57:08,290 --> 00:57:12,700
some other part of the stack so

1042
00:57:10,200 --> 00:57:17,410
basically what it does is it retrieves

1043
00:57:12,700 --> 00:57:20,320
back from the stack what is the current

1044
00:57:17,410 --> 00:57:23,950
value of this canary and it's comparing

1045
00:57:20,320 --> 00:57:26,290
it to what it should be by retrieving

1046
00:57:23,950 --> 00:57:30,370
that back from this special region and

1047
00:57:26,290 --> 00:57:32,350
if they're equal it says fine but if

1048
00:57:30,370 --> 00:57:34,120
they're not equal it's detecting that

1049
00:57:32,350 --> 00:57:35,200
it's got corrupted so just like the

1050
00:57:34,120 --> 00:57:38,050
canary in the coalmine

1051
00:57:35,200 --> 00:57:40,240
if these bytes get corrupted in any form

1052
00:57:38,050 --> 00:57:45,820
it's an indication that something went

1053
00:57:40,240 --> 00:57:49,120
wrong now that example shows that if I

1054
00:57:45,820 --> 00:57:52,780
have a seven character string then I'm

1055
00:57:49,120 --> 00:57:54,400
not going to corrupt the canary but you

1056
00:57:52,780 --> 00:58:01,690
notice I just got away with an eight

1057
00:57:54,400 --> 00:58:04,800
character string so let me just see

1058
00:58:01,690 --> 00:58:04,800
what's going on here

1059
00:58:30,020 --> 00:58:38,230
I won a character string right oh please

1060
00:58:35,750 --> 00:58:38,230
lately

1061
00:58:42,920 --> 00:58:48,799
so I have to look I don't have the code

1062
00:58:45,479 --> 00:58:48,799
in front of me so I have to look at

1063
00:58:52,099 --> 00:59:01,069
so anyways here's where it's subtracting

1064
00:58:57,759 --> 00:59:03,709
24 from the stack pointer and then the

1065
00:59:01,069 --> 00:59:05,930
next instruction is retrieving this

1066
00:59:03,709 --> 00:59:09,880
canary values so let's figure out what

1067
00:59:05,930 --> 00:59:09,880
the canary is right now we are at

1068
00:59:16,109 --> 00:59:29,579
72f so we're at the first instruction

1069
00:59:19,030 --> 00:59:29,579
here let's do another step

1070
00:59:39,310 --> 00:59:47,630
so this is the canary and it you'll see

1071
00:59:45,349 --> 00:59:49,700
actually when from 100 others get a

1072
00:59:47,630 --> 00:59:51,530
different value of it so it's perfectly

1073
00:59:49,700 --> 00:59:54,500
put in there in a way that it's

1074
00:59:51,530 --> 00:59:56,150
unpredictable the one thing you'll

1075
00:59:54,500 --> 01:00:00,890
notice is that the low order byte is

1076
00:59:56,150 --> 01:00:03,079
zeroes and so apparently they knew that

1077
01:00:00,890 --> 01:00:04,819
it's so common to have so to off-by-one

1078
01:00:03,079 --> 01:00:07,190
bugs with strings where you don't

1079
01:00:04,819 --> 01:00:08,060
allocate enough space for the null

1080
01:00:07,190 --> 01:00:11,630
terminator

1081
01:00:08,060 --> 01:00:13,520
that they said well rather than having a

1082
01:00:11,630 --> 01:00:15,140
canary that will detect that byte being

1083
01:00:13,520 --> 01:00:18,380
corrupted we'll just sort of give that

1084
01:00:15,140 --> 01:00:21,980
byte away and so that's why it's letting

1085
01:00:18,380 --> 01:00:24,829
me type in eight characters and it's

1086
01:00:21,980 --> 01:00:28,010
overriding this low order byte of the

1087
01:00:24,829 --> 01:00:30,609
canary later on but that's not going to

1088
01:00:28,010 --> 01:00:30,609
affect anything

1089
01:00:52,490 --> 01:00:58,829
but let's give it 9 characters 10

1090
01:00:56,220 --> 01:01:01,160
characters to training a 9 character

1091
01:00:58,829 --> 01:01:01,160
string

1092
01:01:15,390 --> 01:01:17,390
Oh

1093
01:01:48,880 --> 01:01:50,880
ah

1094
01:01:51,910 --> 01:02:04,769
oh well I'm not finding it where I

1095
01:01:59,500 --> 01:02:04,769
thought it would be anyways oh this will

1096
01:02:06,750 --> 01:02:12,009
crop this deck but what I is showing you

1097
01:02:10,059 --> 01:02:13,720
the main idea is the canary some value

1098
01:02:12,009 --> 01:02:16,119
that gets pulled out and it will vary

1099
01:02:13,720 --> 01:02:18,309
from one time to the next and it's

1100
01:02:16,119 --> 01:02:20,890
letting you get away with eight

1101
01:02:18,309 --> 01:02:22,990
characters plus the null terminator but

1102
01:02:20,890 --> 01:02:25,559
anything more and it will detect that

1103
01:02:22,990 --> 01:02:25,559
corruption

1104
01:02:38,020 --> 01:02:43,240
okay so now we've seen three different

1105
01:02:40,680 --> 01:02:48,220
protections well for one is write better

1106
01:02:43,240 --> 01:02:49,960
code but there's three protections that

1107
01:02:48,220 --> 01:02:54,510
are done by the system that have nothing

1108
01:02:49,960 --> 01:02:54,510
to do with your code right one is to

1109
01:02:54,990 --> 01:03:00,040
randomize the stack position so it's

1110
01:02:58,390 --> 01:03:02,920
harder to figure out where the start

1111
01:03:00,040 --> 01:03:05,380
addresses are the second is to make the

1112
01:03:02,920 --> 01:03:08,380
stack so it's not executable so you

1113
01:03:05,380 --> 01:03:10,270
can't put code on that and then the

1114
01:03:08,380 --> 01:03:13,330
third is to use this deck canary or

1115
01:03:10,270 --> 01:03:17,050
other mechanisms to detect a potential

1116
01:03:13,330 --> 01:03:19,060
buffer overflow at the source so now

1117
01:03:17,050 --> 01:03:23,880
there's another attack that was

1118
01:03:19,060 --> 01:03:23,880
developed in response to some of these

1119
01:03:24,360 --> 01:03:30,610
that is still often successful it's

1120
01:03:28,000 --> 01:03:32,110
called return arted programming and for

1121
01:03:30,610 --> 01:03:34,090
your attack lab you're going to be doing

1122
01:03:32,110 --> 01:03:36,040
these attacks too that's why the tackle

1123
01:03:34,090 --> 01:03:39,130
AB is different than the old way of the

1124
01:03:36,040 --> 01:03:40,930
old web justed code injection exploits

1125
01:03:39,130 --> 01:03:45,040
now you're doing both code injections

1126
01:03:40,930 --> 01:03:50,230
and return oriented programming so the

1127
01:03:45,040 --> 01:03:53,260
idea this is if you are a hacker you're

1128
01:03:50,230 --> 01:03:55,800
frustrated because of these these three

1129
01:03:53,260 --> 01:03:59,140
techniques stack randomization

1130
01:03:55,800 --> 01:04:00,910
non-executable stack and Canaries well I

1131
01:03:59,140 --> 01:04:03,609
can't fix the canary problem that

1132
01:04:00,910 --> 01:04:05,790
actually the canary is a pretty secure

1133
01:04:03,609 --> 01:04:08,859
of

1134
01:04:05,790 --> 01:04:13,060
technique there's very I've never seen

1135
01:04:08,859 --> 01:04:15,100
anyone able to bypass a stet canary but

1136
01:04:13,060 --> 01:04:18,580
the other two you can do it using this

1137
01:04:15,100 --> 01:04:21,790
technique and the strategy is so we

1138
01:04:18,580 --> 01:04:24,850
don't know where the stack is but we

1139
01:04:21,790 --> 01:04:27,070
could still but we know where the code

1140
01:04:24,850 --> 01:04:30,970
is because you saw in that example the

1141
01:04:27,070 --> 01:04:33,040
code my layout randomization was

1142
01:04:30,970 --> 01:04:35,560
shifting the stack positions in the heap

1143
01:04:33,040 --> 01:04:40,230
positions but it wasn't changing either

1144
01:04:35,560 --> 01:04:44,320
global variables or or the code itself

1145
01:04:40,230 --> 01:04:47,830
so what if I can find some code that

1146
01:04:44,320 --> 01:04:50,040
sort of already there in the existing

1147
01:04:47,830 --> 01:04:54,240
part of the program

1148
01:04:50,040 --> 01:04:57,510
and use that instead of my own code that

1149
01:04:54,240 --> 01:04:59,460
I've injected and of course in general

1150
01:04:57,510 --> 01:05:01,350
you're not going to find exactly lying

1151
01:04:59,460 --> 01:05:04,380
there the exact program you want to

1152
01:05:01,350 --> 01:05:07,380
execute that will cause whatever harm

1153
01:05:04,380 --> 01:05:09,750
you intend to do because it's not

1154
01:05:07,380 --> 01:05:11,700
usually compiled into most programs but

1155
01:05:09,750 --> 01:05:17,940
if I could sort of string together

1156
01:05:11,700 --> 01:05:21,600
little segments of code and somehow put

1157
01:05:17,940 --> 01:05:24,000
together a series of little sequences of

1158
01:05:21,600 --> 01:05:26,700
code maybe I can get something useful

1159
01:05:24,000 --> 01:05:29,940
done and so that's the idea of this

1160
01:05:26,700 --> 01:05:32,400
return oriented programming and the idea

1161
01:05:29,940 --> 01:05:35,640
of it is to find what are known as

1162
01:05:32,400 --> 01:05:38,880
gadgets and a gadget is a sequence of

1163
01:05:35,640 --> 01:05:41,580
bytes that are represent part of the

1164
01:05:38,880 --> 01:05:45,870
executable program where the last byte

1165
01:05:41,580 --> 01:05:49,200
this is x86 talking here has a hex value

1166
01:05:45,870 --> 01:05:52,370
c3 which is how the RET instruction the

1167
01:05:49,200 --> 01:06:00,600
return instruction is encoded in x86

1168
01:05:52,370 --> 01:06:04,260
both ia-32 and x64 and so as an example

1169
01:06:00,600 --> 01:06:08,790
on the easy case is where there's some

1170
01:06:04,260 --> 01:06:11,190
function and it implements some

1171
01:06:08,790 --> 01:06:13,620
operation that I might find useful as an

1172
01:06:11,190 --> 01:06:17,040
attacker to be able to do so for example

1173
01:06:13,620 --> 01:06:19,830
this function is computing a times B

1174
01:06:17,040 --> 01:06:22,590
plus C and if I look at just the last

1175
01:06:19,830 --> 01:06:25,520
two instructions from there one of them

1176
01:06:22,590 --> 01:06:30,030
is a la which is performing addition and

1177
01:06:25,520 --> 01:06:32,460
the other is doing a return so I can

1178
01:06:30,030 --> 01:06:37,110
think of this this good old five bunk

1179
01:06:32,460 --> 01:06:40,890
byte chunk is a way if I could get some

1180
01:06:37,110 --> 01:06:43,410
data in registers R di and RDX then I

1181
01:06:40,890 --> 01:06:45,600
could compute their sum and stick it in

1182
01:06:43,410 --> 01:06:47,790
the RAS so imagine taking your program

1183
01:06:45,600 --> 01:06:49,560
you're trying to execute and breaking it

1184
01:06:47,790 --> 01:06:52,140
up into these little fragments and you

1185
01:06:49,560 --> 01:06:53,910
want to somehow find little block of

1186
01:06:52,140 --> 01:06:56,370
code somewhere to implement each of

1187
01:06:53,910 --> 01:06:58,890
these fragments and then the interesting

1188
01:06:56,370 --> 01:07:03,570
part is because they each end in C 3

1189
01:06:58,890 --> 01:07:03,820
this return as is it well let me get to

1190
01:07:03,570 --> 01:07:05,920
that

1191
01:07:03,820 --> 01:07:09,070
a minute so that's sort of the obvious

1192
01:07:05,920 --> 01:07:11,110
way that you pull out this is an

1193
01:07:09,070 --> 01:07:14,230
addition which you'd expect because that

1194
01:07:11,110 --> 01:07:17,380
was in the original C code but here's an

1195
01:07:14,230 --> 01:07:19,900
example of a gadget that has nothing to

1196
01:07:17,380 --> 01:07:23,790
do with the original C code it just

1197
01:07:19,900 --> 01:07:29,170
happens to match the bite pattern of

1198
01:07:23,790 --> 01:07:31,990
some existing code so this function

1199
01:07:29,170 --> 01:07:36,700
seems to not do anything too terribly

1200
01:07:31,990 --> 01:07:38,530
useful from hackers point of view but if

1201
01:07:36,700 --> 01:07:40,690
you look at this particular byte

1202
01:07:38,530 --> 01:07:44,680
sequence that happens to encode the

1203
01:07:40,690 --> 01:07:48,700
instruction move Q are a X to R di and C

1204
01:07:44,680 --> 01:07:53,590
3 encodes repped so and you can see if

1205
01:07:48,700 --> 01:07:59,680
this is at address 49 that's for D a for

1206
01:07:53,590 --> 01:08:02,850
DB for DC so it address 400 for DC if

1207
01:07:59,680 --> 01:08:05,770
you could start executing here it would

1208
01:08:02,850 --> 01:08:09,460
first do a move and then it would do a

1209
01:08:05,770 --> 01:08:12,010
return so I'm sort of taking advantage

1210
01:08:09,460 --> 01:08:16,170
of the fact in x86 it says by doing it

1211
01:08:12,010 --> 01:08:20,500
is instruction sequence and if I sort of

1212
01:08:16,170 --> 01:08:24,520
go off the aligned instructions I can

1213
01:08:20,500 --> 01:08:26,440
often find useful things to do so that's

1214
01:08:24,520 --> 01:08:28,510
what's called a gadget and you might ask

1215
01:08:26,440 --> 01:08:29,980
well what's so special about having them

1216
01:08:28,510 --> 01:08:33,130
end in a return

1217
01:08:29,980 --> 01:08:36,580
well imagine I could fill up my buffer

1218
01:08:33,130 --> 01:08:38,530
instead of with executable code I could

1219
01:08:36,580 --> 01:08:42,880
fill it up with a series of gadget

1220
01:08:38,530 --> 01:08:45,010
addresses so each gadget then is some

1221
01:08:42,880 --> 01:08:52,530
series of bytes where the final bite is

1222
01:08:45,010 --> 01:08:55,750
c3 and I'll actually position this as

1223
01:08:52,530 --> 01:08:57,670
not the oppositionists at some place

1224
01:08:55,750 --> 01:09:01,359
where you're actually going to do the

1225
01:08:57,670 --> 01:09:04,900
initial return instruction of from from

1226
01:09:01,359 --> 01:09:09,310
before so if I can somehow get the

1227
01:09:04,900 --> 01:09:12,520
program to return execute a rest right

1228
01:09:09,310 --> 01:09:15,190
now what it will do is return will pick

1229
01:09:12,520 --> 01:09:17,650
an address off of the stack pop an

1230
01:09:15,190 --> 01:09:19,690
address and begin execute

1231
01:09:17,650 --> 01:09:21,850
so that will start this code executing

1232
01:09:19,690 --> 01:09:25,150
and it will hit the c3 the RET

1233
01:09:21,850 --> 01:09:27,759
instruction at the end which will again

1234
01:09:25,150 --> 01:09:30,580
take a address pop it off the stack and

1235
01:09:27,759 --> 01:09:32,830
begin executing so start executing the

1236
01:09:30,580 --> 01:09:34,810
second gadget and so you'll see what

1237
01:09:32,830 --> 01:09:37,600
will happen is we're effectively

1238
01:09:34,810 --> 01:09:40,600
concatenating these pieces of code

1239
01:09:37,600 --> 01:09:43,060
together where it's using a ret to get

1240
01:09:40,600 --> 01:09:44,980
from one part the end of one gadget to

1241
01:09:43,060 --> 01:09:46,210
the start of the next and so that's

1242
01:09:44,980 --> 01:09:48,730
what's called return oriented

1243
01:09:46,210 --> 01:09:50,859
programming to wait instead of

1244
01:09:48,730 --> 01:09:53,049
sequencing programs using a program

1245
01:09:50,859 --> 01:09:56,080
counter like you normally do your

1246
01:09:53,049 --> 01:09:59,820
sequencing programs using the sort of

1247
01:09:56,080 --> 01:10:04,420
peculiar behavior of this particular x86

1248
01:09:59,820 --> 01:10:07,300
how returns work in in that program and

1249
01:10:04,420 --> 01:10:09,480
remember there's enough x86 out there

1250
01:10:07,300 --> 01:10:14,580
that if I can find a way to attack them

1251
01:10:09,480 --> 01:10:17,590
I'm in pretty I'm in a pretty good place

1252
01:10:14,580 --> 01:10:19,390
it's also possible to attack other

1253
01:10:17,590 --> 01:10:23,620
processors this way - it's just

1254
01:10:19,390 --> 01:10:25,210
particularly nice on x86 so that's the

1255
01:10:23,620 --> 01:10:28,390
idea of return on in programming and

1256
01:10:25,210 --> 01:10:31,150
you'll you'll do this yourself you'll

1257
01:10:28,390 --> 01:10:35,800
find gadgets string them together to do

1258
01:10:31,150 --> 01:10:40,030
different things in the attack lamp but

1259
01:10:35,800 --> 01:10:46,800
I'll point out that this still doesn't

1260
01:10:40,030 --> 01:10:50,100
so that this stack canary idea is still

1261
01:10:46,800 --> 01:10:53,500
successful detecting a buffer overflows

1262
01:10:50,100 --> 01:10:56,380
fairly effectively so in your tack lab

1263
01:10:53,500 --> 01:10:59,890
for example we've carefully compiled the

1264
01:10:56,380 --> 01:11:03,699
code to make it vulnerable to these

1265
01:10:59,890 --> 01:11:06,640
attacks otherwise it would be a lot

1266
01:11:03,699 --> 01:11:09,969
harder web like if you could do this you

1267
01:11:06,640 --> 01:11:17,679
could probably go into the dark world

1268
01:11:09,969 --> 01:11:20,050
and and be very successful so but so

1269
01:11:17,679 --> 01:11:23,140
we're actually sort of exposing the

1270
01:11:20,050 --> 01:11:25,090
vulnerability but in the the first part

1271
01:11:23,140 --> 01:11:27,520
of the lab you're using code injection

1272
01:11:25,090 --> 01:11:31,020
attacks so we've had to disable stack

1273
01:11:27,520 --> 01:11:34,670
randomization and also make the stack X

1274
01:11:31,020 --> 01:11:38,880
cutable so we had to sort of button the

1275
01:11:34,670 --> 01:11:41,880
return on programming we reenable that

1276
01:11:38,880 --> 01:11:45,810
so that the stack is not executable it

1277
01:11:41,880 --> 01:11:47,550
keeps jumping around randomly up but

1278
01:11:45,810 --> 01:11:49,320
we've turned off the stack Canaries so

1279
01:11:47,550 --> 01:11:53,820
you'll be able to overflow the buffer

1280
01:11:49,320 --> 01:11:57,990
and put in your gadget addresses and

1281
01:11:53,820 --> 01:11:59,790
build up a text that way so I think

1282
01:11:57,990 --> 01:12:01,560
you'll find by actually doing it you'll

1283
01:11:59,790 --> 01:12:05,670
learn a lot more than you can by just

1284
01:12:01,560 --> 01:12:08,010
hearing about it oh you might ask why do

1285
01:12:05,670 --> 01:12:09,480
we teach you this stuff right and if we

1286
01:12:08,010 --> 01:12:12,270
supposed to teach you to be good and not

1287
01:12:09,480 --> 01:12:14,390
evil well there's a couple reasons one

1288
01:12:12,270 --> 01:12:18,360
is you're going to learn a lot about

1289
01:12:14,390 --> 01:12:20,490
machine program execution and how stacks

1290
01:12:18,360 --> 01:12:22,770
work and how byte instructions are

1291
01:12:20,490 --> 01:12:25,680
encoded and stuff like that you'll use

1292
01:12:22,770 --> 01:12:27,990
the tools gb object dump and all those

1293
01:12:25,680 --> 01:12:30,900
even more than you did with the bomb web

1294
01:12:27,990 --> 01:12:34,020
so you'll learn a lot the other is we

1295
01:12:30,900 --> 01:12:37,890
assume that you will work for forces of

1296
01:12:34,020 --> 01:12:39,600
good but to be a good person you also

1297
01:12:37,890 --> 01:12:45,000
know what the bet have to know what the

1298
01:12:39,600 --> 01:12:51,390
bad people do so part of it is to become

1299
01:12:45,000 --> 01:12:53,640
more effective as a force for good okay

1300
01:12:51,390 --> 01:12:57,690
so the final thing to talk about today

1301
01:12:53,640 --> 01:13:00,510
is unions and the observation about a

1302
01:12:57,690 --> 01:13:03,270
union in C is the declaration that it

1303
01:13:00,510 --> 01:13:05,130
looks a lot like a struct where there's

1304
01:13:03,270 --> 01:13:07,020
this different fields and they're named

1305
01:13:05,130 --> 01:13:10,110
and they can have different types and

1306
01:13:07,020 --> 01:13:12,690
there can be pointers to unions and all

1307
01:13:10,110 --> 01:13:15,480
that stuff but they're actually totally

1308
01:13:12,690 --> 01:13:17,370
different what they do you recall it a

1309
01:13:15,480 --> 01:13:20,010
struct what happens as it Ella Cates

1310
01:13:17,370 --> 01:13:24,090
enough memory for all the fields to

1311
01:13:20,010 --> 01:13:29,610
coexist and potentially adding padding

1312
01:13:24,090 --> 01:13:32,130
bytes for what a union does is it only K

1313
01:13:29,610 --> 01:13:34,410
allocates enough storage for the maximum

1314
01:13:32,130 --> 01:13:35,850
field in it and it assumes that you're

1315
01:13:34,410 --> 01:13:38,430
only going to be using one of the

1316
01:13:35,850 --> 01:13:41,970
possible fields and it will literally a

1317
01:13:38,430 --> 01:13:44,760
store on top of these fields get stored

1318
01:13:41,970 --> 01:13:48,420
on top of each other so that if you

1319
01:13:44,760 --> 01:13:49,219
try to use multiple fields you can mess

1320
01:13:48,420 --> 01:13:51,840
things up

1321
01:13:49,219 --> 01:13:53,849
and it's not for that purpose of doing

1322
01:13:51,840 --> 01:13:56,369
multiple values it's for the purpose of

1323
01:13:53,849 --> 01:13:59,400
for example if I know I'm only going to

1324
01:13:56,369 --> 01:14:02,309
use one of these or it's another also a

1325
01:13:59,400 --> 01:14:04,199
way to create essentially an alias that

1326
01:14:02,309 --> 01:14:09,210
will let you reference memory in

1327
01:14:04,199 --> 01:14:13,980
different ways so for example in your

1328
01:14:09,210 --> 01:14:15,559
data web viewer using you were

1329
01:14:13,980 --> 01:14:17,219
manipulating the bit level

1330
01:14:15,559 --> 01:14:20,610
representations of floating point

1331
01:14:17,219 --> 01:14:23,400
numbers and in our code that would then

1332
01:14:20,610 --> 01:14:29,190
convert that to an actual float we used

1333
01:14:23,400 --> 01:14:31,469
a union where the Union is either to

1334
01:14:29,190 --> 01:14:36,500
view this field of four bytes is an

1335
01:14:31,469 --> 01:14:36,500
unsigned or is a float and so I can

1336
01:14:37,130 --> 01:14:42,929
convert from unsigned to its float

1337
01:14:39,989 --> 01:14:46,409
representation by just storing the

1338
01:14:42,929 --> 01:14:49,440
unsigned value in this Union and

1339
01:14:46,409 --> 01:14:51,260
retrieving it as if it were float and

1340
01:14:49,440 --> 01:14:53,790
this is a fundamentally different

1341
01:14:51,260 --> 01:14:55,860
operation than casting because you

1342
01:14:53,790 --> 01:14:58,110
recall when you take an unsigned value

1343
01:14:55,860 --> 01:15:00,119
and you cast it to a float you actually

1344
01:14:58,110 --> 01:15:02,309
change the bit to change it into the

1345
01:15:00,119 --> 01:15:07,170
floating point number that the closest a

1346
01:15:02,309 --> 01:15:08,820
match to this particular number it would

1347
01:15:07,170 --> 01:15:11,000
be the equivalent of the function you

1348
01:15:08,820 --> 01:15:13,619
implemented float underscore you to F

1349
01:15:11,000 --> 01:15:16,590
but this one actually doesn't change

1350
01:15:13,619 --> 01:15:19,530
bits it just changes the numeric value

1351
01:15:16,590 --> 01:15:22,020
changes quite a bit so it's a useful

1352
01:15:19,530 --> 01:15:25,280
technique to do that to be able to

1353
01:15:22,020 --> 01:15:29,550
override the the type system and get to

1354
01:15:25,280 --> 01:15:31,500
representations and this actually turns

1355
01:15:29,550 --> 01:15:34,079
out to be one of the places to where

1356
01:15:31,500 --> 01:15:38,369
byte ordering will show up in programs

1357
01:15:34,079 --> 01:15:41,579
if you're not careful so in particular

1358
01:15:38,369 --> 01:15:44,940
with this Union I can view a block of

1359
01:15:41,579 --> 01:15:48,719
eight bytes as either eight characters

1360
01:15:44,940 --> 01:15:51,989
for shorts to inch through one long and

1361
01:15:48,719 --> 01:15:54,900
on a 64-bit machine like is shown here

1362
01:15:51,989 --> 01:15:58,260
where along is 64 bits you'll see that

1363
01:15:54,900 --> 01:16:01,800
you're you're able to

1364
01:15:58,260 --> 01:16:05,850
get things as either as a the individual

1365
01:16:01,800 --> 01:16:08,490
bites making it up or some longer

1366
01:16:05,850 --> 01:16:10,200
aggregation of those bytes and you'll

1367
01:16:08,490 --> 01:16:12,720
actually find that depending on what

1368
01:16:10,200 --> 01:16:15,510
machine you run it on you'll get a

1369
01:16:12,720 --> 01:16:17,910
different result because of the byte

1370
01:16:15,510 --> 01:16:20,730
ordering of the different machines so

1371
01:16:17,910 --> 01:16:23,460
this goes through it what happens when

1372
01:16:20,730 --> 01:16:25,260
you run on different machines

1373
01:16:23,460 --> 01:16:30,090
but you'll you'll notice in particular

1374
01:16:25,260 --> 01:16:35,250
that on a thirty-two machine a 32-bit

1375
01:16:30,090 --> 01:16:40,470
machine it's coming off in in this byte

1376
01:16:35,250 --> 01:16:43,980
pattern F 3 F 2 F 1 F 0 and on a Sun

1377
01:16:40,470 --> 01:16:45,780
back when they existed you'd get the

1378
01:16:43,980 --> 01:16:53,790
opposite becomes in the byte ordering

1379
01:16:45,780 --> 01:16:59,190
and now on an x86 64 where a long is 64

1380
01:16:53,790 --> 01:17:00,810
bits you get a 8 byte and you can also

1381
01:16:59,190 --> 01:17:03,510
determine from this if you look

1382
01:17:00,810 --> 01:17:05,310
carefully that it's in it's a little

1383
01:17:03,510 --> 01:17:08,670
endian order because this is the least

1384
01:17:05,310 --> 01:17:14,940
significant byte is F 0 which is the

1385
01:17:08,670 --> 01:17:17,220
first byte f0 so it's also a way to get

1386
01:17:14,940 --> 01:17:18,660
to the low level bytes but when you use

1387
01:17:17,220 --> 01:17:23,150
this kind of thing you're sort of

1388
01:17:18,660 --> 01:17:25,680
intentionally telling the the C compiler

1389
01:17:23,150 --> 01:17:28,650
trust me I know what I'm doing you don't

1390
01:17:25,680 --> 01:17:30,150
have to protect me from myself and so if

1391
01:17:28,650 --> 01:17:31,950
you're not careful you can write code

1392
01:17:30,150 --> 01:17:32,910
where because of a byte ordering problem

1393
01:17:31,950 --> 01:17:38,190
or something like that

1394
01:17:32,910 --> 01:17:41,310
won't run properly on some machines so

1395
01:17:38,190 --> 01:17:43,500
just to summarize then we looked on it

1396
01:17:41,310 --> 01:17:46,100
we've looked down at the three compound

1397
01:17:43,500 --> 01:17:48,930
types in C the ways you can aggregate

1398
01:17:46,100 --> 01:17:51,260
smaller types into larger ones you can

1399
01:17:48,930 --> 01:17:54,240
make an array of identical elements

1400
01:17:51,260 --> 01:17:56,550
indexed by a number the position and

1401
01:17:54,240 --> 01:17:59,040
that usually turns into some kind of

1402
01:17:56,550 --> 01:18:02,310
scaled computation to get to the

1403
01:17:59,040 --> 01:18:06,060
particular place we've seen structures

1404
01:18:02,310 --> 01:18:07,860
where it's a fixed number of fields but

1405
01:18:06,060 --> 01:18:10,200
the fields can be of different type and

1406
01:18:07,860 --> 01:18:11,860
the reference by their names and that

1407
01:18:10,200 --> 01:18:13,600
usually turns into some type of

1408
01:18:11,860 --> 01:18:18,100
it's placement off of the original

1409
01:18:13,600 --> 01:18:21,790
position and then a union is just a way

1410
01:18:18,100 --> 01:18:24,790
of sort of piling up in one place of

1411
01:18:21,790 --> 01:18:27,070
what a number of different fields and so

1412
01:18:24,790 --> 01:18:30,429
all it does delegate the maximum number

1413
01:18:27,070 --> 01:18:32,110
of bytes for that and doesn't create

1414
01:18:30,429 --> 01:18:37,800
enough space for them all to be there at

1415
01:18:32,110 --> 01:18:37,800
the same time okay that's it for today

1416
01:18:37,840 --> 01:18:39,970
[Applause]

