1
00:00:00,000 --> 00:00:10,349
welcome good to see you today we're

2
00:00:05,040 --> 00:00:13,590
going to begin transitioning from how

3
00:00:10,349 --> 00:00:15,179
our program interact with hardware to

4
00:00:13,590 --> 00:00:17,880
how they interact with software in

5
00:00:15,179 --> 00:00:20,550
particular system software and we're

6
00:00:17,880 --> 00:00:22,289
going to start that investigation by by

7
00:00:20,550 --> 00:00:27,750
studying and learning about a process

8
00:00:22,289 --> 00:00:33,480
called linking which is how the system

9
00:00:27,750 --> 00:00:35,460
builds builds your program ok so we're

10
00:00:33,480 --> 00:00:37,370
going to study the the process of

11
00:00:35,460 --> 00:00:39,809
linking and then I'm going to show you a

12
00:00:37,370 --> 00:00:43,350
really cool technique called library

13
00:00:39,809 --> 00:00:45,450
inter positioning which it which allows

14
00:00:43,350 --> 00:00:49,500
you to use linking to actually intercept

15
00:00:45,450 --> 00:00:51,840
on function calls in in in libraries

16
00:00:49,500 --> 00:00:53,789
like the standard c library so it's a

17
00:00:51,840 --> 00:00:58,260
very very powerful interesting technique

18
00:00:53,789 --> 00:01:02,850
and it's all enabled by by linking so

19
00:00:58,260 --> 00:01:05,790
let's start with a simple program this

20
00:01:02,850 --> 00:01:11,700
program consists of two modules of name

21
00:01:05,790 --> 00:01:14,280
dot c and some dot c some dot c takes as

22
00:01:11,700 --> 00:01:17,159
an array as an argument and a length n

23
00:01:14,280 --> 00:01:21,000
and then it sums up the elements of that

24
00:01:17,159 --> 00:01:26,180
array and returns the sum back to the

25
00:01:21,000 --> 00:01:28,710
caller main dot c calls the sum function

26
00:01:26,180 --> 00:01:33,750
using and passes it a two element array

27
00:01:28,710 --> 00:01:38,040
of int and then returns that and then

28
00:01:33,750 --> 00:01:39,689
returns the value received from some we

29
00:01:38,040 --> 00:01:43,170
that that's kind of an odd thing to do

30
00:01:39,689 --> 00:01:45,000
to return your your exit status like

31
00:01:43,170 --> 00:01:47,130
that but we just did it so that the

32
00:01:45,000 --> 00:01:50,070
compiler would not devise the way all of

33
00:01:47,130 --> 00:01:51,780
our code i know let's look at what

34
00:01:50,070 --> 00:01:57,030
happens if when we want to compile those

35
00:01:51,780 --> 00:02:03,119
those two modules for each of main dot c

36
00:01:57,030 --> 00:02:07,200
and some duck see the GCC calls a series

37
00:02:03,119 --> 00:02:10,050
of translators on that on those modules

38
00:02:07,200 --> 00:02:13,400
on those ducks c files first calls the c

39
00:02:10,050 --> 00:02:13,400
preprocessor CPP

40
00:02:13,409 --> 00:02:20,920
then it calls the the compiler the

41
00:02:16,030 --> 00:02:23,709
actual compiler does which is CC one the

42
00:02:20,920 --> 00:02:28,120
compiler generates assembly which is

43
00:02:23,709 --> 00:02:31,870
then translated by the assembler AAS and

44
00:02:28,120 --> 00:02:35,140
resulting in a dot o file called main

45
00:02:31,870 --> 00:02:41,290
dot o similar things happens first for

46
00:02:35,140 --> 00:02:43,569
some dot C so after after the after

47
00:02:41,290 --> 00:02:47,909
these three translators work on the code

48
00:02:43,569 --> 00:02:51,569
we have two object files two dot o files

49
00:02:47,909 --> 00:02:57,430
the linker takes those those dot o files

50
00:02:51,569 --> 00:03:00,280
and put some link them together sort of

51
00:02:57,430 --> 00:03:06,120
smashes them together to form a single

52
00:03:00,280 --> 00:03:08,500
executable called that we can then run

53
00:03:06,120 --> 00:03:13,900
then we can then load and run on the

54
00:03:08,500 --> 00:03:16,449
system so the main dot C and some dots

55
00:03:13,900 --> 00:03:21,129
they are called source files these dot o

56
00:03:16,449 --> 00:03:24,280
files are our object files that we are

57
00:03:21,129 --> 00:03:26,019
separately compiled but and we call them

58
00:03:24,280 --> 00:03:30,060
relocatable object files because they

59
00:03:26,019 --> 00:03:36,069
can be combined together to form the

60
00:03:30,060 --> 00:03:37,599
fully linked executable object file so

61
00:03:36,069 --> 00:03:41,500
why do we do it like this you know why

62
00:03:37,599 --> 00:03:43,720
why do we allow the so-called separate

63
00:03:41,500 --> 00:03:46,449
compilation you know why don't we just

64
00:03:43,720 --> 00:03:49,120
have like one big you know one big file

65
00:03:46,449 --> 00:03:50,889
that was all of our code in it well

66
00:03:49,120 --> 00:03:53,620
there's a couple reasons the first is is

67
00:03:50,889 --> 00:03:56,079
modularity so by by allowing you to

68
00:03:53,620 --> 00:03:58,090
break your code into smaller pieces you

69
00:03:56,079 --> 00:04:00,639
can put related functions into separate

70
00:03:58,090 --> 00:04:04,060
source files you can define libraries of

71
00:04:00,639 --> 00:04:06,120
function so it's just it's just good

72
00:04:04,060 --> 00:04:09,959
technique and it allows you to kind of

73
00:04:06,120 --> 00:04:14,260
break your code up into nice - nice

74
00:04:09,959 --> 00:04:15,150
modular pieces the other reason is

75
00:04:14,260 --> 00:04:18,630
efficiency

76
00:04:15,150 --> 00:04:20,820
so if

77
00:04:18,630 --> 00:04:25,620
if we if we've broken up our program

78
00:04:20,820 --> 00:04:27,870
into multiple chunks if we change and if

79
00:04:25,620 --> 00:04:31,080
we if we only need to change one of the

80
00:04:27,870 --> 00:04:32,700
chunks we don't have to recompile the

81
00:04:31,080 --> 00:04:34,740
all the other all the other modules

82
00:04:32,700 --> 00:04:37,380
right we can just recompile the one

83
00:04:34,740 --> 00:04:39,030
module that we changed and then link

84
00:04:37,380 --> 00:04:43,350
them all together again right so it's

85
00:04:39,030 --> 00:04:45,060
it's efficient in time it's also

86
00:04:43,350 --> 00:04:49,050
efficient in space because you can take

87
00:04:45,060 --> 00:04:50,820
all of say all of the functions in the

88
00:04:49,050 --> 00:04:53,790
standard c library you could put them

89
00:04:50,820 --> 00:04:55,350
all together but then the only functions

90
00:04:53,790 --> 00:04:56,730
that you actually get compiled and

91
00:04:55,350 --> 00:04:59,750
linked into your program are the ones

92
00:04:56,730 --> 00:05:02,910
that you actually call okay so you can

93
00:04:59,750 --> 00:05:04,620
you can save space you don't you know

94
00:05:02,910 --> 00:05:09,210
normally you use only a small subset of

95
00:05:04,620 --> 00:05:10,980
the standard C functions and so there's

96
00:05:09,210 --> 00:05:12,480
no there's no point in linking all of

97
00:05:10,980 --> 00:05:15,510
those functions into your code if you

98
00:05:12,480 --> 00:05:19,380
don't need them all right so what are

99
00:05:15,510 --> 00:05:23,340
linkers do well there's two main there's

100
00:05:19,380 --> 00:05:27,240
two main tasks that linker performs the

101
00:05:23,340 --> 00:05:30,000
first is called symbol resolution so

102
00:05:27,240 --> 00:05:33,060
program define and reference symbols

103
00:05:30,000 --> 00:05:36,270
okay what the linker refers to as

104
00:05:33,060 --> 00:05:40,350
symbols and these are global variables

105
00:05:36,270 --> 00:05:43,830
and functions gain the names and those

106
00:05:40,350 --> 00:05:50,340
those objects they're referred to as a

107
00:05:43,830 --> 00:05:54,630
symbol so here we're declaring we're

108
00:05:50,340 --> 00:05:56,970
defining a symbol called swap here we're

109
00:05:54,630 --> 00:05:59,820
referring when we call swap we're

110
00:05:56,970 --> 00:06:03,900
referring to that symbol okay that's a

111
00:05:59,820 --> 00:06:06,570
reference to the symbol and here we're

112
00:06:03,900 --> 00:06:10,980
defining a pointer to an int called

113
00:06:06,570 --> 00:06:13,290
XP so we're defining XP and we're

114
00:06:10,980 --> 00:06:16,400
initializing it to the address of X so

115
00:06:13,290 --> 00:06:20,340
we're referring that's a reference to X

116
00:06:16,400 --> 00:06:23,490
okay so the symbol definitions are

117
00:06:20,340 --> 00:06:27,150
stored in the object file by the

118
00:06:23,490 --> 00:06:29,940
assembler in a symbol table which is an

119
00:06:27,150 --> 00:06:32,820
array of structs where each struck

120
00:06:29,940 --> 00:06:35,750
contains information about the symbol

121
00:06:32,820 --> 00:06:42,060
like the name of the symbol its size and

122
00:06:35,750 --> 00:06:45,270
where it's located now what we mean by

123
00:06:42,060 --> 00:06:49,040
symbol resolution is that during the

124
00:06:45,270 --> 00:06:52,890
linker blinking process the linker

125
00:06:49,040 --> 00:06:56,930
associates each symbol reference with

126
00:06:52,890 --> 00:07:00,930
exactly one symbol definition okay

127
00:06:56,930 --> 00:07:02,520
so it's possible and multiple you know

128
00:07:00,930 --> 00:07:04,680
why is this an issue well it's possible

129
00:07:02,520 --> 00:07:07,950
like in multiple modules you may declare

130
00:07:04,680 --> 00:07:09,750
a global variable with the same name the

131
00:07:07,950 --> 00:07:13,020
linker has to decide which one of those

132
00:07:09,750 --> 00:07:15,650
definitions to use for all subsequent

133
00:07:13,020 --> 00:07:15,650
references

134
00:07:15,980 --> 00:07:23,640
now once once the linker is associated a

135
00:07:20,240 --> 00:07:27,210
unique object with each a unique symbol

136
00:07:23,640 --> 00:07:29,160
definition with each reference then it

137
00:07:27,210 --> 00:07:32,220
does the second step which is relocation

138
00:07:29,160 --> 00:07:36,150
and during relocation it merges all of

139
00:07:32,220 --> 00:07:39,600
the modules together into a single into

140
00:07:36,150 --> 00:07:42,330
a single executable object module that

141
00:07:39,600 --> 00:07:46,200
can be directly loaded and executed on

142
00:07:42,330 --> 00:07:51,480
the system so when it when it when it

143
00:07:46,200 --> 00:07:54,390
does this merging it has to it has to

144
00:07:51,480 --> 00:07:56,430
figure out where each each symbol each

145
00:07:54,390 --> 00:07:58,650
function and each variable is going to

146
00:07:56,430 --> 00:08:02,760
be stored okay and this is called

147
00:07:58,650 --> 00:08:04,919
relocation because initially functions

148
00:08:02,760 --> 00:08:08,220
are just stored at some offset in their

149
00:08:04,919 --> 00:08:09,360
in their object module because the the

150
00:08:08,220 --> 00:08:10,950
linker doesn't know where those

151
00:08:09,360 --> 00:08:14,220
functions are actually going to be

152
00:08:10,950 --> 00:08:18,210
eventually a loaded into memory so

153
00:08:14,220 --> 00:08:21,000
before before relocation the address of

154
00:08:18,210 --> 00:08:24,419
a function in the object module is just

155
00:08:21,000 --> 00:08:27,900
its offset in the in the module and

156
00:08:24,419 --> 00:08:31,830
similarly for data during the relocation

157
00:08:27,900 --> 00:08:35,180
step the the linker decides on where

158
00:08:31,830 --> 00:08:37,860
each symbol is going to be ultimately

159
00:08:35,180 --> 00:08:41,610
located in memory one at X when the

160
00:08:37,860 --> 00:08:44,700
program executes and it binds that that

161
00:08:41,610 --> 00:08:47,730
those absolute memory locations to the

162
00:08:44,700 --> 00:08:49,290
to the symbol and then and then it goes

163
00:08:47,730 --> 00:08:52,200
and looks at all the references to those

164
00:08:49,290 --> 00:08:53,700
symbols and it updates those references

165
00:08:52,200 --> 00:08:54,840
so that they now they point to the

166
00:08:53,700 --> 00:08:57,330
correct address

167
00:08:54,840 --> 00:09:00,720
okay so figure out where stuff is going

168
00:08:57,330 --> 00:09:02,010
to go for each definition figure out

169
00:09:00,720 --> 00:09:03,990
where it's going to go and for each

170
00:09:02,010 --> 00:09:10,320
reference then update that reference so

171
00:09:03,990 --> 00:09:13,410
it now points to the right spot so let's

172
00:09:10,320 --> 00:09:15,930
look at what what these how these steps

173
00:09:13,410 --> 00:09:19,980
work in more detail before that we need

174
00:09:15,930 --> 00:09:21,690
to we need to define a few things so

175
00:09:19,980 --> 00:09:24,990
there's there's three kinds of object

176
00:09:21,690 --> 00:09:27,360
modules that I've alluded to there's the

177
00:09:24,990 --> 00:09:28,860
dot o file which is a relocatable object

178
00:09:27,360 --> 00:09:32,490
module this is the output of the

179
00:09:28,860 --> 00:09:34,290
assembler okay and it's it's not it's a

180
00:09:32,490 --> 00:09:37,310
binary file

181
00:09:34,290 --> 00:09:39,750
but it's not in any form that can be

182
00:09:37,310 --> 00:09:42,570
directly loaded into memory it needs to

183
00:09:39,750 --> 00:09:45,120
be manipulated by the linker before it

184
00:09:42,570 --> 00:09:46,950
can be actually used there's the

185
00:09:45,120 --> 00:09:50,700
executable object file which is

186
00:09:46,950 --> 00:09:53,880
generated by the linker these are called

187
00:09:50,700 --> 00:09:56,250
a doc files sometimes done historically

188
00:09:53,880 --> 00:09:58,350
the very first Linux systems the

189
00:09:56,250 --> 00:10:01,230
executable this sort of the default name

190
00:09:58,350 --> 00:10:03,630
that they the developers of UNIX used

191
00:10:01,230 --> 00:10:06,270
the default name for their executables

192
00:10:03,630 --> 00:10:08,940
as they dot out so that's that's just

193
00:10:06,270 --> 00:10:11,370
sort of a historical reason that it's

194
00:10:08,940 --> 00:10:14,190
it's called a dot out and then there's

195
00:10:11,370 --> 00:10:17,790
another type of object file called the

196
00:10:14,190 --> 00:10:22,310
shared object file or dot iso file which

197
00:10:17,790 --> 00:10:24,960
is a sort of modern a modern technique

198
00:10:22,310 --> 00:10:27,000
for creating shared libraries and we'll

199
00:10:24,960 --> 00:10:29,730
look at those we'll look at those later

200
00:10:27,000 --> 00:10:33,210
today now

201
00:10:29,730 --> 00:10:37,140
object modules come in a standard format

202
00:10:33,210 --> 00:10:39,840
called elf formats and it's a unified

203
00:10:37,140 --> 00:10:41,940
format for dot o files for executables

204
00:10:39,840 --> 00:10:48,480
and for dot iso files they all use the

205
00:10:41,940 --> 00:10:52,700
same format the same general format so

206
00:10:48,480 --> 00:10:55,560
this while these these elf binaries are

207
00:10:52,700 --> 00:10:58,370
their binaries they're very structured

208
00:10:55,560 --> 00:11:02,640
okay and they're broken up into section

209
00:10:58,370 --> 00:11:06,480
the at the beginning is the is a header

210
00:11:02,640 --> 00:11:09,690
that defines things like the size of the

211
00:11:06,480 --> 00:11:13,110
words the byte ordering whether it's a

212
00:11:09,690 --> 00:11:16,200
dot o and a dot out or a dot fo so it

213
00:11:13,110 --> 00:11:19,220
just provides them some sort of general

214
00:11:16,200 --> 00:11:21,300
information about this about this binary

215
00:11:19,220 --> 00:11:25,260
and then there's what's a so called

216
00:11:21,300 --> 00:11:27,510
segment header table which is it only

217
00:11:25,260 --> 00:11:30,960
it's only defined for the executable

218
00:11:27,510 --> 00:11:32,970
object files and it indicates where all

219
00:11:30,960 --> 00:11:35,190
the different segments of the code are

220
00:11:32,970 --> 00:11:37,980
going to go in in memory so where does

221
00:11:35,190 --> 00:11:38,970
your stack go where do your shared

222
00:11:37,980 --> 00:11:41,790
libraries go

223
00:11:38,970 --> 00:11:44,520
where does your your initialized and

224
00:11:41,790 --> 00:11:47,330
uninitialized data where does your code

225
00:11:44,520 --> 00:11:50,940
go right so all these all these various

226
00:11:47,330 --> 00:11:53,490
sections are defined in the segment

227
00:11:50,940 --> 00:11:56,430
header table and then there's the code

228
00:11:53,490 --> 00:11:59,220
itself which is is called the dot text

229
00:11:56,430 --> 00:12:04,760
section for sort of arcane historical

230
00:11:59,220 --> 00:12:07,950
reasons so dot text is always code and

231
00:12:04,760 --> 00:12:10,770
then that's followed by read-only data

232
00:12:07,950 --> 00:12:15,000
such as the jump tables in switch

233
00:12:10,770 --> 00:12:17,490
statements so text and and read only the

234
00:12:15,000 --> 00:12:19,380
dot text and ro data have the property

235
00:12:17,490 --> 00:12:22,890
that they're they're both read-only you

236
00:12:19,380 --> 00:12:26,840
don't write to them then that's followed

237
00:12:22,890 --> 00:12:29,640
by the data section which is contains

238
00:12:26,840 --> 00:12:32,130
space for all of your initialized global

239
00:12:29,640 --> 00:12:38,340
variables and then there's a section

240
00:12:32,130 --> 00:12:43,170
called VSS which contain which defines

241
00:12:38,340 --> 00:12:44,700
the uninitialized global variables now

242
00:12:43,170 --> 00:12:48,330
this doesn't actually take up any space

243
00:12:44,700 --> 00:12:50,070
because they're uninitialized rates okay

244
00:12:48,330 --> 00:12:55,050
but they're their entries in the symbol

245
00:12:50,070 --> 00:12:56,880
table for them and and it's at when this

246
00:12:55,050 --> 00:12:59,280
program gets loaded these variables are

247
00:12:56,880 --> 00:13:01,640
going to need they're actually going to

248
00:12:59,280 --> 00:13:05,250
have to have space allocated for them

249
00:13:01,640 --> 00:13:07,410
DFS is another one of those sort of

250
00:13:05,250 --> 00:13:09,840
arcane names that goes all the way back

251
00:13:07,410 --> 00:13:11,550
to the 60s for there's an idea of

252
00:13:09,840 --> 00:13:14,310
instruction called block started by

253
00:13:11,550 --> 00:13:16,980
symbol I think a better way to remember

254
00:13:14,310 --> 00:13:18,839
what it means is better safe space okay

255
00:13:16,980 --> 00:13:20,519
so you can if you have a separate

256
00:13:18,839 --> 00:13:23,010
section for the uninitialized variable

257
00:13:20,519 --> 00:13:25,230
since then initialized you don't have to

258
00:13:23,010 --> 00:13:33,149
you don't have to not have to consume

259
00:13:25,230 --> 00:13:35,160
any room in the in the dot o file ok

260
00:13:33,149 --> 00:13:38,850
there's also a section for the symbol

261
00:13:35,160 --> 00:13:43,290
table and this contained like I said

262
00:13:38,850 --> 00:13:49,380
it's an array of structs for procedures

263
00:13:43,290 --> 00:13:53,880
global variables and anything defined

264
00:13:49,380 --> 00:13:56,220
with the static attribute and each one

265
00:13:53,880 --> 00:13:59,579
of these each one of these symbols gets

266
00:13:56,220 --> 00:14:01,680
an entry in the symbol table and then

267
00:13:59,579 --> 00:14:04,079
there's two two sections called them

268
00:14:01,680 --> 00:14:07,980
that contain relocation info so this is

269
00:14:04,079 --> 00:14:10,290
the notes when that when the linker went

270
00:14:07,980 --> 00:14:12,269
and identified all the references to

271
00:14:10,290 --> 00:14:13,890
symbols it put a little note to say I'm

272
00:14:12,269 --> 00:14:16,770
going to have to remember to fix this

273
00:14:13,890 --> 00:14:21,180
the reference to the symbol up when I

274
00:14:16,770 --> 00:14:23,610
when I actually create the be executable

275
00:14:21,180 --> 00:14:26,370
so a relocation entry is just like a

276
00:14:23,610 --> 00:14:28,230
note that the linker or that it's a note

277
00:14:26,370 --> 00:14:30,149
that the assembler makes to the linker

278
00:14:28,230 --> 00:14:32,459
to say hey you're going to have to fix

279
00:14:30,149 --> 00:14:35,279
up this this reference because I don't

280
00:14:32,459 --> 00:14:36,600
know I don't know where this symbol is

281
00:14:35,279 --> 00:14:39,980
actually going to be stored in memory

282
00:14:36,600 --> 00:14:39,980
when it's when it's loaded

283
00:14:40,880 --> 00:14:48,510
okay and then there's a debug section

284
00:14:43,230 --> 00:14:52,350
that contains information that relates

285
00:14:48,510 --> 00:14:55,410
line numbers to in the source code to

286
00:14:52,350 --> 00:14:57,540
line numbers in the machine code okay

287
00:14:55,410 --> 00:14:59,040
and so this is called debug and this is

288
00:14:57,540 --> 00:15:01,740
what you get when you compile with dash

289
00:14:59,040 --> 00:15:04,550
G and then there's a header table that

290
00:15:01,740 --> 00:15:09,630
that tells you where all these different

291
00:15:04,550 --> 00:15:12,680
sections start now to a linker there's

292
00:15:09,630 --> 00:15:16,079
there's three different kinds of symbols

293
00:15:12,680 --> 00:15:19,560
global symbols are defined in some

294
00:15:16,079 --> 00:15:21,870
module m and they can and they can be

295
00:15:19,560 --> 00:15:24,779
used by other modules all right so I

296
00:15:21,870 --> 00:15:26,399
mean did you notice when we if we have a

297
00:15:24,779 --> 00:15:29,010
program that consists of multiple

298
00:15:26,399 --> 00:15:32,700
modules and we compile each one of those

299
00:15:29,010 --> 00:15:35,490
modules into a dot o file will be

300
00:15:32,700 --> 00:15:38,300
calling functions that aren't defined

301
00:15:35,490 --> 00:15:41,459
that are defined by other modules right

302
00:15:38,300 --> 00:15:44,040
okay so those but there's no error

303
00:15:41,459 --> 00:15:45,660
though that the compiler doesn't doesn't

304
00:15:44,040 --> 00:15:47,970
throw an error because it's assuming

305
00:15:45,660 --> 00:15:50,610
that those are defined in other modules

306
00:15:47,970 --> 00:15:53,070
and it assumes the linker will be able

307
00:15:50,610 --> 00:15:57,089
to find them in and determine the

308
00:15:53,070 --> 00:16:01,370
address so anything that's defined with

309
00:15:57,089 --> 00:16:05,310
any global either either global variable

310
00:16:01,370 --> 00:16:08,550
or a function name that's defined

311
00:16:05,310 --> 00:16:13,290
without the static attribute is a global

312
00:16:08,550 --> 00:16:14,930
symbol okay now and then external

313
00:16:13,290 --> 00:16:17,820
symbols are kind of a flipside of that

314
00:16:14,930 --> 00:16:20,670
external symbols are symbols that are

315
00:16:17,820 --> 00:16:24,870
referenced by some module but defined in

316
00:16:20,670 --> 00:16:27,390
some other module okay so in our in our

317
00:16:24,870 --> 00:16:30,480
in our little running example when when

318
00:16:27,390 --> 00:16:33,899
main dot C called the function sum it

319
00:16:30,480 --> 00:16:36,060
was referencing an external symbol okay

320
00:16:33,899 --> 00:16:38,670
and then there's there's local symbols

321
00:16:36,060 --> 00:16:44,070
and these are symbols that are defined

322
00:16:38,670 --> 00:16:46,410
and referenced within a module okay and

323
00:16:44,070 --> 00:16:48,600
those you create that this is not this

324
00:16:46,410 --> 00:16:51,750
is different from local variables okay

325
00:16:48,600 --> 00:16:53,550
the linker you know local c variables

326
00:16:51,750 --> 00:16:56,580
are

327
00:16:53,550 --> 00:17:01,050
managed by the compiler on the stack

328
00:16:56,580 --> 00:17:03,149
linker has no idea about local local see

329
00:17:01,050 --> 00:17:05,370
variables okay in this context when we

330
00:17:03,149 --> 00:17:08,760
talk about a local symbol what we're

331
00:17:05,370 --> 00:17:11,550
talking about is is either is a global a

332
00:17:08,760 --> 00:17:15,449
global variable or function declared

333
00:17:11,550 --> 00:17:16,770
with the static attribute whose that can

334
00:17:15,449 --> 00:17:19,100
only be referenced from within that

335
00:17:16,770 --> 00:17:22,589
module so we say that the scope the

336
00:17:19,100 --> 00:17:24,230
scope of the func function or global

337
00:17:22,589 --> 00:17:26,910
variable defines what the static

338
00:17:24,230 --> 00:17:31,290
attribute is limited to the module that

339
00:17:26,910 --> 00:17:35,370
it was defined in okay so this is in C

340
00:17:31,290 --> 00:17:37,500
this is how we do abstraction and this

341
00:17:35,370 --> 00:17:41,100
is how we can create sort of private

342
00:17:37,500 --> 00:17:43,740
functions that and pup private functions

343
00:17:41,100 --> 00:17:47,700
that can't be called from from outside

344
00:17:43,740 --> 00:17:51,330
that module okay so for instance if we

345
00:17:47,700 --> 00:17:52,440
want to make a library in C of functions

346
00:17:51,330 --> 00:17:54,870
we want to make a collection of

347
00:17:52,440 --> 00:17:57,630
functions that other programs can then

348
00:17:54,870 --> 00:18:01,350
call and link into their program and

349
00:17:57,630 --> 00:18:06,390
call the functions that we want to make

350
00:18:01,350 --> 00:18:08,970
visible to to other programs are defined

351
00:18:06,390 --> 00:18:10,710
without the static attribute and the

352
00:18:08,970 --> 00:18:14,160
functions that we want to have private

353
00:18:10,710 --> 00:18:16,950
and just be internal we declare what the

354
00:18:14,160 --> 00:18:19,220
static attribute and that way we get

355
00:18:16,950 --> 00:18:21,809
abstraction and we get hiding

356
00:18:19,220 --> 00:18:25,470
information hiding and we're only

357
00:18:21,809 --> 00:18:30,270
exposing data and functions that that we

358
00:18:25,470 --> 00:18:31,740
want that we want to expose all right so

359
00:18:30,270 --> 00:18:35,460
let's look in detail how the symbol

360
00:18:31,740 --> 00:18:40,429
resolution step works we recall our

361
00:18:35,460 --> 00:18:40,429
example our example program

362
00:18:41,190 --> 00:18:49,769
so here we're referencing a global

363
00:18:43,799 --> 00:18:56,099
called array that's defined within Maine

364
00:18:49,769 --> 00:19:05,099
dot see here when we here we're defining

365
00:18:56,099 --> 00:19:07,259
Maine a global called Maine here we're

366
00:19:05,099 --> 00:19:13,950
referencing a global called some that's

367
00:19:07,259 --> 00:19:16,139
defined in some dot C and Val is a local

368
00:19:13,950 --> 00:19:16,950
C variable on the stack and linker knows

369
00:19:16,139 --> 00:19:21,539
nothing about that

370
00:19:16,950 --> 00:19:26,190
okay now nor does it know anything about

371
00:19:21,539 --> 00:19:29,849
IRS which are also local variables now

372
00:19:26,190 --> 00:19:32,299
let's just let's make sure that we

373
00:19:29,849 --> 00:19:35,549
understand the difference between local

374
00:19:32,299 --> 00:19:40,440
static C variables versus local non

375
00:19:35,549 --> 00:19:43,979
static C variables so here we're

376
00:19:40,440 --> 00:19:49,859
defining a local static variable called

377
00:19:43,979 --> 00:19:53,129
int within this function f now because

378
00:19:49,859 --> 00:19:57,090
it's local its scope is limited to this

379
00:19:53,129 --> 00:20:00,979
function so this variable X can only be

380
00:19:57,090 --> 00:20:06,269
referenced within function f and

381
00:20:00,979 --> 00:20:10,590
similarly for this definition of X and

382
00:20:06,269 --> 00:20:14,429
function G can only be referenced by by

383
00:20:10,590 --> 00:20:16,169
function G now what's but because it's

384
00:20:14,429 --> 00:20:18,690
declared with the static attribute it's

385
00:20:16,169 --> 00:20:21,539
not stored on the stack it's actually

386
00:20:18,690 --> 00:20:24,090
stored in in the in dot data just like a

387
00:20:21,539 --> 00:20:26,099
global would be so it's it's like a

388
00:20:24,090 --> 00:20:30,299
global in a sense that it's actually

389
00:20:26,099 --> 00:20:31,769
stored in data rather than the stack but

390
00:20:30,299 --> 00:20:34,349
it's like a local C variable in the

391
00:20:31,769 --> 00:20:37,139
sense that its scope is limited just to

392
00:20:34,349 --> 00:20:41,099
the function that it's defined in so

393
00:20:37,139 --> 00:20:43,710
what what the compiler will do it will

394
00:20:41,099 --> 00:20:46,159
allocate space for each definition of X

395
00:20:43,710 --> 00:20:48,570
so this and it'll give it some name to

396
00:20:46,159 --> 00:20:51,389
disambiguate it so maybe it will call

397
00:20:48,570 --> 00:20:53,060
this one X dot 1 and maybe this one X

398
00:20:51,389 --> 00:20:57,050
dot 2

399
00:20:53,060 --> 00:20:59,090
so these symbols are allocated in dot

400
00:20:57,050 --> 00:21:01,010
data because because they're initialized

401
00:20:59,090 --> 00:21:08,720
and they get symbol table entries just

402
00:21:01,010 --> 00:21:11,960
like just like any other symbol okay so

403
00:21:08,720 --> 00:21:14,780
I said that during symbol resolution the

404
00:21:11,960 --> 00:21:18,970
linker associates each reference each

405
00:21:14,780 --> 00:21:22,550
symbol reference to exactly one unique

406
00:21:18,970 --> 00:21:24,200
symbol definition now how does it do

407
00:21:22,550 --> 00:21:29,570
that if there's multiple symbol

408
00:21:24,200 --> 00:21:32,750
definitions across all the modules so to

409
00:21:29,570 --> 00:21:35,210
understand this will will will will

410
00:21:32,750 --> 00:21:38,350
define symbols as being either strong or

411
00:21:35,210 --> 00:21:42,260
weak so strong symbols are either

412
00:21:38,350 --> 00:21:45,890
procedures or function function names or

413
00:21:42,260 --> 00:21:49,580
initialize global variables weak symbols

414
00:21:45,890 --> 00:21:54,740
or uninitialized global variables okay

415
00:21:49,580 --> 00:21:56,600
so int foo here is a strong symbol

416
00:21:54,740 --> 00:21:59,270
because it's initialized we're

417
00:21:56,600 --> 00:22:04,700
initializing it p1 is strong by

418
00:21:59,270 --> 00:22:08,530
definition foo is is weak in p2 dot C of

419
00:22:04,700 --> 00:22:11,510
this this definition of foo is weak

420
00:22:08,530 --> 00:22:14,450
because it's uninitialized and the

421
00:22:11,510 --> 00:22:17,390
definition of p2 is strong okay so that

422
00:22:14,450 --> 00:22:21,290
the rules that the velinkar uses are the

423
00:22:17,390 --> 00:22:24,680
following multiple strong symbols not

424
00:22:21,290 --> 00:22:27,650
allowed so that's an error okay

425
00:22:24,680 --> 00:22:29,570
so that means that if we if across

426
00:22:27,650 --> 00:22:31,610
multiple modules we declare a function

427
00:22:29,570 --> 00:22:34,810
with the same name the linker will will

428
00:22:31,610 --> 00:22:34,810
throw an error that's not allowed

429
00:22:35,530 --> 00:22:40,580
given a strong symbol and multiple weak

430
00:22:38,240 --> 00:22:46,040
symbols if the linker will always choose

431
00:22:40,580 --> 00:22:51,830
the strong symbol now remember if we

432
00:22:46,040 --> 00:22:54,770
initialize a global variable and we if

433
00:22:51,830 --> 00:22:56,420
we declare a initialized global variable

434
00:22:54,770 --> 00:22:58,280
across multiple modules that's an error

435
00:22:56,420 --> 00:23:01,220
because those are strong symbols okay by

436
00:22:58,280 --> 00:23:03,110
rule one but if we have one strong

437
00:23:01,220 --> 00:23:05,360
symbol and multiple weak symbols all

438
00:23:03,110 --> 00:23:06,410
with the same name then the compiler

439
00:23:05,360 --> 00:23:09,650
will choose the

440
00:23:06,410 --> 00:23:12,260
strong symbol okay and it will associate

441
00:23:09,650 --> 00:23:15,200
all references to that symbol will go to

442
00:23:12,260 --> 00:23:16,670
that strong symbol and if there's

443
00:23:15,200 --> 00:23:19,070
multiple weeks in both then it just

444
00:23:16,670 --> 00:23:20,420
picks an arbitrary one and this thisthis

445
00:23:19,070 --> 00:23:23,210
will see can be problematic

446
00:23:20,420 --> 00:23:27,380
now you can override it with this GCC

447
00:23:23,210 --> 00:23:29,330
flag called no common and if you if you

448
00:23:27,380 --> 00:23:32,930
declare your function with this no

449
00:23:29,330 --> 00:23:35,330
common argument then multiple weak

450
00:23:32,930 --> 00:23:37,820
symbols will throw an error in the

451
00:23:35,330 --> 00:23:39,470
linker all right so why do we care about

452
00:23:37,820 --> 00:23:41,600
all this stuff well it turns out if

453
00:23:39,470 --> 00:23:43,880
you're not aware of this stuff you can

454
00:23:41,600 --> 00:23:46,250
you can run into some really serious

455
00:23:43,880 --> 00:23:49,460
problems that are just perplexing and

456
00:23:46,250 --> 00:23:51,530
confounding right so linker linker

457
00:23:49,460 --> 00:23:53,390
errors are like the worst kind they're

458
00:23:51,530 --> 00:23:54,830
the hardest kind of debug because people

459
00:23:53,390 --> 00:23:58,580
aren't usually aware of what's going on

460
00:23:54,830 --> 00:24:00,490
inside their linkers and usually it's

461
00:23:58,580 --> 00:24:04,250
only like the very best programmers that

462
00:24:00,490 --> 00:24:06,110
really understand you know how these

463
00:24:04,250 --> 00:24:08,810
linkers work and what kind of errors

464
00:24:06,110 --> 00:24:12,560
they can throw and how to debug them so

465
00:24:08,810 --> 00:24:16,340
let me show you some examples of these

466
00:24:12,560 --> 00:24:19,130
these kind of errors all right so we

467
00:24:16,340 --> 00:24:21,430
have a program we've worked we have two

468
00:24:19,130 --> 00:24:24,440
modules so each of these rectangles

469
00:24:21,430 --> 00:24:29,210
corresponds to a module and we're

470
00:24:24,440 --> 00:24:34,030
defining p1 in each module so that's too

471
00:24:29,210 --> 00:24:34,030
strong symbols that's an error okay

472
00:24:35,140 --> 00:24:42,820
now here we were defining p1 and p2 so

473
00:24:40,030 --> 00:24:45,960
we're okay but now we've got two week

474
00:24:42,820 --> 00:24:51,520
symbols both are integers variables

475
00:24:45,960 --> 00:24:53,860
called X so and if these modules are

476
00:24:51,520 --> 00:24:56,200
referencing X the linker will just pick

477
00:24:53,860 --> 00:25:02,020
it we'll just pick one of these to serve

478
00:24:56,200 --> 00:25:05,290
as the definition but is this really

479
00:25:02,020 --> 00:25:07,210
what you want now in this case it

480
00:25:05,290 --> 00:25:09,580
doesn't really hurt anything because X

481
00:25:07,210 --> 00:25:12,940
is declared in both modules is an int

482
00:25:09,580 --> 00:25:17,950
all right so it'll just be it'll just be

483
00:25:12,940 --> 00:25:21,430
some integer sized variable that and it

484
00:25:17,950 --> 00:25:23,470
will be it'll be somewhere and but it

485
00:25:21,430 --> 00:25:26,770
doesn't really matter which which one

486
00:25:23,470 --> 00:25:29,110
the linker chooses but we start to get

487
00:25:26,770 --> 00:25:34,600
into trouble if we declare these weak

488
00:25:29,110 --> 00:25:36,820
symbols with different types so here

489
00:25:34,600 --> 00:25:42,820
we've declared an int X in one module

490
00:25:36,820 --> 00:25:45,850
and a double X in another module so if

491
00:25:42,820 --> 00:25:49,450
we write to X if the linker just

492
00:25:45,850 --> 00:25:52,870
arbitrarily chooses this this symbol

493
00:25:49,450 --> 00:26:01,060
definition to use now this is a symbol

494
00:25:52,870 --> 00:26:03,520
that of length 8 of size 8 if we

495
00:26:01,060 --> 00:26:05,410
anywhere in this program if we if the

496
00:26:03,520 --> 00:26:09,430
linker chooses that then anywhere in the

497
00:26:05,410 --> 00:26:11,800
program those references to those

498
00:26:09,430 --> 00:26:17,830
references to X will be to this double

499
00:26:11,800 --> 00:26:20,740
word this double word even even in this

500
00:26:17,830 --> 00:26:24,880
module if we reference X it'll be an 8

501
00:26:20,740 --> 00:26:27,090
byte right so it will overwrite Y with

502
00:26:24,880 --> 00:26:27,090
the

503
00:26:28,970 --> 00:26:43,510
hi order excuse me oh no it's completely

504
00:26:41,049 --> 00:26:50,559
its system it'll just pick one

505
00:26:43,510 --> 00:26:50,559
arbitrarily and you don't know I mean it

506
00:26:52,929 --> 00:26:59,500
alright here's now this is uh here's the

507
00:26:56,900 --> 00:27:02,720
problem we've defined a strong symbol X

508
00:26:59,500 --> 00:27:06,049
because we initialize it so the linker

509
00:27:02,720 --> 00:27:10,090
will always will associate all

510
00:27:06,049 --> 00:27:19,840
references to X to this integer size

511
00:27:10,090 --> 00:27:19,840
this integer sized symbol so if we write

512
00:27:28,410 --> 00:27:38,250
oh yeah right so so rights to X here

513
00:27:35,570 --> 00:27:41,280
this will be a double in this module but

514
00:27:38,250 --> 00:27:44,030
it will overwrite Y in this module so

515
00:27:41,280 --> 00:27:44,030
that's really nasty

516
00:27:47,880 --> 00:27:54,430
and here we were defining a strong

517
00:27:51,160 --> 00:27:58,870
symbol X so references to X in the

518
00:27:54,430 --> 00:28:00,640
second module will always get it will

519
00:27:58,870 --> 00:28:04,180
refer to this initialized variable which

520
00:28:00,640 --> 00:28:07,900
might not so it might not be what you

521
00:28:04,180 --> 00:28:12,880
want you may you may be assuming that

522
00:28:07,900 --> 00:28:15,310
it's uninitialized in your code okay and

523
00:28:12,880 --> 00:28:18,250
then you get the the ultimate nightmare

524
00:28:15,310 --> 00:28:20,290
scenario suppose you know because we're

525
00:28:18,250 --> 00:28:22,030
following a standard adi we can compile

526
00:28:20,290 --> 00:28:24,580
our code with multiple compilers and

527
00:28:22,030 --> 00:28:36,720
this actually happens in some oh yes

528
00:28:24,580 --> 00:28:39,160
questions oh yeah actually you're right

529
00:28:36,720 --> 00:28:41,770
it will it will still take preference

530
00:28:39,160 --> 00:28:43,780
and you'd be writing a for by quantity

531
00:28:41,770 --> 00:28:52,630
which is is what you want so that slides

532
00:28:43,780 --> 00:28:55,360
not quite right so yeah what is the

533
00:28:52,630 --> 00:28:57,850
point of doing that expert is not that

534
00:28:55,360 --> 00:29:00,010
it is always being reference just

535
00:28:57,850 --> 00:29:03,130
locally in your function what is the

536
00:29:00,010 --> 00:29:07,210
point of declaring it back is it

537
00:29:03,130 --> 00:29:10,440
distorted in like so no no no it's if

538
00:29:07,210 --> 00:29:14,290
you reference up if you reference a a

539
00:29:10,440 --> 00:29:18,720
variable that's you need so a variable

540
00:29:14,290 --> 00:29:18,720
its defined in your module and then you

541
00:29:18,840 --> 00:29:29,200
with the static right oh they're both

542
00:29:25,540 --> 00:29:33,430
they're both local so you do this if you

543
00:29:29,200 --> 00:29:34,900
want a value to retain from if you want

544
00:29:33,430 --> 00:29:38,740
if you want that variable to retain

545
00:29:34,900 --> 00:29:41,560
value from in locations in location so

546
00:29:38,740 --> 00:29:43,180
suppose you it's usually a bad idea as

547
00:29:41,560 --> 00:29:46,360
we'll see when we study threads because

548
00:29:43,180 --> 00:29:49,680
it makes your code non thread safe but

549
00:29:46,360 --> 00:29:52,810
like early like random number generators

550
00:29:49,680 --> 00:29:55,180
would it would compute a pseudo-random

551
00:29:52,810 --> 00:29:57,700
number and then it would store it in a

552
00:29:55,180 --> 00:30:00,120
static variable and then use that as the

553
00:29:57,700 --> 00:30:02,310
starting value for the next the neck

554
00:30:00,120 --> 00:30:04,920
time you called that function so

555
00:30:02,310 --> 00:30:06,750
whenever you want values to persist

556
00:30:04,920 --> 00:30:09,920
across function invocation to reduce

557
00:30:06,750 --> 00:30:09,920
static yes

558
00:30:25,200 --> 00:30:32,430
well win it let me let me get this

559
00:30:28,530 --> 00:30:35,790
straight right 2x + t2 will actually

560
00:30:32,430 --> 00:30:37,800
correspond to the memory look that will

561
00:30:35,790 --> 00:30:43,760
actually go to the memory location I'm

562
00:30:37,800 --> 00:30:48,690
sorry I I need to amend that so write 2x

563
00:30:43,760 --> 00:30:50,850
in t2 will be 8 bytes because the

564
00:30:48,690 --> 00:30:54,060
compiler you know the compiler knows

565
00:30:50,850 --> 00:30:59,940
that it's a double but it'll go to a

566
00:30:54,060 --> 00:31:02,850
memory location that I that's only 4

567
00:30:59,940 --> 00:31:06,300
bytes because X because the linker chose

568
00:31:02,850 --> 00:31:08,930
the strong symbol okay so so the rights

569
00:31:06,300 --> 00:31:11,930
to X and T 2 will actually overwrite Y

570
00:31:08,930 --> 00:31:11,930
ok

571
00:31:12,960 --> 00:31:34,110
I'm sorry yes question that's just

572
00:31:24,059 --> 00:31:37,830
usually the way it happens you know no

573
00:31:34,110 --> 00:31:40,260
no no global variables go in in dot data

574
00:31:37,830 --> 00:31:41,730
they don't go on the stack but usually

575
00:31:40,260 --> 00:31:44,010
if you define local variables in a

576
00:31:41,730 --> 00:31:45,510
function it will put them it will

577
00:31:44,010 --> 00:31:52,460
allocate them one after the other on

578
00:31:45,510 --> 00:31:52,460
their on the stack okay

579
00:31:53,180 --> 00:31:57,250
all right so all this discussion about

580
00:31:57,430 --> 00:32:02,780
these weird strong weak symbol rules

581
00:32:00,380 --> 00:32:08,180
that the linker have it's another reason

582
00:32:02,780 --> 00:32:11,630
to avoid global variables if you can if

583
00:32:08,180 --> 00:32:13,010
you if you need to declare a global see

584
00:32:11,630 --> 00:32:15,470
if you can declare it static because

585
00:32:13,010 --> 00:32:17,540
that'll limited scope to the the module

586
00:32:15,470 --> 00:32:20,120
that it's declared in so that's a good

587
00:32:17,540 --> 00:32:23,660
idea if you can do it and if you define

588
00:32:20,120 --> 00:32:25,730
a global variable initialize it so that

589
00:32:23,660 --> 00:32:29,480
you'll you'll you'll find you'll

590
00:32:25,730 --> 00:32:31,160
discover if you have multiple initialize

591
00:32:29,480 --> 00:32:35,510
global symbols with the same name in

592
00:32:31,160 --> 00:32:36,680
your code and then if you want to it's

593
00:32:35,510 --> 00:32:39,350
always good practice if you're

594
00:32:36,680 --> 00:32:40,880
referencing an external variable to tell

595
00:32:39,350 --> 00:32:47,930
the compiler about it by using the

596
00:32:40,880 --> 00:32:49,760
extern attribute all right so now at

597
00:32:47,930 --> 00:32:53,300
this point the linker has associated

598
00:32:49,760 --> 00:32:56,450
every symbol reference with some symbol

599
00:32:53,300 --> 00:32:59,090
definition now it has to take all those

600
00:32:56,450 --> 00:33:01,480
object relocatable object files and

601
00:32:59,090 --> 00:33:06,920
smush them together and create like one

602
00:33:01,480 --> 00:33:10,550
one big executable so suppose with our

603
00:33:06,920 --> 00:33:15,550
example a little running example each

604
00:33:10,550 --> 00:33:20,300
main zero and some dot o contain a a

605
00:33:15,550 --> 00:33:22,190
code and initialize data some dato

606
00:33:20,300 --> 00:33:25,880
doesn't have any initialize data just

607
00:33:22,190 --> 00:33:27,890
has code and then there's their system

608
00:33:25,880 --> 00:33:31,310
code that actually runs before and after

609
00:33:27,890 --> 00:33:33,140
your program so when when your program

610
00:33:31,310 --> 00:33:37,040
run it actually starts executing

611
00:33:33,140 --> 00:33:39,050
a startup code from from would see that

612
00:33:37,040 --> 00:33:40,700
that sort of initializes things and then

613
00:33:39,050 --> 00:33:46,190
the last thing that it does is it calls

614
00:33:40,700 --> 00:33:48,200
main and passes it arcs RC and RV okay

615
00:33:46,190 --> 00:33:52,100
and then when your when your program

616
00:33:48,200 --> 00:33:54,440
exits well that this is call but if your

617
00:33:52,100 --> 00:33:57,020
program if your main function routine

618
00:33:54,440 --> 00:33:58,820
does a return then it returns back to

619
00:33:57,020 --> 00:34:03,950
that startup code which then doesn't

620
00:33:58,820 --> 00:34:06,509
exit okay so so this is just and so this

621
00:34:03,950 --> 00:34:10,109
this consists of fudge

622
00:34:06,509 --> 00:34:12,480
texts and data as well and so when we

623
00:34:10,109 --> 00:34:18,299
when the linker relocates these these

624
00:34:12,480 --> 00:34:20,759
object files it takes all of the the

625
00:34:18,299 --> 00:34:24,599
code the text sections from each of the

626
00:34:20,759 --> 00:34:29,039
modules and put them together

627
00:34:24,599 --> 00:34:31,789
contiguously in the dot text section for

628
00:34:29,039 --> 00:34:34,289
the executable object file ok so it just

629
00:34:31,789 --> 00:34:38,940
puts them together in some order that it

630
00:34:34,289 --> 00:34:41,519
determines and it creates a combined dot

631
00:34:38,940 --> 00:34:43,559
text section in the executable that

632
00:34:41,519 --> 00:34:46,139
contains all of the system code and the

633
00:34:43,559 --> 00:34:48,179
all of the all of the code defined in

634
00:34:46,139 --> 00:34:50,669
the modules and then it does the same

635
00:34:48,179 --> 00:34:53,849
thing with the data takes all the all

636
00:34:50,669 --> 00:34:56,630
the dot data sections from the various

637
00:34:53,849 --> 00:35:00,269
object files and puts them together in

638
00:34:56,630 --> 00:35:04,079
one combined data section in the

639
00:35:00,269 --> 00:35:06,750
executable and it also emerges the

640
00:35:04,079 --> 00:35:12,599
symbol tables and in the debug

641
00:35:06,750 --> 00:35:17,220
information as well now when it just the

642
00:35:12,599 --> 00:35:20,339
act the act of sort of relocating these

643
00:35:17,220 --> 00:35:22,710
these object files requires the linker

644
00:35:20,339 --> 00:35:25,769
to figure out where it's going to

645
00:35:22,710 --> 00:35:29,039
actually store these these these

646
00:35:25,769 --> 00:35:31,319
different these different symbols when

647
00:35:29,039 --> 00:35:35,220
the system gets when this program gets

648
00:35:31,319 --> 00:35:38,940
loaded so it it has to pick an address

649
00:35:35,220 --> 00:35:42,119
for main that that function will start

650
00:35:38,940 --> 00:35:43,440
at some absolute address it's going to

651
00:35:42,119 --> 00:35:46,140
have it's gonna have to do the same for

652
00:35:43,440 --> 00:35:48,440
swap so for all the all the data arrays

653
00:35:46,140 --> 00:35:48,440
right

654
00:35:50,730 --> 00:35:58,269
and but the problem is that when this

655
00:35:54,819 --> 00:36:00,309
code is is compiled the compiler doesn't

656
00:35:58,269 --> 00:36:05,769
know what addresses the linker is going

657
00:36:00,309 --> 00:36:08,289
to pick so the so the compiler creates

658
00:36:05,769 --> 00:36:10,510
these these reminders to the linker

659
00:36:08,289 --> 00:36:11,680
called relocation entries which which

660
00:36:10,510 --> 00:36:15,609
are then stored in the relocation

661
00:36:11,680 --> 00:36:18,220
sections of the the object file and

662
00:36:15,609 --> 00:36:20,109
these these relocation entries are

663
00:36:18,220 --> 00:36:23,380
instructions to the linker that's

664
00:36:20,109 --> 00:36:24,789
something that there's a reference to a

665
00:36:23,380 --> 00:36:27,670
symbol that's going to have to be

666
00:36:24,789 --> 00:36:32,190
patched up when the the code is actually

667
00:36:27,670 --> 00:36:35,230
relocated and merged into the executable

668
00:36:32,190 --> 00:36:38,109
so let's look at a couple of these a

669
00:36:35,230 --> 00:36:40,089
couple of examples so in our in our main

670
00:36:38,109 --> 00:36:45,660
dot c module there was a reference to

671
00:36:40,089 --> 00:36:48,519
this to this global symbol called array

672
00:36:45,660 --> 00:36:51,490
okay and then there's also a reference

673
00:36:48,519 --> 00:36:55,599
to this this this global symbol sum

674
00:36:51,490 --> 00:36:57,789
which is the function so the the

675
00:36:55,599 --> 00:37:00,640
compiler creates two relocation entries

676
00:36:57,789 --> 00:37:04,750
the first one for the reference to the

677
00:37:00,640 --> 00:37:08,559
array a so here we're moving remember

678
00:37:04,750 --> 00:37:11,259
EDI is the first argument so remember

679
00:37:08,559 --> 00:37:14,470
our sum function takes the address of

680
00:37:11,259 --> 00:37:21,519
the of array of the input array as its

681
00:37:14,470 --> 00:37:26,740
it's argument so this move we're moving

682
00:37:21,519 --> 00:37:29,049
the address of the array into EDI for

683
00:37:26,740 --> 00:37:30,549
the first argument but the compiler

684
00:37:29,049 --> 00:37:36,490
doesn't know what that address is going

685
00:37:30,549 --> 00:37:39,220
to be it's it just it just it just it

686
00:37:36,490 --> 00:37:41,920
just moves in it an immediate value of 0

687
00:37:39,220 --> 00:37:46,180
into EDI temporarily right so you can

688
00:37:41,920 --> 00:37:48,970
see this is all zeros but bf is the move

689
00:37:46,180 --> 00:37:52,310
instruction and then there's allsey ROS

690
00:37:48,970 --> 00:37:54,590
in for now

691
00:37:52,310 --> 00:37:57,650
and then it places this relocation entry

692
00:37:54,590 --> 00:38:01,670
in the in the relocation section of

693
00:37:57,650 --> 00:38:06,710
Maemo and it it says it says to the

694
00:38:01,670 --> 00:38:10,510
laker at addre at offset a so these let

695
00:38:06,710 --> 00:38:15,680
me remind you these are our main zero

696
00:38:10,510 --> 00:38:17,780
module only contains one one function so

697
00:38:15,680 --> 00:38:21,200
that function starts that offsets zero

698
00:38:17,780 --> 00:38:24,590
in the in the code section of the module

699
00:38:21,200 --> 00:38:25,880
in the dot text section of the module if

700
00:38:24,590 --> 00:38:28,190
there were other functions in this

701
00:38:25,880 --> 00:38:31,610
module they would they would follow

702
00:38:28,190 --> 00:38:34,280
immediately after okay and it so you can

703
00:38:31,610 --> 00:38:36,560
see what what the compiler is it's just

704
00:38:34,280 --> 00:38:39,080
all it it's just generating offsets of

705
00:38:36,560 --> 00:38:42,800
these instructions from the beginning of

706
00:38:39,080 --> 00:38:45,860
the dot text section and it it includes

707
00:38:42,800 --> 00:38:48,170
this relocation entry which says to the

708
00:38:45,860 --> 00:38:54,260
link or hey on when you're relocating

709
00:38:48,170 --> 00:39:00,140
main zero at offset a in this dot text

710
00:38:54,260 --> 00:39:02,780
section you've got a reference a 30 to a

711
00:39:00,140 --> 00:39:08,980
reference to an array in the form of a

712
00:39:02,780 --> 00:39:11,120
32-bit address ok so that so eventually

713
00:39:08,980 --> 00:39:14,720
the linker is going to have to patch up

714
00:39:11,120 --> 00:39:16,400
these so this is address nine this is

715
00:39:14,720 --> 00:39:19,690
address a it's going to have to patch up

716
00:39:16,400 --> 00:39:24,980
the four bytes starting at address a

717
00:39:19,690 --> 00:39:27,250
with the absolute address of the symbol

718
00:39:24,980 --> 00:39:27,250
array

719
00:39:28,140 --> 00:39:37,830
and then similarly the reference to the

720
00:39:32,640 --> 00:39:41,790
reference to this the reference to this

721
00:39:37,830 --> 00:39:45,030
function some the compiler has no idea

722
00:39:41,790 --> 00:39:46,800
where some actually will end up it

723
00:39:45,030 --> 00:39:49,200
doesn't even know what module it's in or

724
00:39:46,800 --> 00:39:54,660
even if it's even it is defined in a

725
00:39:49,200 --> 00:39:59,730
module so in this case it just it does a

726
00:39:54,660 --> 00:40:01,710
call with all zeros and then it adds the

727
00:39:59,730 --> 00:40:09,510
three location entry that says to the

728
00:40:01,710 --> 00:40:14,510
linker at offset F you've got a four

729
00:40:09,510 --> 00:40:20,580
byte PC relative reference to a function

730
00:40:14,510 --> 00:40:23,610
to assemble called some and then it this

731
00:40:20,580 --> 00:40:25,950
is sort of a arcane detail that but and

732
00:40:23,610 --> 00:40:29,730
it includes there's an option to include

733
00:40:25,950 --> 00:40:33,840
a bias in the in the offset and since

734
00:40:29,730 --> 00:40:35,850
we're using since calls are since calls

735
00:40:33,840 --> 00:40:39,360
are always resolved using PC relative

736
00:40:35,850 --> 00:40:42,990
addressing the value that's going to be

737
00:40:39,360 --> 00:40:45,720
placed here at these four bytes that

738
00:40:42,990 --> 00:40:48,300
offset F is going to be an offset from

739
00:40:45,720 --> 00:40:51,180
the current RI p value or programmer

740
00:40:48,300 --> 00:40:53,130
counter value and since the program

741
00:40:51,180 --> 00:40:57,900
counter always points to the Ness cat

742
00:40:53,130 --> 00:41:00,270
next instruction it includes this which

743
00:40:57,900 --> 00:41:08,430
is four bytes away it includes this this

744
00:41:00,270 --> 00:41:09,930
offset of minus four so if it I talked

745
00:41:08,430 --> 00:41:12,090
about it in detail in the book if you

746
00:41:09,930 --> 00:41:14,730
really want to know how this works but

747
00:41:12,090 --> 00:41:16,440
just the point here is that there's

748
00:41:14,730 --> 00:41:19,740
enough information for the linker to

749
00:41:16,440 --> 00:41:21,540
actually fill in the right address so

750
00:41:19,740 --> 00:41:23,730
now if we look at the relocated text

751
00:41:21,540 --> 00:41:25,950
section so if we if we compile this code

752
00:41:23,730 --> 00:41:31,280
into an executable and then we use off

753
00:41:25,950 --> 00:41:31,280
stump to to disassemble it then

754
00:41:31,650 --> 00:41:37,560
what you see is this this reference here

755
00:41:34,710 --> 00:41:41,640
where we move the address of the address

756
00:41:37,560 --> 00:41:43,770
of a into EDI those four bytes which

757
00:41:41,640 --> 00:41:47,180
were originally zero has now been

758
00:41:43,770 --> 00:41:51,630
updated with the the actual address of

759
00:41:47,180 --> 00:41:54,180
array in in memory at runtime okay so

760
00:41:51,630 --> 00:41:56,970
the linkers decided that the array is

761
00:41:54,180 --> 00:42:00,450
going to go at address zero x six zero

762
00:41:56,970 --> 00:42:02,730
one zero one eight and then it's it's

763
00:42:00,450 --> 00:42:05,060
actually patched that the four bytes in

764
00:42:02,730 --> 00:42:10,290
the cup in the in the move instruction

765
00:42:05,060 --> 00:42:14,220
with that absolute address and the call

766
00:42:10,290 --> 00:42:16,530
to Psalm is it's also been updated but

767
00:42:14,220 --> 00:42:20,040
this one's interesting right that so the

768
00:42:16,530 --> 00:42:24,630
the address it's been updated with the

769
00:42:20,040 --> 00:42:30,500
PC relative address of five okay so when

770
00:42:24,630 --> 00:42:34,200
this program run this call instruction

771
00:42:30,500 --> 00:42:36,510
what it will do when it when it

772
00:42:34,200 --> 00:42:41,940
determines when it computes the absolute

773
00:42:36,510 --> 00:42:44,180
address of of the function some it will

774
00:42:41,940 --> 00:42:44,180
take

775
00:42:49,049 --> 00:42:57,490
it will take the current value of the

776
00:42:55,779 --> 00:43:02,710
program counter which is the next

777
00:42:57,490 --> 00:43:07,150
construction so 4 0 0 43 and it will add

778
00:43:02,710 --> 00:43:10,619
to it whatever whatever value is in this

779
00:43:07,150 --> 00:43:12,779
immediate field okay which is a tooth

780
00:43:10,619 --> 00:43:16,270
comprar today's a tooth compliment

781
00:43:12,779 --> 00:43:19,990
integer so it can go it can be relative

782
00:43:16,270 --> 00:43:21,910
you can go - or or plus in this case

783
00:43:19,990 --> 00:43:27,760
it's saying that the function that you

784
00:43:21,910 --> 00:43:34,119
want to call is that it is at 4 0 0 4 e

785
00:43:27,760 --> 00:43:37,029
3 + 5 which is 4 0 0 for e 8 which is

786
00:43:34,119 --> 00:43:40,000
the address of some okay and so the

787
00:43:37,029 --> 00:43:42,549
linker the linker does that the compiler

788
00:43:40,000 --> 00:43:45,190
has all the smarts the compiler computed

789
00:43:42,549 --> 00:43:46,720
the relocation entry the linker is just

790
00:43:45,190 --> 00:43:49,180
blindly going through each of those

791
00:43:46,720 --> 00:43:52,630
relocation entries and just doing what

792
00:43:49,180 --> 00:43:55,240
it's told ok but the net result is that

793
00:43:52,630 --> 00:43:58,809
now all of these these references have

794
00:43:55,240 --> 00:44:01,319
been patched up with with valid absolute

795
00:43:58,809 --> 00:44:01,319
addresses

796
00:44:05,250 --> 00:44:12,030
now once the linker has created a an

797
00:44:07,920 --> 00:44:15,180
object file that object file can be

798
00:44:12,030 --> 00:44:17,520
loaded the code and data and that object

799
00:44:15,180 --> 00:44:21,270
file can be loaded directly into memory

800
00:44:17,520 --> 00:44:25,650
with with no further modification okay

801
00:44:21,270 --> 00:44:31,470
so the if you look at all of the

802
00:44:25,650 --> 00:44:36,270
read-only sections in the executable so

803
00:44:31,470 --> 00:44:38,310
there's this an it section which we're

804
00:44:36,270 --> 00:44:40,380
not to worry about that that all the

805
00:44:38,310 --> 00:44:45,020
code is in the dot text and things like

806
00:44:40,380 --> 00:44:48,150
jump tables or an ro data all of this

807
00:44:45,020 --> 00:44:51,720
data can be loaded directly into memory

808
00:44:48,150 --> 00:44:54,859
as is okay so these bytes can just be

809
00:44:51,720 --> 00:44:58,230
copied directly into into memory and

810
00:44:54,859 --> 00:45:05,340
that that forms is so called a read-only

811
00:44:58,230 --> 00:45:08,250
code segment the the data and the dot

812
00:45:05,340 --> 00:45:14,490
data and BSS deck X section can also be

813
00:45:08,250 --> 00:45:16,619
copied directly into into memory and in

814
00:45:14,490 --> 00:45:18,960
the case of the variables and data

815
00:45:16,619 --> 00:45:25,690
they'll be initialized to a value that's

816
00:45:18,960 --> 00:45:28,210
stored in the symbol table so

817
00:45:25,690 --> 00:45:33,880
we're drawing our our memory here this

818
00:45:28,210 --> 00:45:38,019
is the this is the the memory address

819
00:45:33,880 --> 00:45:42,279
space that every Linux program sees and

820
00:45:38,019 --> 00:45:46,390
we're drawing addresses starting from

821
00:45:42,279 --> 00:45:51,130
zero and going up increasing as we grow

822
00:45:46,390 --> 00:46:00,910
up and every program is loaded at this

823
00:45:51,130 --> 00:46:03,700
the same address 0 X 4 0 0 0 0 0 and so

824
00:46:00,910 --> 00:46:06,130
the the code comes directly from the

825
00:46:03,700 --> 00:46:08,410
object file the data comes directly from

826
00:46:06,130 --> 00:46:12,279
the object file and then that's followed

827
00:46:08,410 --> 00:46:14,410
by a runtime heat which is created and

828
00:46:12,279 --> 00:46:16,390
managed by malloc so when you need

829
00:46:14,410 --> 00:46:21,819
dynamic dynamically need to allocate

830
00:46:16,390 --> 00:46:24,430
memory like using malloc that memory

831
00:46:21,819 --> 00:46:26,200
comes out of this heap which starts

832
00:46:24,430 --> 00:46:31,029
immediately following the the data

833
00:46:26,200 --> 00:46:37,630
segment and grows upwards the stack is

834
00:46:31,029 --> 00:46:39,900
at the very top of the visible memory

835
00:46:37,630 --> 00:46:46,450
that's available to application programs

836
00:46:39,900 --> 00:46:49,480
the memory above that is is restricted

837
00:46:46,450 --> 00:46:52,240
to the kernel ok so if you try to access

838
00:46:49,480 --> 00:46:56,109
those memory locations you'll get a seg

839
00:46:52,240 --> 00:46:58,390
fault and then the stack as we know

840
00:46:56,109 --> 00:47:00,819
grows down so this is managed and

841
00:46:58,390 --> 00:47:02,950
created at runtime and then there's this

842
00:47:00,819 --> 00:47:06,549
region somewhere in this huge gap

843
00:47:02,950 --> 00:47:08,980
between the stack and the heap there's a

844
00:47:06,549 --> 00:47:13,150
region for shared libraries so the dot n

845
00:47:08,980 --> 00:47:14,799
so files all get loaded into this this

846
00:47:13,150 --> 00:47:19,720
memory mapped region for shared

847
00:47:14,799 --> 00:47:23,430
libraries now that the top of the heap

848
00:47:19,720 --> 00:47:25,890
is indicated by this global variable

849
00:47:23,430 --> 00:47:30,039
maintained by the kernel called break

850
00:47:25,890 --> 00:47:32,890
vrk and the the top of the stack as we

851
00:47:30,039 --> 00:47:35,769
know is is maintained by the general

852
00:47:32,890 --> 00:47:37,779
purpose register RSP now there's a

853
00:47:35,769 --> 00:47:39,490
little bit of a this is a little bit of

854
00:47:37,779 --> 00:47:43,350
a simplification if you actually

855
00:47:39,490 --> 00:47:46,630
look at the addresses returned by malloc

856
00:47:43,350 --> 00:47:49,390
there's actually a there's actually two

857
00:47:46,630 --> 00:47:52,330
heaps there's a heap up here and in the

858
00:47:49,390 --> 00:47:55,630
high memory that grows down that's used

859
00:47:52,330 --> 00:47:57,070
for large objects very large you know if

860
00:47:55,630 --> 00:48:00,010
you now like a whole bunch of space and

861
00:47:57,070 --> 00:48:04,150
then the heat that grows up is is

862
00:48:00,010 --> 00:48:05,530
reserved for smaller smaller objects so

863
00:48:04,150 --> 00:48:08,520
I'm not really sure why they do this I

864
00:48:05,530 --> 00:48:10,900
think it allows them to have separate

865
00:48:08,520 --> 00:48:13,770
allocation algorithms for large objects

866
00:48:10,900 --> 00:48:13,770
and small objects

867
00:48:19,539 --> 00:48:24,319
okay so one of the one of the real

868
00:48:21,920 --> 00:48:27,529
advantages of linking is that allows us

869
00:48:24,319 --> 00:48:28,640
to create libraries of things so it's

870
00:48:27,529 --> 00:48:32,450
always something we want to do as

871
00:48:28,640 --> 00:48:35,599
programmers we always we always want to

872
00:48:32,450 --> 00:48:38,599
create abstractions and then present

873
00:48:35,599 --> 00:48:39,829
those abstractions to to users right and

874
00:48:38,599 --> 00:48:56,329
we do that by creating libraries

875
00:48:39,829 --> 00:49:01,569
defining an API yes I think it just no

876
00:48:56,329 --> 00:49:04,069
no it actually that's a good question I

877
00:49:01,569 --> 00:49:07,220
the things I've done it just grows until

878
00:49:04,069 --> 00:49:09,619
it runs out of memory right there so I

879
00:49:07,220 --> 00:49:12,380
don't think actually that's a really

880
00:49:09,619 --> 00:49:14,839
good question I mean I've done those

881
00:49:12,380 --> 00:49:23,619
experiments and it it eventually reaches

882
00:49:14,839 --> 00:49:32,380
some limit yeah I don't I don't know

883
00:49:23,619 --> 00:49:32,380
it's a very large number but I so

884
00:49:33,060 --> 00:49:37,890
you know as programmers we always want

885
00:49:35,130 --> 00:49:41,220
to abstract define api's implement

886
00:49:37,890 --> 00:49:45,960
package up those ATIS and make them

887
00:49:41,220 --> 00:49:48,110
available to to other programmers so how

888
00:49:45,960 --> 00:49:50,400
can we actually do that how can we make

889
00:49:48,110 --> 00:49:53,340
commonly used functions available to

890
00:49:50,400 --> 00:49:55,770
other programmers well one thing given

891
00:49:53,340 --> 00:49:58,050
what we've learned so far you could just

892
00:49:55,770 --> 00:50:02,670
take all the functions and put them all

893
00:49:58,050 --> 00:50:05,190
in a single big C file right and then

894
00:50:02,670 --> 00:50:07,290
programmers would just link that C file

895
00:50:05,190 --> 00:50:10,380
into their into their programs that they

896
00:50:07,290 --> 00:50:12,240
want to use them right another option

897
00:50:10,380 --> 00:50:14,010
would be to take that might get kind of

898
00:50:12,240 --> 00:50:16,350
unwieldy if it's a big library right

899
00:50:14,010 --> 00:50:19,560
let's see has hundreds and hundreds of

900
00:50:16,350 --> 00:50:21,480
functions so another option would might

901
00:50:19,560 --> 00:50:24,030
be to just take each function put it in

902
00:50:21,480 --> 00:50:25,410
a separate file and then compile them

903
00:50:24,030 --> 00:50:30,680
all together and compile and link them

904
00:50:25,410 --> 00:50:33,660
all together so this is more space and

905
00:50:30,680 --> 00:50:36,570
time efficient than then our first

906
00:50:33,660 --> 00:50:39,630
option but it seems like it would be

907
00:50:36,570 --> 00:50:40,860
burdensome on the programmer because the

908
00:50:39,630 --> 00:50:42,930
program would have to know where all

909
00:50:40,860 --> 00:50:45,240
these functions were and put them in

910
00:50:42,930 --> 00:50:46,770
make files would just be a lot of you

911
00:50:45,240 --> 00:50:52,820
know this you could end up with a

912
00:50:46,770 --> 00:50:52,820
ridiculously large command line to GCC

913
00:50:53,300 --> 00:51:01,320
so that the one solution to this problem

914
00:50:58,020 --> 00:51:04,590
it's a the first solution that the

915
00:51:01,320 --> 00:51:07,590
developers of UNIX came up with is

916
00:51:04,590 --> 00:51:09,540
something call it static library so the

917
00:51:07,590 --> 00:51:11,670
idea with a static library is that you

918
00:51:09,540 --> 00:51:15,960
create this archive called the dot a

919
00:51:11,670 --> 00:51:18,330
file which is it's just a collection of

920
00:51:15,960 --> 00:51:21,090
dot o files where each dot o file

921
00:51:18,330 --> 00:51:23,220
contains a function ok so you take all

922
00:51:21,090 --> 00:51:25,740
the functions in your library you use

923
00:51:23,220 --> 00:51:28,650
option two to create a bunch of dot o

924
00:51:25,740 --> 00:51:31,380
files and then you use a program called

925
00:51:28,650 --> 00:51:35,370
an archive or a R to take those dot o

926
00:51:31,380 --> 00:51:37,980
files put them together in a all

927
00:51:35,370 --> 00:51:41,850
together in a big file called an archive

928
00:51:37,980 --> 00:51:43,500
out with a with a table of contents at

929
00:51:41,850 --> 00:51:44,890
the beginning that tells you the offset

930
00:51:43,500 --> 00:51:47,560
of each one of the dot o file

931
00:51:44,890 --> 00:51:50,610
okay so an archive is just this

932
00:51:47,560 --> 00:51:56,040
concatenated collection of dot o files

933
00:51:50,610 --> 00:51:59,350
and then and then you link you pass that

934
00:51:56,040 --> 00:52:02,230
archive to the to the linker and it only

935
00:51:59,350 --> 00:52:04,150
takes the dot o files that are actually

936
00:52:02,230 --> 00:52:05,890
referenced and lengths them into the

937
00:52:04,150 --> 00:52:09,310
code right so it's a more efficient way

938
00:52:05,890 --> 00:52:11,340
you can have a huge archive but like

939
00:52:09,310 --> 00:52:14,170
let's see but if you only call printf

940
00:52:11,340 --> 00:52:19,720
the only dot o file you get is printf

941
00:52:14,170 --> 00:52:27,250
zero okay so the way this works is as

942
00:52:19,720 --> 00:52:30,820
before we take we take all the functions

943
00:52:27,250 --> 00:52:32,560
we want to put in our library we run

944
00:52:30,820 --> 00:52:36,670
them through our translators to get dot

945
00:52:32,560 --> 00:52:40,210
o files we pass those to the archiver to

946
00:52:36,670 --> 00:52:45,100
get a the archive so in this case of Lib

947
00:52:40,210 --> 00:52:48,340
C dot a and which has this code for

948
00:52:45,100 --> 00:52:51,640
printf that we might want to use right

949
00:52:48,340 --> 00:52:53,860
and so we can we can we can recreate

950
00:52:51,640 --> 00:52:55,390
that archive anytime we want so if one

951
00:52:53,860 --> 00:52:58,750
of these functions changes like say

952
00:52:55,390 --> 00:53:01,390
printf changes you just re archive the

953
00:52:58,750 --> 00:53:05,890
dot recompile printf and then re archive

954
00:53:01,390 --> 00:53:08,560
all of it dot o files so in let's see

955
00:53:05,890 --> 00:53:13,090
it's about 1500 object files and it's

956
00:53:08,560 --> 00:53:14,500
archived things like printf scanf simple

957
00:53:13,090 --> 00:53:18,880
integer math and there's also a math

958
00:53:14,500 --> 00:53:22,170
library which has you know several

959
00:53:18,880 --> 00:53:26,130
hundred common functions for things like

960
00:53:22,170 --> 00:53:30,700
floating point math sine cosine tangent

961
00:53:26,130 --> 00:53:32,830
etc these libraries the convention is

962
00:53:30,700 --> 00:53:36,580
that a library always is prefixed with

963
00:53:32,830 --> 00:53:39,130
Lib L ID and then and then sort of

964
00:53:36,580 --> 00:53:41,250
there's some indication of what it what

965
00:53:39,130 --> 00:53:41,250
it does

966
00:53:42,660 --> 00:53:47,080
so now let's see how linking with these

967
00:53:45,100 --> 00:53:51,250
static libraries of work so I I've

968
00:53:47,080 --> 00:53:54,210
created a little example here I've

969
00:53:51,250 --> 00:53:57,100
created a library called Lib vector a

970
00:53:54,210 --> 00:53:59,590
and it consists of functions that

971
00:53:57,100 --> 00:54:02,050
manipulate vectors and this is a real

972
00:53:59,590 --> 00:54:05,350
simple library just adds there's a

973
00:54:02,050 --> 00:54:10,570
function to add two vectors x and y

974
00:54:05,350 --> 00:54:12,970
together and return the result in Z and

975
00:54:10,570 --> 00:54:16,240
then another similar function that will

976
00:54:12,970 --> 00:54:22,750
do pairwise multiplication of two

977
00:54:16,240 --> 00:54:25,750
vectors so X I times y I equals Z I and

978
00:54:22,750 --> 00:54:27,970
now I compile these two programs and

979
00:54:25,750 --> 00:54:31,150
pack I want to package them into an

980
00:54:27,970 --> 00:54:33,670
archive called lead vector a and then in

981
00:54:31,150 --> 00:54:37,060
my in my main program I'm going to call

982
00:54:33,670 --> 00:54:40,800
one of those functions advic to add

983
00:54:37,060 --> 00:54:40,800
these two vectors x and y together

984
00:54:43,430 --> 00:54:50,099
so now what happens when we compile this

985
00:54:46,049 --> 00:54:54,509
this program we've already we've

986
00:54:50,099 --> 00:54:57,859
constructed the archive live dr. a from

987
00:54:54,509 --> 00:55:01,460
ad zero and multi

988
00:54:57,859 --> 00:55:06,029
and we pass that archive to the linker

989
00:55:01,460 --> 00:55:10,880
along with our main to zero relocatable

990
00:55:06,029 --> 00:55:13,499
objects file and we also pass it live CA

991
00:55:10,880 --> 00:55:16,559
which has the definition of which

992
00:55:13,499 --> 00:55:21,769
contains printf zero and anything else

993
00:55:16,559 --> 00:55:25,559
that printf L might call so these three

994
00:55:21,769 --> 00:55:28,440
the linker detects the reference to

995
00:55:25,559 --> 00:55:31,859
advic the function add back and so it

996
00:55:28,440 --> 00:55:33,150
just pulls advocaat o out and and

997
00:55:31,859 --> 00:55:36,479
ignores the rest

998
00:55:33,150 --> 00:55:39,660
similarly for printf dot o and then it

999
00:55:36,479 --> 00:55:41,700
compiles all those main main to 0 add

1000
00:55:39,660 --> 00:55:45,269
vector and printf dot o all together

1001
00:55:41,700 --> 00:55:50,069
into this fully linked executable called

1002
00:55:45,269 --> 00:55:52,259
prog to see for compiled time so we're

1003
00:55:50,069 --> 00:55:55,759
doing this we're doing this link we're

1004
00:55:52,259 --> 00:56:00,779
doing this this linking at compile time

1005
00:55:55,759 --> 00:56:05,430
when we call a GCC now what the linker

1006
00:56:00,779 --> 00:56:10,469
does when it's when it's using static

1007
00:56:05,430 --> 00:56:12,960
libraries it scans all the dot o files

1008
00:56:10,469 --> 00:56:16,769
and dot a files in order on the command

1009
00:56:12,960 --> 00:56:19,259
line so you're just typing GCC and then

1010
00:56:16,769 --> 00:56:24,660
a list of dot o files and dot a CoA

1011
00:56:19,259 --> 00:56:28,109
files in some words so so during the

1012
00:56:24,660 --> 00:56:31,589
scan it keeps a list of the current

1013
00:56:28,109 --> 00:56:34,079
unresolved references right so if let's

1014
00:56:31,589 --> 00:56:36,799
say let's say it looks at main dot o

1015
00:56:34,079 --> 00:56:38,940
first and there's a reference to printf

1016
00:56:36,799 --> 00:56:41,819
that's an unresolved reference because

1017
00:56:38,940 --> 00:56:43,529
printouts not not defined in main dot o

1018
00:56:41,819 --> 00:56:47,059
so that goes in a list of undefined

1019
00:56:43,529 --> 00:56:51,529
references and at some point or another

1020
00:56:47,059 --> 00:56:55,569
as each new 0 file or dot a file is

1021
00:56:51,529 --> 00:56:57,130
encountered the linker tries to

1022
00:56:55,569 --> 00:56:59,049
resolve its list of unresolved

1023
00:56:57,130 --> 00:57:02,109
references with the symbols that are

1024
00:56:59,049 --> 00:57:05,770
defined in that dot o file or dot a file

1025
00:57:02,109 --> 00:57:07,359
and then if there's any entries in the

1026
00:57:05,770 --> 00:57:10,180
list at the end of the scan then there's

1027
00:57:07,359 --> 00:57:11,740
an error okay so that the key here is

1028
00:57:10,180 --> 00:57:13,569
that the linker will try to resolve

1029
00:57:11,740 --> 00:57:16,829
these references from left to right on

1030
00:57:13,569 --> 00:57:19,000
the command line and so this is another

1031
00:57:16,829 --> 00:57:20,980
sort of important thing for you to know

1032
00:57:19,000 --> 00:57:23,920
as programmers because the order that

1033
00:57:20,980 --> 00:57:25,660
you that you put your files on the

1034
00:57:23,920 --> 00:57:28,150
command line actually makes a difference

1035
00:57:25,660 --> 00:57:31,210
okay so you can get sort of weird

1036
00:57:28,150 --> 00:57:34,059
baffling linker errors if you if you use

1037
00:57:31,210 --> 00:57:40,059
the wrong order so for instance suppose

1038
00:57:34,059 --> 00:57:44,380
we've got a function an object module

1039
00:57:40,059 --> 00:57:50,290
called Lib test that calls a function

1040
00:57:44,380 --> 00:57:54,640
that's defined in and live Monday okay

1041
00:57:50,290 --> 00:58:01,270
so these - L - Big L period that that

1042
00:57:54,640 --> 00:58:03,970
says to look for to look for a library

1043
00:58:01,270 --> 00:58:06,640
files in the current directory that's

1044
00:58:03,970 --> 00:58:08,380
what the dot look there first and then

1045
00:58:06,640 --> 00:58:14,530
look in the normal places that you look

1046
00:58:08,380 --> 00:58:17,020
and the the - lowercase L that's a it's

1047
00:58:14,530 --> 00:58:20,140
like an abbreviation we could replace

1048
00:58:17,020 --> 00:58:23,109
this with just the fully spelled out vid

1049
00:58:20,140 --> 00:58:27,579
mind is okay but you'll see this this

1050
00:58:23,109 --> 00:58:29,880
lowercase L used a lot so so Lib test

1051
00:58:27,579 --> 00:58:35,049
calls a function that's declared in in

1052
00:58:29,880 --> 00:58:37,150
live mind dot a so the linker looks at

1053
00:58:35,049 --> 00:58:39,819
it looked at the unresolved symbols in

1054
00:58:37,150 --> 00:58:41,319
Lib test dot o and it detects that

1055
00:58:39,819 --> 00:58:44,410
there's this unresolved function let's

1056
00:58:41,319 --> 00:58:49,690
say it's called foo I know it's it's

1057
00:58:44,410 --> 00:58:51,520
called lid fun so and it puts it on the

1058
00:58:49,690 --> 00:58:54,579
list and then it goes on to the next

1059
00:58:51,520 --> 00:58:57,940
command line entry and that's lid line

1060
00:58:54,579 --> 00:59:01,380
dot a and in there it finds it finds

1061
00:58:57,940 --> 00:59:04,809
this symbol of live phone and it

1062
00:59:01,380 --> 00:59:07,850
resolves the reference to that - lid

1063
00:59:04,809 --> 00:59:10,760
phone - the actual address

1064
00:59:07,850 --> 00:59:13,520
the relocated address now if we switch

1065
00:59:10,760 --> 00:59:17,000
the order and we we put lib mind on a

1066
00:59:13,520 --> 00:59:18,650
first followed by lib to zero well

1067
00:59:17,000 --> 00:59:20,240
there's there's no unresolved references

1068
00:59:18,650 --> 00:59:24,920
in this library right it's just a

1069
00:59:20,240 --> 00:59:26,900
collection of function definitions so it

1070
00:59:24,920 --> 00:59:28,880
there's no unresolved references so the

1071
00:59:26,900 --> 00:59:31,010
linker looks at that that's all good and

1072
00:59:28,880 --> 00:59:33,350
then it looks at lib test dot oh now

1073
00:59:31,010 --> 00:59:36,230
there's an unresolved reference to to

1074
00:59:33,350 --> 00:59:38,630
live fun but we're out of we're at the

1075
00:59:36,230 --> 00:59:42,620
end of the command line so that's the

1076
00:59:38,630 --> 00:59:46,850
linker err so you get this you get this

1077
00:59:42,620 --> 00:59:48,650
really cryptic error message and if you

1078
00:59:46,850 --> 00:59:53,230
didn't know about this ordering rule you

1079
00:59:48,650 --> 00:59:53,230
wouldn't have any idea how to debug it

1080
00:59:53,440 --> 00:59:57,980
okay so the static libraries are kind of

1081
00:59:56,570 --> 01:00:00,230
the old-fashioned solution that the

1082
00:59:57,980 --> 01:00:05,210
modern solution is to use dynamic

1083
01:00:00,230 --> 01:00:07,610
libraries are shared a shared library so

1084
01:00:05,210 --> 01:00:09,770
the reason the reason there's this sort

1085
01:00:07,610 --> 01:00:12,620
of newer form of libraries that static

1086
01:00:09,770 --> 01:00:17,630
libraries have some some disadvantages

1087
01:00:12,620 --> 01:00:20,210
so every if you compile with static

1088
01:00:17,630 --> 01:00:22,760
libraries then every every function that

1089
01:00:20,210 --> 01:00:24,440
uses print out of which it or every

1090
01:00:22,760 --> 01:00:28,100
program that uses printf has to have a

1091
01:00:24,440 --> 01:00:30,230
copy of printf okay but almost every

1092
01:00:28,100 --> 01:00:33,160
every program uses printf right so

1093
01:00:30,230 --> 01:00:35,270
there's shared shared libraries allow

1094
01:00:33,160 --> 01:00:37,970
provide a mechanism where they can just

1095
01:00:35,270 --> 01:00:43,280
be one wherever there's just one

1096
01:00:37,970 --> 01:00:46,190
instance of a shared library member like

1097
01:00:43,280 --> 01:00:47,960
like printf and and every program

1098
01:00:46,190 --> 01:00:50,590
running on the system will share that

1099
01:00:47,960 --> 01:00:50,590
one copy

1100
01:00:55,310 --> 01:01:00,140
so that's the that's sort of the big big

1101
01:00:58,190 --> 01:01:06,920
disadvantage of this potential

1102
01:01:00,140 --> 01:01:11,170
duplication so shared libraries are

1103
01:01:06,920 --> 01:01:11,170
different in the sense that they contain

1104
01:01:11,740 --> 01:01:17,180
code and data that are linked and loaded

1105
01:01:15,020 --> 01:01:20,540
into the program not when it's not when

1106
01:01:17,180 --> 01:01:23,480
it's compiled and linked and into a

1107
01:01:20,540 --> 01:01:27,080
executable object file but actually when

1108
01:01:23,480 --> 01:01:31,190
the program is loaded into the system so

1109
01:01:27,080 --> 01:01:34,190
linking of references to shared library

1110
01:01:31,190 --> 01:01:36,830
objects is deferred until the program is

1111
01:01:34,190 --> 01:01:39,170
actually loaded into into memory until

1112
01:01:36,830 --> 01:01:41,810
the executable object file is actually

1113
01:01:39,170 --> 01:01:44,810
loaded into memory and this can either

1114
01:01:41,810 --> 01:01:46,550
and it can even happen it can happen

1115
01:01:44,810 --> 01:01:48,970
when the program is actually loaded into

1116
01:01:46,550 --> 01:01:52,280
memory but it can also happen at runtime

1117
01:01:48,970 --> 01:01:54,520
anytime at runtime so you can be you can

1118
01:01:52,280 --> 01:01:57,760
be running a program and that program

1119
01:01:54,520 --> 01:02:00,200
can arbitrarily decide to load a

1120
01:01:57,760 --> 01:02:02,150
function that's declared in a shared

1121
01:02:00,200 --> 01:02:06,140
library okay I'll show you that it's

1122
01:02:02,150 --> 01:02:07,640
really cool now these things are often

1123
01:02:06,140 --> 01:02:09,800
called they're called shared libraries

1124
01:02:07,640 --> 01:02:12,950
they're called dynamic link libraries

1125
01:02:09,800 --> 01:02:14,690
like in Windows they're called DLLs dot

1126
01:02:12,950 --> 01:02:17,200
ISO files they're all referenced the

1127
01:02:14,690 --> 01:02:17,200
same thing

1128
01:02:21,440 --> 01:02:26,940
okay so that just like I said you can be

1129
01:02:24,990 --> 01:02:29,700
the dynamic linking can occur when the

1130
01:02:26,940 --> 01:02:34,859
program's loaded or after it's loaded

1131
01:02:29,700 --> 01:02:36,540
and actually running and there's a sort

1132
01:02:34,859 --> 01:02:38,550
of big deal that shared library routines

1133
01:02:36,540 --> 01:02:40,200
can be shared by multiple processes and

1134
01:02:38,550 --> 01:02:41,550
we'll look at this this will make sense

1135
01:02:40,200 --> 01:02:44,790
when we look at virtual memories so

1136
01:02:41,550 --> 01:02:48,020
don't don't worry about that now but but

1137
01:02:44,790 --> 01:02:48,020
here's how the process works

1138
01:02:49,760 --> 01:02:56,640
so we first we have to create instead of

1139
01:02:53,940 --> 01:03:02,569
creating an archive we create a shared

1140
01:02:56,640 --> 01:03:07,890
library so our lid vector routines

1141
01:03:02,569 --> 01:03:11,119
instead of creating an archive a file we

1142
01:03:07,890 --> 01:03:15,270
create a shared a dot iso file using the

1143
01:03:11,119 --> 01:03:17,970
using the shared argument to GCC so we

1144
01:03:15,270 --> 01:03:21,300
take our two input functions add Zac and

1145
01:03:17,970 --> 01:03:23,400
molbeck and share it says to create and

1146
01:03:21,300 --> 01:03:27,109
we're telling GCC to create a shared

1147
01:03:23,400 --> 01:03:31,040
library and place it in live dr. dot fo

1148
01:03:27,109 --> 01:03:34,410
okay and so and there's also that the

1149
01:03:31,040 --> 01:03:36,810
the C the C developers created a

1150
01:03:34,410 --> 01:03:39,900
function of shared library called Lib C

1151
01:03:36,810 --> 01:03:44,550
so that contains printf and all and

1152
01:03:39,900 --> 01:03:47,010
other standard library functions so we

1153
01:03:44,550 --> 01:03:50,430
take our program main - this is the same

1154
01:03:47,010 --> 01:03:53,550
program that calls adzick and we compile

1155
01:03:50,430 --> 01:03:57,690
it into main to zero and we passed main

1156
01:03:53,550 --> 01:04:03,000
to zero and these dot s0 files to the

1157
01:03:57,690 --> 01:04:06,329
linker now the linker doesn't at this

1158
01:04:03,000 --> 01:04:09,869
point it doesn't actually copy let's say

1159
01:04:06,329 --> 01:04:11,609
we're using advic or printf it doesn't

1160
01:04:09,869 --> 01:04:15,119
actually copy those functions or do

1161
01:04:11,609 --> 01:04:17,400
anything with them in the executable it

1162
01:04:15,119 --> 01:04:21,329
just makes a note in the symbol table

1163
01:04:17,400 --> 01:04:23,010
that those functions will need to be the

1164
01:04:21,329 --> 01:04:25,050
references to those functions will need

1165
01:04:23,010 --> 01:04:27,350
to be resolved when the program is

1166
01:04:25,050 --> 01:04:29,390
loaded okay so it

1167
01:04:27,350 --> 01:04:32,230
it puts in a relocation entry it says

1168
01:04:29,390 --> 01:04:35,570
fix this stuff when you load the program

1169
01:04:32,230 --> 01:04:38,120
so it's partially linked but it's not

1170
01:04:35,570 --> 01:04:39,440
fully linked you can't take that you

1171
01:04:38,120 --> 01:04:43,430
can't take a program

1172
01:04:39,440 --> 01:04:45,860
you can't take a executable file that

1173
01:04:43,430 --> 01:04:52,310
was dynamically linked and load it

1174
01:04:45,860 --> 01:04:54,770
directly what you what you do is the

1175
01:04:52,310 --> 01:04:56,810
loader which is the X X ee system call

1176
01:04:54,770 --> 01:05:00,850
and we'll learn more about that but just

1177
01:04:56,810 --> 01:05:04,030
this is just a sis call that loads loads

1178
01:05:00,850 --> 01:05:08,360
executables into memory and runs them

1179
01:05:04,030 --> 01:05:14,420
the loader takes the executable and then

1180
01:05:08,360 --> 01:05:16,010
it takes the shared data so files that

1181
01:05:14,420 --> 01:05:18,530
this this program needs

1182
01:05:16,010 --> 01:05:22,270
cade also made when the linker also made

1183
01:05:18,530 --> 01:05:22,270
a note of which data so files it needs

1184
01:05:22,300 --> 01:05:29,060
so the loader calls the dynamic linker

1185
01:05:26,150 --> 01:05:31,420
which takes those deso files and then

1186
01:05:29,060 --> 01:05:35,500
actually resolves all the references to

1187
01:05:31,420 --> 01:05:39,830
any unresolved reference ok so the

1188
01:05:35,500 --> 01:05:43,760
address of advic the add vac and printf

1189
01:05:39,830 --> 01:05:47,090
functions isn't determined until the

1190
01:05:43,760 --> 01:05:49,010
program is loaded and by that and it

1191
01:05:47,090 --> 01:05:52,010
isn't determined by the dynamic linker

1192
01:05:49,010 --> 01:05:53,660
until the program is loaded so that the

1193
01:05:52,010 --> 01:05:55,580
dynamic linker does it goes through a

1194
01:05:53,660 --> 01:05:58,130
similar process that the static linker

1195
01:05:55,580 --> 01:06:01,910
did sort of fixing up references to add

1196
01:05:58,130 --> 01:06:05,510
back at references to to printf and then

1197
01:06:01,910 --> 01:06:08,900
at that point the binary the binary is

1198
01:06:05,510 --> 01:06:11,929
in it is in a form that can be executed

1199
01:06:08,900 --> 01:06:15,929
directly so question

1200
01:06:11,929 --> 01:06:17,759
that it can I don't work

1201
01:06:15,929 --> 01:06:20,400
yeah well what if you look at the bottom

1202
01:06:17,759 --> 01:06:22,409
where you'd like weird is that no look

1203
01:06:20,400 --> 01:06:29,640
at you blue violet look at your finger

1204
01:06:22,409 --> 01:06:32,059
and b0s if okay the question is what

1205
01:06:29,640 --> 01:06:34,559
happens if you include a file so

1206
01:06:32,059 --> 01:06:37,109
includes are handled by the C

1207
01:06:34,559 --> 01:06:40,499
preprocessor so they're gone they're

1208
01:06:37,109 --> 01:06:42,869
long gone by the time them by the time

1209
01:06:40,499 --> 01:06:44,699
the linker gets around to it okay so the

1210
01:06:42,869 --> 01:06:49,669
C preprocessor just takes sharp sign

1211
01:06:44,699 --> 01:06:52,169
define sharp sign include and and

1212
01:06:49,669 --> 01:06:55,549
interprets those and outputs another C

1213
01:06:52,169 --> 01:06:58,619
program so if you if you include a file

1214
01:06:55,549 --> 01:07:03,119
the C preprocessor just takes that file

1215
01:06:58,619 --> 01:07:05,099
and just expands it and the output seat

1216
01:07:03,119 --> 01:07:08,269
program contains an expanded version of

1217
01:07:05,099 --> 01:07:08,269
all the files that you included

1218
01:07:11,900 --> 01:07:17,660
now what's really cool is that you can

1219
01:07:15,650 --> 01:07:20,960
also do this dynamic linking at runtime

1220
01:07:17,660 --> 01:07:23,509
so what I showed you before we're doing

1221
01:07:20,960 --> 01:07:28,549
it at load time but you can also

1222
01:07:23,509 --> 01:07:32,109
arbitrarily decide to to load link and

1223
01:07:28,549 --> 01:07:35,420
call a function from a shared from a

1224
01:07:32,109 --> 01:07:38,990
from any function defined in a dot iso

1225
01:07:35,420 --> 01:07:42,549
file and the way you do it is there's a

1226
01:07:38,990 --> 01:07:45,710
there's an interface called dl open

1227
01:07:42,549 --> 01:07:48,829
that's in Lib C that allows you to do

1228
01:07:45,710 --> 01:07:52,160
this and so let's say we want to this is

1229
01:07:48,829 --> 01:07:54,799
this is our main program and just like

1230
01:07:52,160 --> 01:07:57,920
before we want to call adzick okay but

1231
01:07:54,799 --> 01:08:01,160
advic now is defined in it in a dot iso

1232
01:07:57,920 --> 01:08:05,660
file the exact same dot SL file that we

1233
01:08:01,160 --> 01:08:07,940
generated before when we compile so

1234
01:08:05,660 --> 01:08:12,980
we'll call this dll C when we compile

1235
01:08:07,940 --> 01:08:14,920
this program DLL dot C we have no we

1236
01:08:12,980 --> 01:08:20,870
have no idea that it's going to call a

1237
01:08:14,920 --> 01:08:24,440
function from from lib dr. D so we just

1238
01:08:20,870 --> 01:08:27,409
compile it as those standalone C C

1239
01:08:24,440 --> 01:08:29,600
program within this program though we

1240
01:08:27,409 --> 01:08:32,299
declare a pointer a function pointer

1241
01:08:29,600 --> 01:08:36,589
called advic and we give the prototype

1242
01:08:32,299 --> 01:08:39,440
for this function its pointers cities so

1243
01:08:36,589 --> 01:08:43,219
it's two input arrays the output array

1244
01:08:39,440 --> 01:08:45,560
on the size and then first we

1245
01:08:43,219 --> 01:08:48,799
dynamically load the shared library that

1246
01:08:45,560 --> 01:08:54,080
contains the function we want so we call

1247
01:08:48,799 --> 01:08:57,319
DL open and we say load up this this dot

1248
01:08:54,080 --> 01:09:01,909
s L file into memory so that I can call

1249
01:08:57,319 --> 01:09:03,500
a function but don't resolve you know

1250
01:09:01,909 --> 01:09:05,449
don't worry don't worry about the

1251
01:09:03,500 --> 01:09:08,839
resolving the references to functions

1252
01:09:05,449 --> 01:09:13,520
until I actually tell you - that's the

1253
01:09:08,839 --> 01:09:17,239
lazy part and so what what this deal

1254
01:09:13,520 --> 01:09:20,779
open returns a handle that that then you

1255
01:09:17,239 --> 01:09:22,549
use in subsequent calls okay so if we

1256
01:09:20,779 --> 01:09:24,949
don't if the handle as no there was some

1257
01:09:22,549 --> 01:09:27,819
kind of error like maybe maybe this data

1258
01:09:24,949 --> 01:09:27,819
so file doesn't exist

1259
01:09:28,060 --> 01:09:34,819
so once we've opened that data so file

1260
01:09:30,739 --> 01:09:38,659
then we use DL cm with the handle so

1261
01:09:34,819 --> 01:09:40,699
this and then we we give it as we passes

1262
01:09:38,659 --> 01:09:45,560
a string the name of the function that

1263
01:09:40,699 --> 01:09:48,259
we want to invoke and we get what we get

1264
01:09:45,560 --> 01:09:51,469
back from the L sent as a pointer to

1265
01:09:48,259 --> 01:09:52,909
that function and then we can we can use

1266
01:09:51,469 --> 01:09:54,440
that function just like any other

1267
01:09:52,909 --> 01:09:56,690
function so we can use that function

1268
01:09:54,440 --> 01:09:59,110
pointer and we call it just as Ella

1269
01:09:56,690 --> 01:10:01,670
where it's statically defined function

1270
01:09:59,110 --> 01:10:13,340
so you can see this is real very

1271
01:10:01,670 --> 01:10:15,949
powerful technique okay so let's let's

1272
01:10:13,340 --> 01:10:18,260
finish the last little bit of the class

1273
01:10:15,949 --> 01:10:19,940
I want to show you it to try to convince

1274
01:10:18,260 --> 01:10:21,710
you that linking is is actually

1275
01:10:19,940 --> 01:10:30,730
interesting which is kind of a hard sell

1276
01:10:21,710 --> 01:10:30,730
sometime yes question yes

1277
01:10:32,260 --> 01:10:39,020
no it's that's how now you just it's

1278
01:10:37,159 --> 01:10:42,320
it's declared as a function pointer and

1279
01:10:39,020 --> 01:10:43,429
you then you just you just you just use

1280
01:10:42,320 --> 01:10:47,030
the name of the function

1281
01:10:43,429 --> 01:10:48,860
you have to dereference it or you just

1282
01:10:47,030 --> 01:10:53,090
you call it you call the function by

1283
01:10:48,860 --> 01:10:57,340
just using that that that function

1284
01:10:53,090 --> 01:10:57,340
pointer name okay just like I did

1285
01:11:00,709 --> 01:11:06,349
if you dereference it I just get back a

1286
01:11:03,170 --> 01:11:11,570
pointer value you get back the address

1287
01:11:06,349 --> 01:11:15,170
of that function all right so it's kind

1288
01:11:11,570 --> 01:11:17,150
of a hard sell to that to convention of

1289
01:11:15,170 --> 01:11:20,209
linking is is interesting but I'm going

1290
01:11:17,150 --> 01:11:22,820
to try ok so there's there's this

1291
01:11:20,209 --> 01:11:25,519
powerful technique called in library

1292
01:11:22,820 --> 01:11:28,489
inter positioning and the goal is to

1293
01:11:25,519 --> 01:11:32,329
intercept function calls from from

1294
01:11:28,489 --> 01:11:35,929
libraries and do something intercept

1295
01:11:32,329 --> 01:11:37,670
them for some reason right so what we

1296
01:11:35,929 --> 01:11:41,360
typically want to do is intercept the

1297
01:11:37,670 --> 01:11:43,280
function call maybe record some to some

1298
01:11:41,360 --> 01:11:46,639
statistics or do some error checking and

1299
01:11:43,280 --> 01:11:49,189
then call the real function as intended

1300
01:11:46,639 --> 01:11:55,880
right so so the idea is we're going to

1301
01:11:49,189 --> 01:11:58,340
create wrappers and when the program

1302
01:11:55,880 --> 01:11:59,329
when a program calls a function what

1303
01:11:58,340 --> 01:12:03,439
we're going to do is we're going to

1304
01:11:59,329 --> 01:12:04,639
execute its wrapper instead okay and

1305
01:12:03,439 --> 01:12:07,449
we're going to do it without changing

1306
01:12:04,639 --> 01:12:07,449
any of the source

1307
01:12:10,240 --> 01:12:14,570
now there there's a lot of reasons

1308
01:12:12,770 --> 01:12:18,740
there's a lot of applications for this

1309
01:12:14,570 --> 01:12:22,250
that the neatest ones that that I know

1310
01:12:18,740 --> 01:12:24,200
is that these facebook engineers so

1311
01:12:22,250 --> 01:12:26,860
we're trying to deal with this year-long

1312
01:12:24,200 --> 01:12:28,850
blog in the Facebook iPhone app and

1313
01:12:26,860 --> 01:12:32,210
nobody could figure out what was going

1314
01:12:28,850 --> 01:12:34,760
on and they figured it out using library

1315
01:12:32,210 --> 01:12:36,860
inter positioning they figured out that

1316
01:12:34,760 --> 01:12:38,810
there was something in the network stack

1317
01:12:36,860 --> 01:12:41,030
writing to the wrong location they

1318
01:12:38,810 --> 01:12:44,120
figured it out by intercepting all the

1319
01:12:41,030 --> 01:12:47,540
calls from their Facebook app that did

1320
01:12:44,120 --> 01:12:50,540
rights so things like right right to the

1321
01:12:47,540 --> 01:12:51,890
EP right so they just they intercepted

1322
01:12:50,540 --> 01:12:53,750
all those calls and then they were able

1323
01:12:51,890 --> 01:12:55,100
to when they looked at the arguments and

1324
01:12:53,750 --> 01:13:01,730
how those functions were being called

1325
01:12:55,100 --> 01:13:03,770
they determine the error you can also

1326
01:13:01,730 --> 01:13:04,910
use it for monitoring and profiling like

1327
01:13:03,770 --> 01:13:07,010
so if you want to know like how many

1328
01:13:04,910 --> 01:13:10,820
times different functions get calls you

1329
01:13:07,010 --> 01:13:14,180
can you can do you can interpose we use

1330
01:13:10,820 --> 01:13:17,570
it for for generating address traces so

1331
01:13:14,180 --> 01:13:19,550
your Malak when you do your malik labs

1332
01:13:17,570 --> 01:13:24,050
later in the semester you're going to be

1333
01:13:19,550 --> 01:13:26,180
evaluating your malik using a traces

1334
01:13:24,050 --> 01:13:28,580
that we generated from real programs

1335
01:13:26,180 --> 01:13:31,010
using this inter positioning technique

1336
01:13:28,580 --> 01:13:33,950
alright so we we enter post on all the

1337
01:13:31,010 --> 01:13:38,210
malloc and free calls in like netscape

1338
01:13:33,950 --> 01:13:42,470
ID and then we just recorded what

1339
01:13:38,210 --> 01:13:45,470
addresses and and sizes Malik was was

1340
01:13:42,470 --> 01:13:47,630
returning and what what blocks free was

1341
01:13:45,470 --> 01:13:52,220
freeing up and we just created a trace

1342
01:13:47,630 --> 01:13:56,060
of those and and then so let me show you

1343
01:13:52,220 --> 01:13:57,800
how you would do this so the idea let's

1344
01:13:56,060 --> 01:14:00,380
say we have this main program and the

1345
01:13:57,800 --> 01:14:02,150
idea is to trace all the malloc and free

1346
01:14:00,380 --> 01:14:04,880
calls so there's one malloc call and

1347
01:14:02,150 --> 01:14:06,890
there's one free call and we want to

1348
01:14:04,880 --> 01:14:09,980
know what these addresses are and we

1349
01:14:06,890 --> 01:14:11,990
want to know what these sizes are so we

1350
01:14:09,980 --> 01:14:15,950
can do this at either compile time link

1351
01:14:11,990 --> 01:14:19,220
time or run time to do it at compile

1352
01:14:15,950 --> 01:14:22,100
time we first write wrapper functions

1353
01:14:19,220 --> 01:14:23,460
called my malloc and my free where my

1354
01:14:22,100 --> 01:14:25,800
malloc call

1355
01:14:23,460 --> 01:14:29,280
the real malloc function and then it

1356
01:14:25,800 --> 01:14:31,950
prints out the size that it was called

1357
01:14:29,280 --> 01:14:34,920
and the address that malloc returned

1358
01:14:31,950 --> 01:14:36,330
okay so this when we run our program it

1359
01:14:34,920 --> 01:14:37,860
will it will print out these all these

1360
01:14:36,330 --> 01:14:42,000
addresses and it does the same thing for

1361
01:14:37,860 --> 01:14:47,810
free and then here's the trick in malloc

1362
01:14:42,000 --> 01:14:51,240
H we we define malloc to be my malloc

1363
01:14:47,810 --> 01:14:53,100
okay and free to be my free and then we

1364
01:14:51,240 --> 01:14:55,620
give the prototype for it so the

1365
01:14:53,100 --> 01:14:58,470
compiler doesn't get confused and then

1366
01:14:55,620 --> 01:15:02,730
we compile compile my malloc C into a

1367
01:14:58,470 --> 01:15:07,520
dot o file and then we call week then we

1368
01:15:02,730 --> 01:15:11,190
complete we call our program which is is

1369
01:15:07,520 --> 01:15:14,550
our main program int duxi for inner

1370
01:15:11,190 --> 01:15:18,330
positioning and we call that and here's

1371
01:15:14,550 --> 01:15:21,570
the trick we call it with the - cap I

1372
01:15:18,330 --> 01:15:24,030
argument and we say look for any include

1373
01:15:21,570 --> 01:15:30,230
files in the current directory okay so

1374
01:15:24,030 --> 01:15:34,980
this was similar to that l - CapTel

1375
01:15:30,230 --> 01:15:37,320
argument but because we tell GCC to look

1376
01:15:34,980 --> 01:15:38,670
in the current directory first so this

1377
01:15:37,320 --> 01:15:42,500
is sort of where the inner positioning

1378
01:15:38,670 --> 01:15:47,220
happens just because when it does that

1379
01:15:42,500 --> 01:15:49,260
it's going to it's going to find a it's

1380
01:15:47,220 --> 01:15:52,620
going to find a library called malloc H

1381
01:15:49,260 --> 01:15:55,670
I mean a dot H file called malloc dot H

1382
01:15:52,620 --> 01:15:58,110
and so all the calls to malloc will be

1383
01:15:55,670 --> 01:16:04,080
translated by the C preprocessor to my

1384
01:15:58,110 --> 01:16:08,030
malloc so when we run this it prints out

1385
01:16:04,080 --> 01:16:08,030
the the trip malloc and free trace

1386
01:16:08,700 --> 01:16:13,980
now we can also do this at link time so

1387
01:16:11,010 --> 01:16:16,770
we can tell see in order to do this we

1388
01:16:13,980 --> 01:16:18,510
had to get access to the we had to

1389
01:16:16,770 --> 01:16:21,420
compile the program we didn't have to

1390
01:16:18,510 --> 01:16:24,110
change it but we had to compile it we

1391
01:16:21,420 --> 01:16:28,790
can use link time that are positioning

1392
01:16:24,110 --> 01:16:31,620
its to avoid that that that compilation

1393
01:16:28,790 --> 01:16:33,600
so the way this works we define our

1394
01:16:31,620 --> 01:16:35,720
wrapper functions with this special name

1395
01:16:33,600 --> 01:16:38,490
underscore underscore wrap malloc and

1396
01:16:35,720 --> 01:16:42,630
this calls the real malloc function and

1397
01:16:38,490 --> 01:16:44,880
then prints out the information and then

1398
01:16:42,630 --> 01:16:48,060
at link time then we do the inter

1399
01:16:44,880 --> 01:16:49,470
positioning by calling the linker with

1400
01:16:48,060 --> 01:16:54,540
this special

1401
01:16:49,470 --> 01:17:00,510
- WL argument and so what this does the

1402
01:16:54,540 --> 01:17:02,760
- WL flag to GCC says hey take what

1403
01:17:00,510 --> 01:17:06,420
follows the argument that follows or

1404
01:17:02,760 --> 01:17:08,220
place all the commas with spaces and

1405
01:17:06,420 --> 01:17:09,870
then invoke the linker with this

1406
01:17:08,220 --> 01:17:12,570
argument okay so what we're doing is

1407
01:17:09,870 --> 01:17:16,790
passing a linker arguments to the linker

1408
01:17:12,570 --> 01:17:21,900
and this - - wrap argument to the linker

1409
01:17:16,790 --> 01:17:23,760
it tells the linker to resolve all

1410
01:17:21,900 --> 01:17:26,430
references to malloc as the underscore

1411
01:17:23,760 --> 01:17:29,960
underscore wrap malloc and all

1412
01:17:26,430 --> 01:17:34,200
references to underscore real malloc -

1413
01:17:29,960 --> 01:17:35,730
should be resolved as malloc okay so

1414
01:17:34,200 --> 01:17:37,830
anywhere in the program where we call

1415
01:17:35,730 --> 01:17:39,840
malloc it will be resolved to underscore

1416
01:17:37,830 --> 01:17:42,030
underscore wrap malloc and it will

1417
01:17:39,840 --> 01:17:46,740
invoke our wrapper and then the wrapper

1418
01:17:42,030 --> 01:17:51,150
calls real malloc which which by because

1419
01:17:46,740 --> 01:17:55,470
of this flag resolves to the actual

1420
01:17:51,150 --> 01:17:57,300
malloc routine now here you can also in

1421
01:17:55,470 --> 01:17:58,800
the really the really amazing thing is

1422
01:17:57,300 --> 01:18:01,680
you can also do this inter positioning

1423
01:17:58,800 --> 01:18:03,210
it load timer and run time when the

1424
01:18:01,680 --> 01:18:05,130
program is loaded so you don't even need

1425
01:18:03,210 --> 01:18:08,430
access to the dot o files all you need

1426
01:18:05,130 --> 01:18:10,140
is access to the executable right and

1427
01:18:08,430 --> 01:18:12,540
for every program we've access to the

1428
01:18:10,140 --> 01:18:15,570
executable so think about that we can

1429
01:18:12,540 --> 01:18:19,590
take any program and we can interpose on

1430
01:18:15,570 --> 01:18:22,230
its library calls at runtime

1431
01:18:19,590 --> 01:18:25,740
so the way we do this is we write the

1432
01:18:22,230 --> 01:18:29,640
wrapper function now uses the DL sim

1433
01:18:25,740 --> 01:18:32,010
call that we saw before and we call it

1434
01:18:29,640 --> 01:18:32,790
with a special function the special

1435
01:18:32,010 --> 01:18:37,860
argument called

1436
01:18:32,790 --> 01:18:39,930
next and we silver and what this is

1437
01:18:37,860 --> 01:18:43,260
saying is get the address of the real

1438
01:18:39,930 --> 01:18:44,610
knowledge okay so and what we're going

1439
01:18:43,260 --> 01:18:48,750
to we're going to trick the linker into

1440
01:18:44,610 --> 01:18:51,720
looking first to our our implementation

1441
01:18:48,750 --> 01:18:53,550
of malloc but here we want the real one

1442
01:18:51,720 --> 01:18:55,680
so we're telling it to get to look in

1443
01:18:53,550 --> 01:18:59,700
the next place its next place that it

1444
01:18:55,680 --> 01:19:01,860
would normally look and and fetch the

1445
01:18:59,700 --> 01:19:04,920
the address of malloc so the result is a

1446
01:19:01,860 --> 01:19:07,080
pointer a function pointer called malloc

1447
01:19:04,920 --> 01:19:10,920
T and then we can just call that

1448
01:19:07,080 --> 01:19:14,730
function to get to call the Lipsy malloc

1449
01:19:10,920 --> 01:19:18,840
and then print out the data okay we do

1450
01:19:14,730 --> 01:19:21,410
the same thing for free say we use DF m

1451
01:19:18,840 --> 01:19:24,560
in exactly the same way for free and

1452
01:19:21,410 --> 01:19:28,860
then the inter positioning now happens

1453
01:19:24,560 --> 01:19:31,830
when the program is loaded so notice we

1454
01:19:28,860 --> 01:19:34,940
built this our main program now int our

1455
01:19:31,830 --> 01:19:38,340
for runtime in a positioning we built it

1456
01:19:34,940 --> 01:19:42,320
I'm sorry we created our dot SL file my

1457
01:19:38,340 --> 01:19:46,830
Malachy so using the shared argument and

1458
01:19:42,320 --> 01:19:49,770
then and then we we compiled int int dot

1459
01:19:46,830 --> 01:19:52,080
C into this executable called int R but

1460
01:19:49,770 --> 01:19:56,520
notice there's no mention of my malloc

1461
01:19:52,080 --> 01:19:58,350
dot SL anywhere and now the inner

1462
01:19:56,520 --> 01:20:04,680
positioning happens when we actually run

1463
01:19:58,350 --> 01:20:06,900
the program and we do we we affect the

1464
01:20:04,680 --> 01:20:11,150
the inner positioning by setting an

1465
01:20:06,900 --> 01:20:16,560
environment variable called LD preload

1466
01:20:11,150 --> 01:20:18,360
to my Malachy so and so well this is a

1467
01:20:16,560 --> 01:20:21,930
environment variable to tell us the

1468
01:20:18,360 --> 01:20:24,960
dynamic linker to look first in the

1469
01:20:21,930 --> 01:20:28,260
value it looked first in the value of LD

1470
01:20:24,960 --> 01:20:30,360
preload is a list of locations look

1471
01:20:28,260 --> 01:20:33,150
first in those locations when to resolve

1472
01:20:30,360 --> 01:20:33,430
references and only only later look in

1473
01:20:33,150 --> 01:20:36,700
the

1474
01:20:33,430 --> 01:20:39,100
the normal system places so we're saying

1475
01:20:36,700 --> 01:20:41,650
to look in my Malik dot so4 unresolved

1476
01:20:39,100 --> 01:20:43,480
references first and then and then we're

1477
01:20:41,650 --> 01:20:45,460
invoking so this isn't bash this is how

1478
01:20:43,480 --> 01:20:47,680
you initialize an environment variable

1479
01:20:45,460 --> 01:20:50,110
so we're initializing it to my Malik

1480
01:20:47,680 --> 01:20:55,690
data so and then we're loading and

1481
01:20:50,110 --> 01:20:58,990
running the program and so the LD so all

1482
01:20:55,690 --> 01:21:01,860
the references to Malik get turned into

1483
01:20:58,990 --> 01:21:05,980
the references to the rapper function

1484
01:21:01,860 --> 01:21:11,410
the Malik function that we defined in in

1485
01:21:05,980 --> 01:21:12,910
our program ok so that's a so that's it

1486
01:21:11,410 --> 01:21:15,400
so that that inter positioning is a

1487
01:21:12,910 --> 01:21:18,030
really cool technique and it's only it's

1488
01:21:15,400 --> 01:21:19,630
only possible because of linkers so

1489
01:21:18,030 --> 01:21:22,150
alright so good

1490
01:21:19,630 --> 01:21:25,260
we'll see you on on Thursday and good

1491
01:21:22,150 --> 01:21:25,260
luck with your cash life

