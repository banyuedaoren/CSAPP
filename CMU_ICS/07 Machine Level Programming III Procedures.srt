1
00:00:00,000 --> 00:00:05,850
we're still slogging through the

2
00:00:02,179 --> 00:00:08,790
material on machine level programming

3
00:00:05,850 --> 00:00:10,889
which is I talked to you earlier I think

4
00:00:08,790 --> 00:00:13,410
is in some ways the core of this course

5
00:00:10,889 --> 00:00:16,710
that much of the rest of material builds

6
00:00:13,410 --> 00:00:20,490
upon and hopefully you've all had a

7
00:00:16,710 --> 00:00:23,070
chance to check out lab - and your bomb

8
00:00:20,490 --> 00:00:25,800
lab and you've gotten started on that

9
00:00:23,070 --> 00:00:27,570
and certainly by the time you're

10
00:00:25,800 --> 00:00:30,300
finished with the material from today

11
00:00:27,570 --> 00:00:33,300
you will be well on the way to solving

12
00:00:30,300 --> 00:00:36,410
all but the last one or two stages of

13
00:00:33,300 --> 00:00:39,120
the bomb web so I highly recommend you

14
00:00:36,410 --> 00:00:43,739
get going on that not put it off to the

15
00:00:39,120 --> 00:00:48,239
last minute so and what we're talking

16
00:00:43,739 --> 00:00:50,070
about today is is how procedures proceed

17
00:00:48,239 --> 00:00:50,879
I'm going to use the same terminology

18
00:00:50,070 --> 00:00:54,360
here

19
00:00:50,879 --> 00:00:56,730
whether it's a function a procedure or

20
00:00:54,360 --> 00:00:59,309
an object-oriented programming a method

21
00:00:56,730 --> 00:01:01,020
those are all roughly the same thing and

22
00:00:59,309 --> 00:01:03,829
what we'll talk about covers them

23
00:01:01,020 --> 00:01:03,829
overall

24
00:01:09,240 --> 00:01:16,270
I'll also mention at the outset that the

25
00:01:13,150 --> 00:01:18,040
way this is handled in the procedures

26
00:01:16,270 --> 00:01:21,460
that we'll be talking about today is a

27
00:01:18,040 --> 00:01:25,000
combination of the actual x86 hardware

28
00:01:21,460 --> 00:01:27,010
and how it supports it but also in some

29
00:01:25,000 --> 00:01:30,090
ways more importantly a set of

30
00:01:27,010 --> 00:01:32,950
conventions that were developed that

31
00:01:30,090 --> 00:01:36,450
basically everyone agreed to and it's

32
00:01:32,950 --> 00:01:39,310
known as an ABI that's why I want to

33
00:01:36,450 --> 00:01:51,220
wood stands for application binary

34
00:01:39,310 --> 00:01:55,300
interface so the idea is the document

35
00:01:51,220 --> 00:01:58,840
you can get it online it's and it's

36
00:01:55,300 --> 00:02:01,570
cited in the book it's the document that

37
00:01:58,840 --> 00:02:05,170
people put together the initial version

38
00:02:01,570 --> 00:02:08,050
when the first x86 64 machines were

39
00:02:05,170 --> 00:02:10,840
first being developed and specifically

40
00:02:08,050 --> 00:02:15,220
for Linux they said ok all Linux

41
00:02:10,840 --> 00:02:17,410
programs that all compilers all the

42
00:02:15,220 --> 00:02:20,350
operating system all the different parts

43
00:02:17,410 --> 00:02:22,690
of a system that need to have some

44
00:02:20,350 --> 00:02:25,540
common understanding of how to manage

45
00:02:22,690 --> 00:02:29,310
the resources on the machine will agree

46
00:02:25,540 --> 00:02:32,050
to adhere to this set of rules and so it

47
00:02:29,310 --> 00:02:34,480
it goes beyond the actual what the

48
00:02:32,050 --> 00:02:37,090
hardware does to a set of software

49
00:02:34,480 --> 00:02:38,620
standards and it's called application

50
00:02:37,090 --> 00:02:40,870
binary interface because it's

51
00:02:38,620 --> 00:02:43,140
particularly the interface at the

52
00:02:40,870 --> 00:02:46,780
Machine level machine level programming

53
00:02:43,140 --> 00:02:49,150
the machine program level and so that's

54
00:02:46,780 --> 00:02:51,610
what we'll be covering today so people

55
00:02:49,150 --> 00:02:53,470
asked sort of well you know who makes up

56
00:02:51,610 --> 00:02:55,030
these rules and things and the point was

57
00:02:53,470 --> 00:02:57,850
there was a working group that did this

58
00:02:55,030 --> 00:03:00,489
and there's a separate ABI for Windows

59
00:02:57,850 --> 00:03:04,239
it's similar but not quite the same

60
00:03:00,489 --> 00:03:08,560
there's a separate ABI for OSX for Apple

61
00:03:04,239 --> 00:03:11,560
and even FreeBSD a different variant of

62
00:03:08,560 --> 00:03:14,320
a unix-like operating system has its own

63
00:03:11,560 --> 00:03:18,660
ABI that they all share a lot in common

64
00:03:14,320 --> 00:03:18,660
but some of the details differ

65
00:03:19,540 --> 00:03:24,530
so if you think about what goes on in a

66
00:03:22,550 --> 00:03:27,410
procedure even in C which is a

67
00:03:24,530 --> 00:03:31,069
relatively unsophisticated language in

68
00:03:27,410 --> 00:03:32,810
many ways there's a lot going on and so

69
00:03:31,069 --> 00:03:34,880
it's worth breaking down those and

70
00:03:32,810 --> 00:03:37,670
thinking about it one is there's a

71
00:03:34,880 --> 00:03:40,640
notion of control so in my example I

72
00:03:37,670 --> 00:03:45,160
show a procedure P calling a procedure Q

73
00:03:40,640 --> 00:03:48,410
and so when when P calls Q then somehow

74
00:03:45,160 --> 00:03:51,950
the program has to jump down and begin

75
00:03:48,410 --> 00:03:55,910
executing the the lines of code for Q

76
00:03:51,950 --> 00:03:58,730
and then when Q hits its exit point it's

77
00:03:55,910 --> 00:04:01,610
returned point somehow is to get back to

78
00:03:58,730 --> 00:04:04,519
P and not just to any old place in P but

79
00:04:01,610 --> 00:04:07,730
specifically to whatever it came comes

80
00:04:04,519 --> 00:04:09,980
in P right after the call to Q so

81
00:04:07,730 --> 00:04:11,840
somehow we have to record the

82
00:04:09,980 --> 00:04:14,330
information about where the return

83
00:04:11,840 --> 00:04:16,810
should be to be able to return to the

84
00:04:14,330 --> 00:04:20,480
correct place so that's first of all

85
00:04:16,810 --> 00:04:22,190
passing control to a function and having

86
00:04:20,480 --> 00:04:25,720
that function return back to where it

87
00:04:22,190 --> 00:04:29,570
should get back to our second lose data

88
00:04:25,720 --> 00:04:32,120
how do we get operands to it so in this

89
00:04:29,570 --> 00:04:34,430
particular case Q is a function that

90
00:04:32,120 --> 00:04:37,490
takes a single argument that it calls

91
00:04:34,430 --> 00:04:40,370
internally it calls i and up here where

92
00:04:37,490 --> 00:04:43,970
p is calling it it's passing some value

93
00:04:40,370 --> 00:04:47,390
within p called X so hump somehow that

94
00:04:43,970 --> 00:04:50,330
data value of X has to be recorded in a

95
00:04:47,390 --> 00:04:54,680
form that within Q it will have access

96
00:04:50,330 --> 00:04:59,030
to that information and similarly when q

97
00:04:54,680 --> 00:05:01,010
wants to return a value back up and then

98
00:04:59,030 --> 00:05:03,310
P will make use of that value there has

99
00:05:01,010 --> 00:05:08,120
to be some convention of how that data

100
00:05:03,310 --> 00:05:12,130
gets communicated back and then finally

101
00:05:08,120 --> 00:05:15,740
in a function might have some local data

102
00:05:12,130 --> 00:05:18,229
that requires allocation of some amount

103
00:05:15,740 --> 00:05:20,150
of space and so where does that space

104
00:05:18,229 --> 00:05:23,060
get allocated how do we make sure it

105
00:05:20,150 --> 00:05:25,150
gets allocated properly in particular in

106
00:05:23,060 --> 00:05:29,000
C as you know when a function returns

107
00:05:25,150 --> 00:05:31,460
any local data that it allocated should

108
00:05:29,000 --> 00:05:34,250
get D allocated should be freed

109
00:05:31,460 --> 00:05:37,340
so that we don't sort of start consuming

110
00:05:34,250 --> 00:05:39,170
an unbounded amount of storage so how do

111
00:05:37,340 --> 00:05:42,080
we do that those are all the sort of

112
00:05:39,170 --> 00:05:45,220
different aspects that a procedure call

113
00:05:42,080 --> 00:05:47,420
and return have to deal with somehow and

114
00:05:45,220 --> 00:05:51,970
part of the reason for breaking it down

115
00:05:47,420 --> 00:05:55,010
into those little segments is in x86 64

116
00:05:51,970 --> 00:05:57,830
one of the clever things they did was to

117
00:05:55,010 --> 00:05:59,450
try and reduce the overhead of procedure

118
00:05:57,830 --> 00:06:02,150
calls as much as possible

119
00:05:59,450 --> 00:06:05,660
because as you know in good programming

120
00:06:02,150 --> 00:06:08,060
style you often write these functions

121
00:06:05,660 --> 00:06:11,690
that do a fairly small amount of actual

122
00:06:08,060 --> 00:06:13,850
useful stuff and it's sort of good

123
00:06:11,690 --> 00:06:15,740
programming style to do that especially

124
00:06:13,850 --> 00:06:18,470
in a more object-oriented programming

125
00:06:15,740 --> 00:06:20,480
style and so you don't want the overhead

126
00:06:18,470 --> 00:06:22,760
the extra number of steps taken to

127
00:06:20,480 --> 00:06:23,780
invoke a procedure and deal with all

128
00:06:22,760 --> 00:06:27,020
that it's a SPECT

129
00:06:23,780 --> 00:06:30,430
to take any more time than it needs to

130
00:06:27,020 --> 00:06:33,920
because it's a fairly critical overhead

131
00:06:30,430 --> 00:06:36,950
so one of the things they do in in this

132
00:06:33,920 --> 00:06:40,040
is they only do whatever is absolutely

133
00:06:36,950 --> 00:06:43,430
needed so for in particular if no local

134
00:06:40,040 --> 00:06:45,200
storage is needed on this for data then

135
00:06:43,430 --> 00:06:47,900
don't allocate it and therefore don't

136
00:06:45,200 --> 00:06:51,650
free it if you're not passing any values

137
00:06:47,900 --> 00:06:54,230
don't pass them and in general sort of

138
00:06:51,650 --> 00:06:55,940
how little can you get away with and

139
00:06:54,230 --> 00:06:58,730
that makes it a little bit confusing

140
00:06:55,940 --> 00:07:00,890
from a teaching point of view and that

141
00:06:58,730 --> 00:07:03,530
there's no set template that it follows

142
00:07:00,890 --> 00:07:05,870
every time it's sort of you have to each

143
00:07:03,530 --> 00:07:11,330
case is a special case for how a

144
00:07:05,870 --> 00:07:14,090
particular procedure gets implemented so

145
00:07:11,330 --> 00:07:15,950
we'll go through all these parts and see

146
00:07:14,090 --> 00:07:18,320
how they happen and you've already seen

147
00:07:15,950 --> 00:07:19,790
little glimpses of them we'll get the

148
00:07:18,320 --> 00:07:24,710
little fragments of code that we've

149
00:07:19,790 --> 00:07:26,510
shown already so the first one and sort

150
00:07:24,710 --> 00:07:30,020
of the most critical is how do we pass

151
00:07:26,510 --> 00:07:31,640
control to a function but before we can

152
00:07:30,020 --> 00:07:34,790
even talk about that we have to talk

153
00:07:31,640 --> 00:07:38,600
about the stack so and you've heard that

154
00:07:34,790 --> 00:07:41,390
term the stack in various ways the stack

155
00:07:38,600 --> 00:07:44,420
is really not a special memory it's just

156
00:07:41,390 --> 00:07:48,230
a region of the normal memory remember

157
00:07:44,420 --> 00:07:51,230
to the programmers perspective assembly

158
00:07:48,230 --> 00:07:53,380
level programmers perspective is memory

159
00:07:51,230 --> 00:07:56,180
is just a big array of bytes and

160
00:07:53,380 --> 00:07:59,180
somewhere within that bunch of bytes

161
00:07:56,180 --> 00:08:01,910
we're going to call it the stack and the

162
00:07:59,180 --> 00:08:05,090
stack is used by the program to manage

163
00:08:01,910 --> 00:08:08,420
the state associated with the procedures

164
00:08:05,090 --> 00:08:11,570
that it calls and as they return so it's

165
00:08:08,420 --> 00:08:15,010
where it passes all these potential

166
00:08:11,570 --> 00:08:19,460
information the the control information

167
00:08:15,010 --> 00:08:21,440
data and allocates local data and the

168
00:08:19,460 --> 00:08:24,530
reason why it can be managed is a stack

169
00:08:21,440 --> 00:08:26,690
is because of the nature of the whole

170
00:08:24,530 --> 00:08:29,420
idea of procedure calls and returns that

171
00:08:26,690 --> 00:08:31,910
you make a call and you might need some

172
00:08:29,420 --> 00:08:34,220
information but when you return from a

173
00:08:31,910 --> 00:08:38,000
call all that information can be

174
00:08:34,220 --> 00:08:40,760
discarded and so it makes use of that

175
00:08:38,000 --> 00:08:43,160
sort of last in first out allocation

176
00:08:40,760 --> 00:08:47,260
principle mesh is very well with this

177
00:08:43,160 --> 00:08:52,070
idea of procedure call and return so in

178
00:08:47,260 --> 00:08:55,570
x86 stacks actually start with a very

179
00:08:52,070 --> 00:08:59,180
high numbered address and when they grow

180
00:08:55,570 --> 00:09:02,480
when more data are allocated for this

181
00:08:59,180 --> 00:09:05,510
deck it's done by decrementing the stack

182
00:09:02,480 --> 00:09:08,990
pointer so the stack pointer as you know

183
00:09:05,510 --> 00:09:11,840
is just a regular register RSP and its

184
00:09:08,990 --> 00:09:14,660
value is the address of the current top

185
00:09:11,840 --> 00:09:16,700
of the stack and every time you allocate

186
00:09:14,660 --> 00:09:19,970
more space on the stack it does it by

187
00:09:16,700 --> 00:09:24,260
decrementing that pointer now just for a

188
00:09:19,970 --> 00:09:26,830
convention and I'm not sure why this

189
00:09:24,260 --> 00:09:30,410
happens but this is the way we do it is

190
00:09:26,830 --> 00:09:34,580
we draw stacks upside down so that the

191
00:09:30,410 --> 00:09:37,540
term the top of the stack is actually

192
00:09:34,580 --> 00:09:37,540
shown at the bottom

193
00:09:37,870 --> 00:09:46,150
and just to add to that confusion and

194
00:09:42,190 --> 00:09:47,320
also remember that the addresses go from

195
00:09:46,150 --> 00:09:49,630
bottom to top

196
00:09:47,320 --> 00:09:51,910
not from top to bottom so when you add

197
00:09:49,630 --> 00:09:54,520
to the stack you decrement the stack

198
00:09:51,910 --> 00:09:57,430
pointer neither of those kind of meshes

199
00:09:54,520 --> 00:09:59,440
with your intuition perhaps but you just

200
00:09:57,430 --> 00:10:04,750
have to get used to it because we're not

201
00:09:59,440 --> 00:10:08,350
going to redraw out all this one so

202
00:10:04,750 --> 00:10:10,240
anyways that's just remember that over

203
00:10:08,350 --> 00:10:13,210
and over again it and that's why these

204
00:10:10,240 --> 00:10:15,310
arrows show that if we were to enumerate

205
00:10:13,210 --> 00:10:17,830
the addresses of these different bytes

206
00:10:15,310 --> 00:10:20,620
in the data they'd be increasing in this

207
00:10:17,830 --> 00:10:23,290
direction and when we add to the stack

208
00:10:20,620 --> 00:10:25,750
the stack top is at the bottom of the

209
00:10:23,290 --> 00:10:30,790
picture and we do it by decrementing the

210
00:10:25,750 --> 00:10:33,820
stack pointer so in particular others

211
00:10:30,790 --> 00:10:38,190
saw explicit instructions push and pop

212
00:10:33,820 --> 00:10:41,860
that make use of the stack and it's

213
00:10:38,190 --> 00:10:46,270
often written push cue and pop cue but

214
00:10:41,860 --> 00:10:50,080
that cue is actually an optional suffix

215
00:10:46,270 --> 00:10:52,440
on the instruction so the the idea of

216
00:10:50,080 --> 00:10:56,080
pushing something onto the stack then is

217
00:10:52,440 --> 00:10:59,770
there is some source operand it could be

218
00:10:56,080 --> 00:11:02,230
from register or for memory or an

219
00:10:59,770 --> 00:11:06,040
immediate so this is sort of like a move

220
00:11:02,230 --> 00:11:08,670
instruction but the destination of the

221
00:11:06,040 --> 00:11:11,140
move will be toward memory and that

222
00:11:08,670 --> 00:11:13,330
address of the memory is determined by

223
00:11:11,140 --> 00:11:16,710
first decrementing the stack pointer and

224
00:11:13,330 --> 00:11:16,710
then doing a right

225
00:11:18,990 --> 00:11:25,360
and similarly the pop instruction takes

226
00:11:22,900 --> 00:11:27,280
reads data from the stack and stores it

227
00:11:25,360 --> 00:11:30,610
in the destination which must be a

228
00:11:27,280 --> 00:11:34,180
register for this particular instruction

229
00:11:30,610 --> 00:11:36,280
I think push must be a register too now

230
00:11:34,180 --> 00:11:41,740
that I think of it for immediate you

231
00:11:36,280 --> 00:11:45,040
can't push from memory to so pop reads

232
00:11:41,740 --> 00:11:48,700
from memory the address that reads from

233
00:11:45,040 --> 00:11:50,890
is given by the current stack pointer it

234
00:11:48,700 --> 00:11:54,730
and then it increments the stack pointer

235
00:11:50,890 --> 00:11:56,760
by 8 these both work only on 8 byte

236
00:11:54,730 --> 00:12:01,030
operands I'll get to you in a second and

237
00:11:56,760 --> 00:12:06,820
then the result of that is stored in a

238
00:12:01,030 --> 00:12:10,780
register question pop and push or just

239
00:12:06,820 --> 00:12:13,090
like doing the liquidation like is there

240
00:12:10,780 --> 00:12:16,210
a difference between like using the like

241
00:12:13,090 --> 00:12:19,710
the top Oh could you write it as a set

242
00:12:16,210 --> 00:12:22,840
of instructions yeah you could actually

243
00:12:19,710 --> 00:12:25,170
except for some weird corner cases write

244
00:12:22,840 --> 00:12:29,320
it out as a set of separate instructions

245
00:12:25,170 --> 00:12:31,920
but it's a common enough thing that it's

246
00:12:29,320 --> 00:12:34,690
sort of built in as a as an operation

247
00:12:31,920 --> 00:12:38,530
whereas call and return are special they

248
00:12:34,690 --> 00:12:40,630
can't be simulated so one thing to

249
00:12:38,530 --> 00:12:44,020
remember too is it's important that in

250
00:12:40,630 --> 00:12:46,510
one case you decrement you do the

251
00:12:44,020 --> 00:12:49,000
arithmetic on the stack pointer before

252
00:12:46,510 --> 00:12:51,220
you write because when you first start

253
00:12:49,000 --> 00:12:52,810
it out the stack pointer is pointing to

254
00:12:51,220 --> 00:12:55,120
whatever was the top element of the

255
00:12:52,810 --> 00:12:56,680
stack we want to create a new top

256
00:12:55,120 --> 00:13:00,430
element so we're going to decrement

257
00:12:56,680 --> 00:13:03,310
first and then do the right whereas

258
00:13:00,430 --> 00:13:04,780
going the other direction you want to

259
00:13:03,310 --> 00:13:07,450
read off the current top of stack

260
00:13:04,780 --> 00:13:10,510
element and then you want to increment

261
00:13:07,450 --> 00:13:12,370
the stack pointer to sort of deallocate

262
00:13:10,510 --> 00:13:14,500
it and one thing you'll notice here is

263
00:13:12,370 --> 00:13:17,980
when I say deallocate it's not like I

264
00:13:14,500 --> 00:13:19,600
magically erased this or or something

265
00:13:17,980 --> 00:13:22,930
all I'm doing is just moving a stack

266
00:13:19,600 --> 00:13:25,240
pointer whatever was there at the top of

267
00:13:22,930 --> 00:13:29,040
the stack is still in memory it's just

268
00:13:25,240 --> 00:13:29,040
no longer considered part of the stack

269
00:13:31,300 --> 00:13:38,980
okay so that's the idea of the stack and

270
00:13:34,690 --> 00:13:42,009
the instructions push and pop are are to

271
00:13:38,980 --> 00:13:44,870
put data on the stack or take it off but

272
00:13:42,009 --> 00:13:50,449
we use the same basic idea for a call

273
00:13:44,870 --> 00:13:52,339
and return so let's look at some

274
00:13:50,449 --> 00:13:55,550
examples and there's a lot of stuff up

275
00:13:52,339 --> 00:13:58,839
here but this is a see function called

276
00:13:55,550 --> 00:14:02,690
mult store and then this is the output

277
00:13:58,839 --> 00:14:05,170
slightly cleaned up output from the

278
00:14:02,690 --> 00:14:07,519
disassembler of that exact function and

279
00:14:05,170 --> 00:14:10,730
similarly this is a function called mult

280
00:14:07,519 --> 00:14:12,769
to and this is it's disassembled version

281
00:14:10,730 --> 00:14:15,259
and the reason I'm showing this is

282
00:14:12,769 --> 00:14:18,079
because I want to make use of the

283
00:14:15,259 --> 00:14:20,000
addresses that these instructions are at

284
00:14:18,079 --> 00:14:22,490
that you don't see when you write it an

285
00:14:20,000 --> 00:14:27,050
assembly code so I'm showing it the

286
00:14:22,490 --> 00:14:28,639
disassembled version and the reason all

287
00:14:27,050 --> 00:14:33,230
this is up here is because you'll see

288
00:14:28,639 --> 00:14:37,810
the function multi so I want to show how

289
00:14:33,230 --> 00:14:40,100
that works so and there's two

290
00:14:37,810 --> 00:14:43,010
instructions and you've seen these in

291
00:14:40,100 --> 00:14:46,670
some form to call a function you just

292
00:14:43,010 --> 00:14:48,949
call it where you give a label but keep

293
00:14:46,670 --> 00:14:50,899
in mind that this these two instructions

294
00:14:48,949 --> 00:14:53,120
and the other is when you're ready to

295
00:14:50,899 --> 00:14:56,120
return you just execute the RET

296
00:14:53,120 --> 00:14:58,269
instruction and keep in mind though that

297
00:14:56,120 --> 00:15:00,769
these functions don't do the whole

298
00:14:58,269 --> 00:15:02,600
business of procedure call and return

299
00:15:00,769 --> 00:15:04,940
they just do the control part of it

300
00:15:02,600 --> 00:15:09,709
which is we saw is only one of three

301
00:15:04,940 --> 00:15:13,010
aspects of a procedure also mention

302
00:15:09,709 --> 00:15:18,350
you'll see especially in sometimes it

303
00:15:13,010 --> 00:15:21,709
will say ret semicolon ret and you can

304
00:15:18,350 --> 00:15:24,980
pretty much just ignore that and it's a

305
00:15:21,709 --> 00:15:27,759
bit obscure why it's even there so it's

306
00:15:24,980 --> 00:15:27,759
really the same idea

307
00:15:29,679 --> 00:15:36,799
okay so let's to break this down into

308
00:15:32,809 --> 00:15:41,539
its simplest part so let's imagine a

309
00:15:36,799 --> 00:15:44,539
scenario in which the top of stack is at

310
00:15:41,539 --> 00:15:47,509
hex address 1 to 0 which is not

311
00:15:44,539 --> 00:15:49,819
realistic by the way and the program

312
00:15:47,509 --> 00:15:55,239
counter which is called our IP which is

313
00:15:49,819 --> 00:15:57,619
not anything to do with death is is

314
00:15:55,239 --> 00:16:02,599
indicating that the current instruction

315
00:15:57,619 --> 00:16:05,659
is this at 5:44 which is this call

316
00:16:02,599 --> 00:16:09,529
instruction and so what would happen

317
00:16:05,659 --> 00:16:13,939
with the call instruction is it would do

318
00:16:09,529 --> 00:16:15,649
two things it would actually three

319
00:16:13,939 --> 00:16:18,949
things it would decrement the stack

320
00:16:15,649 --> 00:16:22,519
pointer and so subjecting 8 from 1 to 0

321
00:16:18,949 --> 00:16:25,959
and hex gives you 1 1 8 and it would

322
00:16:22,519 --> 00:16:30,649
write the address of the instruction

323
00:16:25,959 --> 00:16:33,739
following to call onto the top of the

324
00:16:30,649 --> 00:16:37,009
stack and it's important that it does it

325
00:16:33,739 --> 00:16:39,819
the one following the call is it that

326
00:16:37,009 --> 00:16:43,099
that's instruction I'm going to return

327
00:16:39,819 --> 00:16:47,659
used for my return address and I want to

328
00:16:43,099 --> 00:16:49,669
resume execution in this function at the

329
00:16:47,659 --> 00:16:51,469
instruction after the call not to call

330
00:16:49,669 --> 00:16:57,529
itself otherwise you'd have an infinite

331
00:16:51,469 --> 00:17:00,739
loop and it also this call instruction

332
00:16:57,529 --> 00:17:04,339
also embedded in the encoding of the

333
00:17:00,739 --> 00:17:09,350
instruction is the destination address

334
00:17:04,339 --> 00:17:11,480
of it and which happens to be the

335
00:17:09,350 --> 00:17:14,449
starting address of this particular

336
00:17:11,480 --> 00:17:19,189
function so the program counter will be

337
00:17:14,449 --> 00:17:21,529
set to that value and now the the

338
00:17:19,189 --> 00:17:23,149
processor starts just executing along

339
00:17:21,529 --> 00:17:25,730
these instructions so it did a

340
00:17:23,149 --> 00:17:27,740
combination of a jump and a push and

341
00:17:25,730 --> 00:17:31,240
that's why the question was raised

342
00:17:27,740 --> 00:17:33,649
earlier is a push instruction could you

343
00:17:31,240 --> 00:17:35,539
assemble that out of existing

344
00:17:33,649 --> 00:17:39,669
instructions the answer is yes for push

345
00:17:35,539 --> 00:17:39,669
but not for call question back there

346
00:17:40,210 --> 00:17:48,340
bump in in like both story would put the

347
00:17:42,850 --> 00:17:52,690
address of multitude in RIT no no it did

348
00:17:48,340 --> 00:17:54,399
that RIT you never explicitly there

349
00:17:52,690 --> 00:17:57,009
aren't instructions that manipulate that

350
00:17:54,399 --> 00:17:59,710
directly it's implicitly part of the

351
00:17:57,009 --> 00:18:03,299
call instruction the call instruction

352
00:17:59,710 --> 00:18:08,080
will take I don't have the actual

353
00:18:03,299 --> 00:18:09,850
encoding but embedded in this call

354
00:18:08,080 --> 00:18:11,529
instruction you see that it's five bytes

355
00:18:09,850 --> 00:18:13,929
long I don't show you the bike coding

356
00:18:11,529 --> 00:18:17,710
but embedded in it is the target address

357
00:18:13,929 --> 00:18:19,330
and so it will take that address and use

358
00:18:17,710 --> 00:18:23,320
it for the new value of the program

359
00:18:19,330 --> 00:18:25,330
counter so the call does both the

360
00:18:23,320 --> 00:18:27,999
pushing of the old the return pointer

361
00:18:25,330 --> 00:18:33,549
and setting the program counter to the

362
00:18:27,999 --> 00:18:36,389
new the the new target for it so it does

363
00:18:33,549 --> 00:18:36,389
both of those things

364
00:18:37,940 --> 00:18:40,780
question

365
00:18:45,590 --> 00:18:55,480
I don't think so would either call or

366
00:18:48,799 --> 00:18:59,419
return if so it would be really obscure

367
00:18:55,480 --> 00:19:02,059
no I don't think so no so call and

368
00:18:59,419 --> 00:19:03,799
return are the there might be some weird

369
00:19:02,059 --> 00:19:05,510
system instructions that let you do that

370
00:19:03,799 --> 00:19:10,340
but not in you'd see in any normal

371
00:19:05,510 --> 00:19:17,419
program of a question good question so

372
00:19:10,340 --> 00:19:23,149
so okay so that shows you the control

373
00:19:17,419 --> 00:19:26,090
McCall works and then so now imagine

374
00:19:23,149 --> 00:19:28,370
this multitude chugs along and it hits

375
00:19:26,090 --> 00:19:31,039
its return point and it hits this rep

376
00:19:28,370 --> 00:19:36,580
instruction by the way again ret Q and

377
00:19:31,039 --> 00:19:39,950
rather the same instruction and ret will

378
00:19:36,580 --> 00:19:43,429
its purpose is to reverse the effect of

379
00:19:39,950 --> 00:19:47,480
a call it assumes that the top of the

380
00:19:43,429 --> 00:19:51,470
stack has an address that you want to

381
00:19:47,480 --> 00:19:53,809
jump to so it will pop that address off

382
00:19:51,470 --> 00:19:56,090
the stack meaning it will increment the

383
00:19:53,809 --> 00:19:58,309
stack pointer like I said the value

384
00:19:56,090 --> 00:20:00,529
doesn't really disappear from the memory

385
00:19:58,309 --> 00:20:03,860
it just is no longer considered part of

386
00:20:00,529 --> 00:20:05,659
the stack and then it will set the

387
00:20:03,860 --> 00:20:08,750
program counter to what it just popped

388
00:20:05,659 --> 00:20:11,299
off the stack and that will cause the

389
00:20:08,750 --> 00:20:11,860
program to resume back to where it came

390
00:20:11,299 --> 00:20:15,110
from

391
00:20:11,860 --> 00:20:17,929
so you see that to the clever idea of

392
00:20:15,110 --> 00:20:20,179
pushing the address of the next

393
00:20:17,929 --> 00:20:22,610
instruction so when the return comes it

394
00:20:20,179 --> 00:20:25,120
will get it to the point where it should

395
00:20:22,610 --> 00:20:25,120
resume execution

396
00:20:26,600 --> 00:20:31,020
okay so that's passing control it's

397
00:20:29,070 --> 00:20:33,450
pretty simple all these things by the

398
00:20:31,020 --> 00:20:35,970
way and is just the nature machine code

399
00:20:33,450 --> 00:20:38,929
every single part of it is pretty simple

400
00:20:35,970 --> 00:20:42,179
because it's designed to be executed by

401
00:20:38,929 --> 00:20:45,360
the original hardware is fairly simple

402
00:20:42,179 --> 00:20:49,169
it's not any more but it's really the

403
00:20:45,360 --> 00:20:51,330
basic ideas are and that we use kind of

404
00:20:49,169 --> 00:20:53,630
combinations of instructions to build up

405
00:20:51,330 --> 00:20:55,890
all the layers associated with

406
00:20:53,630 --> 00:21:00,299
operations like procedure call and

407
00:20:55,890 --> 00:21:02,610
return okay so passing data now we've

408
00:21:00,299 --> 00:21:06,120
already seen a few small examples of

409
00:21:02,610 --> 00:21:08,100
passing data we've seen a couple

410
00:21:06,120 --> 00:21:10,530
registers that get used when you're

411
00:21:08,100 --> 00:21:13,470
passing arguments to a function and

412
00:21:10,530 --> 00:21:15,600
we've seen the register RA X getting

413
00:21:13,470 --> 00:21:19,440
used to return values from a function

414
00:21:15,600 --> 00:21:22,070
and so those that's the basic idea and

415
00:21:19,440 --> 00:21:24,720
again this is all built into this ABI

416
00:21:22,070 --> 00:21:27,780
you know defined as a set of conventions

417
00:21:24,720 --> 00:21:29,610
not particularly part of the hardware so

418
00:21:27,780 --> 00:21:35,460
in particular the rule is that the first

419
00:21:29,610 --> 00:21:40,620
six arguments get passed within these

420
00:21:35,460 --> 00:21:43,620
particular registers and you just have

421
00:21:40,620 --> 00:21:45,960
to memorize the order of them or have a

422
00:21:43,620 --> 00:21:47,909
table handy to look at or something like

423
00:21:45,960 --> 00:21:56,010
that because there's no particular logic

424
00:21:47,909 --> 00:21:58,590
to it and the return value is returned

425
00:21:56,010 --> 00:22:00,679
in register RA X and by the way this is

426
00:21:58,590 --> 00:22:04,919
all four arguments that are either

427
00:22:00,679 --> 00:22:06,750
integers or pointers well I think I've

428
00:22:04,919 --> 00:22:08,190
got a little bit unfolding point those

429
00:22:06,750 --> 00:22:10,710
are passed in a separate set of

430
00:22:08,190 --> 00:22:12,809
registers so these are just for assumed

431
00:22:10,710 --> 00:22:16,470
now we just are dealing with integer

432
00:22:12,809 --> 00:22:18,450
data pointer data and then you ask well

433
00:22:16,470 --> 00:22:20,820
what happens if you have more than six

434
00:22:18,450 --> 00:22:23,250
arguments to a function which isn't very

435
00:22:20,820 --> 00:22:25,710
common but it happens well the rule on

436
00:22:23,250 --> 00:22:28,409
that is those get put in memory on the

437
00:22:25,710 --> 00:22:30,780
stack and I'll show straight what I mean

438
00:22:28,409 --> 00:22:32,880
by that so they're passed to the

439
00:22:30,780 --> 00:22:36,230
function and then the function has to

440
00:22:32,880 --> 00:22:39,350
retrieve those values off the stack

441
00:22:36,230 --> 00:22:41,239
back in the bad old days of ia-32 by the

442
00:22:39,350 --> 00:22:44,659
way all the arguments got passed on the

443
00:22:41,239 --> 00:22:47,029
stack but now for the most part you pass

444
00:22:44,659 --> 00:22:49,340
arguments and the registers and the

445
00:22:47,029 --> 00:22:53,359
reason for that is register access is

446
00:22:49,340 --> 00:22:56,480
way faster than memory access okay so

447
00:22:53,359 --> 00:22:59,929
here's a kind of a messy bunch of code

448
00:22:56,480 --> 00:23:04,429
but just to show you how they show up

449
00:22:59,929 --> 00:23:08,210
all the time in the function not store

450
00:23:04,429 --> 00:23:10,820
as three arguments XY and desk and you

451
00:23:08,210 --> 00:23:14,869
can just see within this code that it's

452
00:23:10,820 --> 00:23:19,940
making use of of registers like RDI

453
00:23:14,869 --> 00:23:23,389
and does it show where and in other

454
00:23:19,940 --> 00:23:25,940
places like mult - as two arguments and

455
00:23:23,389 --> 00:23:29,029
you can see how it's making use of our

456
00:23:25,940 --> 00:23:30,799
GI and our si and the code so basically

457
00:23:29,029 --> 00:23:33,019
the code is generated under the

458
00:23:30,799 --> 00:23:35,389
assumptions that whatever arguments is

459
00:23:33,019 --> 00:23:37,700
being passed to it will be passed in

460
00:23:35,389 --> 00:23:39,919
that particular set of registers and the

461
00:23:37,700 --> 00:23:42,049
particular orders are listed and the

462
00:23:39,919 --> 00:23:44,679
code is sort of makes those assumptions

463
00:23:42,049 --> 00:23:47,659
and then similarly

464
00:23:44,679 --> 00:23:50,169
when you have a return value from a

465
00:23:47,659 --> 00:23:50,169
function

466
00:23:50,289 --> 00:23:58,309
it's the multi-store does not have a

467
00:23:52,730 --> 00:24:00,859
return values but of mul - does and the

468
00:23:58,309 --> 00:24:04,850
way it does is it deposits the value

469
00:24:00,859 --> 00:24:09,830
into our ax and then when the return

470
00:24:04,850 --> 00:24:16,460
from our X occurs a tumult store you see

471
00:24:09,830 --> 00:24:19,519
that it assumes now that the mult store

472
00:24:16,460 --> 00:24:23,210
code can assume that register RA X holds

473
00:24:19,519 --> 00:24:26,509
the value of the return value and it can

474
00:24:23,210 --> 00:24:28,789
store it in its destination register and

475
00:24:26,509 --> 00:24:32,149
we'll look in a minute why RB X gets

476
00:24:28,789 --> 00:24:34,970
used here we'll cover that in just a

477
00:24:32,149 --> 00:24:37,009
little later but that's the point that

478
00:24:34,970 --> 00:24:40,070
as long as everyone sticks to this

479
00:24:37,009 --> 00:24:42,950
common interface standard then you can

480
00:24:40,070 --> 00:24:47,359
even use different compilers to compile

481
00:24:42,950 --> 00:24:49,399
code and have them be able to cooperate

482
00:24:47,359 --> 00:24:49,730
with each other in terms of passing

483
00:24:49,399 --> 00:24:52,400
argue

484
00:24:49,730 --> 00:24:56,740
it's returning data and that's the

485
00:24:52,400 --> 00:24:56,740
reason why you want that convention yes

486
00:24:58,240 --> 00:25:03,650
eight bytes because the well first of

487
00:25:02,390 --> 00:25:06,800
all for call and return

488
00:25:03,650 --> 00:25:10,580
it's a 64-bit machine so all addresses

489
00:25:06,800 --> 00:25:13,640
are 64 bits or 8 bytes but also even the

490
00:25:10,580 --> 00:25:17,750
push in the pop instruction only work on

491
00:25:13,640 --> 00:25:20,300
8 byte values if you said push L if you

492
00:25:17,750 --> 00:25:22,330
tried to write that an X in 64-bit code

493
00:25:20,300 --> 00:25:30,320
it would come back with a syntax error

494
00:25:22,330 --> 00:25:32,420
if you had in the assembly so oh that

495
00:25:30,320 --> 00:25:39,590
and that's different I three to there'd

496
00:25:32,420 --> 00:25:41,450
be four byte values here okay so like I

497
00:25:39,590 --> 00:25:42,920
said you've certain seen that implicitly

498
00:25:41,450 --> 00:25:44,540
and some of the code you've already been

499
00:25:42,920 --> 00:25:47,930
looking at and it's pretty

500
00:25:44,540 --> 00:25:51,170
straightforward to get an example that

501
00:25:47,930 --> 00:25:53,000
shows passing arguments you have to have

502
00:25:51,170 --> 00:25:55,190
a function with at least seven arguments

503
00:25:53,000 --> 00:25:58,960
which is pretty messy to do so I won't

504
00:25:55,190 --> 00:25:58,960
do it but there's examples in the book

505
00:25:59,470 --> 00:26:06,490
but now and we'll sort of pick it up

506
00:26:02,480 --> 00:26:10,880
I'll show you also in this later part

507
00:26:06,490 --> 00:26:12,830
and now the third part of it is again

508
00:26:10,880 --> 00:26:16,190
what if there's some local data that we

509
00:26:12,830 --> 00:26:19,150
need to make use of and so to get that

510
00:26:16,190 --> 00:26:22,460
idea across I have to illness to another

511
00:26:19,150 --> 00:26:27,470
concept which is called the stack frame

512
00:26:22,460 --> 00:26:29,720
and so this is a particularly intense

513
00:26:27,470 --> 00:26:33,140
it's used in memory and as I mentioned

514
00:26:29,720 --> 00:26:36,020
earlier one of the features of calling

515
00:26:33,140 --> 00:26:40,010
and returning is you can imagine when

516
00:26:36,020 --> 00:26:42,890
you have a nested series of calls to a

517
00:26:40,010 --> 00:26:48,920
function when a particular function is

518
00:26:42,890 --> 00:26:51,260
executing it only it only needs to

519
00:26:48,920 --> 00:26:54,050
reference the data within that function

520
00:26:51,260 --> 00:26:56,390
or values that have been passed to it

521
00:26:54,050 --> 00:26:58,700
some which might be pointers and

522
00:26:56,390 --> 00:27:02,030
therefore pointing to other locations in

523
00:26:58,700 --> 00:27:03,330
memory but the point is sort of the rest

524
00:27:02,030 --> 00:27:06,210
of the functions

525
00:27:03,330 --> 00:27:08,310
in your code however many they are are

526
00:27:06,210 --> 00:27:10,470
sort of frozen at that moment really

527
00:27:08,310 --> 00:27:14,180
there's only one function executing at

528
00:27:10,470 --> 00:27:16,770
any given time I'm assuming a suit of

529
00:27:14,180 --> 00:27:21,540
what you'd call a single-threaded model

530
00:27:16,770 --> 00:27:24,720
here and so we can just allocate on the

531
00:27:21,540 --> 00:27:27,240
stack whatever space is required for

532
00:27:24,720 --> 00:27:29,940
this particular function and then when

533
00:27:27,240 --> 00:27:32,730
we return from that function oh we

534
00:27:29,940 --> 00:27:34,830
shouldn't if it's correctly written need

535
00:27:32,730 --> 00:27:36,270
any of the information associated with

536
00:27:34,830 --> 00:27:38,370
that function that can just sort of

537
00:27:36,270 --> 00:27:41,750
disappear forever and that's why this

538
00:27:38,370 --> 00:27:44,130
idea of a stack you allocate something

539
00:27:41,750 --> 00:27:46,590
if you make more calls you keep

540
00:27:44,130 --> 00:27:48,990
allocating more stuff but as they return

541
00:27:46,590 --> 00:27:51,900
you kind of back out of the stack and

542
00:27:48,990 --> 00:27:55,110
and free things up so the stack

543
00:27:51,900 --> 00:27:56,940
discipline is is exactly the right match

544
00:27:55,110 --> 00:28:00,480
as well this whole idea of procedure

545
00:27:56,940 --> 00:28:03,000
calling returns so each block we use for

546
00:28:00,480 --> 00:28:09,110
a particular call then it's called a

547
00:28:03,000 --> 00:28:12,960
stack frame and to be suitum more

548
00:28:09,110 --> 00:28:15,510
technical we'll say it's a frame for a

549
00:28:12,960 --> 00:28:19,830
particular instance of a procedure a

550
00:28:15,510 --> 00:28:23,250
particular call to a procedure so just

551
00:28:19,830 --> 00:28:25,920
imagine we had a set of functions one

552
00:28:23,250 --> 00:28:30,330
called you which calls a function called

553
00:28:25,920 --> 00:28:33,390
who and who has multiple calls to

554
00:28:30,330 --> 00:28:35,730
another function called MI and mi is

555
00:28:33,390 --> 00:28:42,000
itself recurrence recursive it calls

556
00:28:35,730 --> 00:28:45,090
itself and so an imagine we had a chain

557
00:28:42,000 --> 00:28:48,510
of calls where you call two calls

558
00:28:45,090 --> 00:28:52,890
mi which calls itself recursively twice

559
00:28:48,510 --> 00:28:55,230
and then we'll exit out of MI and get

560
00:28:52,890 --> 00:28:58,710
back to who and then who will hit it

561
00:28:55,230 --> 00:29:01,700
second call to mi which won't go any

562
00:28:58,710 --> 00:29:04,830
further and that will be it so this

563
00:29:01,700 --> 00:29:08,630
picture here shows the soul whole

564
00:29:04,830 --> 00:29:13,460
history of all these calls that get made

565
00:29:08,630 --> 00:29:13,460
but in terms of the stack of

566
00:29:13,650 --> 00:29:19,840
all we need what will keep a frame for

567
00:29:17,440 --> 00:29:24,970
every sort of procedure that has been

568
00:29:19,840 --> 00:29:28,419
called but not yet returned on this deck

569
00:29:24,970 --> 00:29:31,630
and in general this deck of is delimited

570
00:29:28,419 --> 00:29:33,400
by delimited by two pointers one is the

571
00:29:31,630 --> 00:29:35,740
stack pointer which we're familiar with

572
00:29:33,400 --> 00:29:39,540
and then there's another called the base

573
00:29:35,740 --> 00:29:44,650
pointer which register RB P indicates

574
00:29:39,540 --> 00:29:48,340
but one a feature of actually it's now

575
00:29:44,650 --> 00:29:51,760
become a feature of ia32 as well is that

576
00:29:48,340 --> 00:29:53,760
this is an optional pointer and in

577
00:29:51,760 --> 00:29:57,280
particularly the code that we'll see

578
00:29:53,760 --> 00:30:01,720
does not use a base pointer except in

579
00:29:57,280 --> 00:30:05,169
some very special cases so this this

580
00:30:01,720 --> 00:30:08,620
register doesn't really won't show up in

581
00:30:05,169 --> 00:30:10,929
your programs being used in a special

582
00:30:08,620 --> 00:30:14,380
way as a frame pointer it will be used

583
00:30:10,929 --> 00:30:16,450
instead just as a regular register so

584
00:30:14,380 --> 00:30:17,890
typically then the only thing you'll

585
00:30:16,450 --> 00:30:19,000
know about the stack pointer you

586
00:30:17,890 --> 00:30:22,960
wouldn't even be able to figure out

587
00:30:19,000 --> 00:30:25,960
where where the frame is exactly you'll

588
00:30:22,960 --> 00:30:28,840
just know that the top part of the stack

589
00:30:25,960 --> 00:30:33,040
is the top frame for the topmost

590
00:30:28,840 --> 00:30:38,230
function and this is all managed by the

591
00:30:33,040 --> 00:30:39,760
code itself and this is the same stack

592
00:30:38,230 --> 00:30:42,850
by the way in which you're pushing and

593
00:30:39,760 --> 00:30:45,480
popping addresses - and they all kind of

594
00:30:42,850 --> 00:30:45,480
get mixed together

595
00:30:46,830 --> 00:30:52,230
so we haven't actually seen any code up

596
00:30:49,860 --> 00:30:54,540
til now that makes you have to do any

597
00:30:52,230 --> 00:30:56,930
explicit management of the stack because

598
00:30:54,540 --> 00:31:01,050
all our examples were very simple and

599
00:30:56,930 --> 00:31:04,350
just did a made use of the stack only

600
00:31:01,050 --> 00:31:07,440
for return addresses but we'll see some

601
00:31:04,350 --> 00:31:10,200
that uses more but so in general then

602
00:31:07,440 --> 00:31:13,620
imagine that each time you begin a

603
00:31:10,200 --> 00:31:16,500
function some space key delicated

604
00:31:13,620 --> 00:31:21,770
potentially on the stack for its frame

605
00:31:16,500 --> 00:31:25,730
and then and that frame is indicated by

606
00:31:21,770 --> 00:31:31,110
either one pointer only or two pointers

607
00:31:25,730 --> 00:31:33,000
and so now as you calls who then that

608
00:31:31,110 --> 00:31:36,330
will create a new stack frame for who

609
00:31:33,000 --> 00:31:38,970
and some way when mi gets called that

610
00:31:36,330 --> 00:31:40,830
creates the new stack frame and as we

611
00:31:38,970 --> 00:31:42,750
continue with these recursive calls

612
00:31:40,830 --> 00:31:45,450
we're just adding more stuff to the

613
00:31:42,750 --> 00:31:46,980
stack getting deeper and deeper and that

614
00:31:45,450 --> 00:31:49,230
will keep happening it's one of the

615
00:31:46,980 --> 00:31:52,500
reasons why recursion is a little bit of

616
00:31:49,230 --> 00:31:55,920
a risky thing is that it compared to

617
00:31:52,500 --> 00:31:58,920
iteration it keeps requiring more space

618
00:31:55,920 --> 00:32:03,210
as you go deeper in the recursion and in

619
00:31:58,920 --> 00:32:08,070
particular most systems limit the total

620
00:32:03,210 --> 00:32:10,140
depth of the stack and you can have what

621
00:32:08,070 --> 00:32:11,730
because they're they're afraid of the

622
00:32:10,140 --> 00:32:14,130
sort of infinite loop version of

623
00:32:11,730 --> 00:32:15,720
recursion is runaway recursion where it

624
00:32:14,130 --> 00:32:20,450
just keeps trying to push more and more

625
00:32:15,720 --> 00:32:26,190
stuff onto the stack that's an aside and

626
00:32:20,450 --> 00:32:28,650
then as these begin to return they those

627
00:32:26,190 --> 00:32:32,550
frames get de-allocated removed from the

628
00:32:28,650 --> 00:32:35,340
stack so part of it it the nice thing

629
00:32:32,550 --> 00:32:38,790
about this is it means that every time I

630
00:32:35,340 --> 00:32:41,730
if I have multiple calls to MI because

631
00:32:38,790 --> 00:32:44,970
I've gone deep recursively each one of

632
00:32:41,730 --> 00:32:49,140
them will have its own local state that

633
00:32:44,970 --> 00:32:51,270
it needs to manage and again the whole

634
00:32:49,140 --> 00:32:55,110
stack discipline is what makes it work

635
00:32:51,270 --> 00:32:57,320
and what we'll find out in particular is

636
00:32:55,110 --> 00:32:59,670
because of the way this is set up

637
00:32:57,320 --> 00:33:00,659
recursive calls are handled the same way

638
00:32:59,670 --> 00:33:02,309
that

639
00:33:00,659 --> 00:33:04,499
regular calls are there's nothing

640
00:33:02,309 --> 00:33:07,139
special about them all the heart all the

641
00:33:04,499 --> 00:33:09,210
sort of infrastructure required to

642
00:33:07,139 --> 00:33:12,409
support recursion is built into this

643
00:33:09,210 --> 00:33:12,409
whole stack discipline

644
00:33:13,190 --> 00:33:19,649
so anyways imagine that all these calls

645
00:33:16,549 --> 00:33:24,090
return back to who and then who would

646
00:33:19,649 --> 00:33:26,429
call mi again and then again as we exit

647
00:33:24,090 --> 00:33:29,429
we were sort of deallocating these stack

648
00:33:26,429 --> 00:33:30,200
frames and getting back to the starting

649
00:33:29,429 --> 00:33:38,879
point

650
00:33:30,200 --> 00:33:40,499
yes question oh so the question was if

651
00:33:38,879 --> 00:33:43,409
RB P is optional

652
00:33:40,499 --> 00:33:45,659
then how does the program know how to do

653
00:33:43,409 --> 00:33:48,179
the D allocation how can it reset the

654
00:33:45,659 --> 00:33:50,549
stack back to the right place and the

655
00:33:48,179 --> 00:33:54,450
answer is and we'll see examples that

656
00:33:50,549 --> 00:33:58,080
the code is compiled so it knows for

657
00:33:54,450 --> 00:34:00,809
example when it does the allocation is

658
00:33:58,080 --> 00:34:02,729
going to allocate 16 bytes and then it

659
00:34:00,809 --> 00:34:05,159
knows at the end that it can be

660
00:34:02,729 --> 00:34:06,659
allocated 16 bytes and it actually

661
00:34:05,159 --> 00:34:09,599
brings up a good point there is sort of

662
00:34:06,659 --> 00:34:11,700
an obscure part of the book that goes

663
00:34:09,599 --> 00:34:14,460
over this there's a few special cases

664
00:34:11,700 --> 00:34:16,829
where it can't know in advance how much

665
00:34:14,460 --> 00:34:21,750
space will be allocated when it has to

666
00:34:16,829 --> 00:34:24,450
allocate an array or a memory buffer of

667
00:34:21,750 --> 00:34:28,020
variable size and then it will actually

668
00:34:24,450 --> 00:34:30,679
use the the RB P in those cases for

669
00:34:28,020 --> 00:34:30,679
exactly that purpose

670
00:34:33,700 --> 00:34:42,099
okay and so in general that what the

671
00:34:38,799 --> 00:34:45,069
stack frame will look like in one of

672
00:34:42,099 --> 00:34:49,419
these machines will be something like

673
00:34:45,069 --> 00:34:53,200
this that look and you'll see this is

674
00:34:49,419 --> 00:34:56,799
the caller and then this is the the

675
00:34:53,200 --> 00:35:02,470
stack frame of the the function that got

676
00:34:56,799 --> 00:35:05,470
called so working our way back if we

677
00:35:02,470 --> 00:35:09,280
have to pass more than six arguments the

678
00:35:05,470 --> 00:35:16,030
caller will actually use its own stack

679
00:35:09,280 --> 00:35:18,069
frame to store those arguments and so

680
00:35:16,030 --> 00:35:21,190
that they'd be available and we already

681
00:35:18,069 --> 00:35:24,700
saw when you do a call it will push the

682
00:35:21,190 --> 00:35:27,910
return address onto the stack so before

683
00:35:24,700 --> 00:35:31,240
a function even starts all this

684
00:35:27,910 --> 00:35:35,319
information would be on the stack now if

685
00:35:31,240 --> 00:35:37,780
there's a if this particular if we're

686
00:35:35,319 --> 00:35:39,700
making use of a base pointer then we

687
00:35:37,780 --> 00:35:41,619
have to have some way where to store the

688
00:35:39,700 --> 00:35:45,040
old value of the base pointer so that we

689
00:35:41,619 --> 00:35:47,140
could fix it back when we return we

690
00:35:45,040 --> 00:35:49,930
won't show any code doing that here so

691
00:35:47,140 --> 00:35:53,170
this is optional but in general if

692
00:35:49,930 --> 00:35:54,880
there's some local state like some

693
00:35:53,170 --> 00:35:57,400
registers that need to be saved can

694
00:35:54,880 --> 00:36:00,040
we'll see examples of that or an array

695
00:35:57,400 --> 00:36:02,890
that needs to be allocated locally that

696
00:36:00,040 --> 00:36:05,530
will be stored within the stack frame

697
00:36:02,890 --> 00:36:07,990
and there might be some requirement for

698
00:36:05,530 --> 00:36:10,660
some extra space in the stack frame for

699
00:36:07,990 --> 00:36:12,670
other stuff in particular if it we're

700
00:36:10,660 --> 00:36:14,829
going to pass more than seven arguments

701
00:36:12,670 --> 00:36:15,760
that need space somewhere in the stack

702
00:36:14,829 --> 00:36:19,210
frame to do it

703
00:36:15,760 --> 00:36:22,440
and what we'll see in typical a code is

704
00:36:19,210 --> 00:36:25,960
this stack pointer gets decremented

705
00:36:22,440 --> 00:36:28,900
pretty soon after the procedure begins

706
00:36:25,960 --> 00:36:29,740
and it gets incremented back just before

707
00:36:28,900 --> 00:36:34,869
it returns

708
00:36:29,740 --> 00:36:38,190
that's how it manages this deck so let's

709
00:36:34,869 --> 00:36:38,190
do some examples

710
00:36:41,060 --> 00:36:50,660
um what he looked at this before but

711
00:36:48,530 --> 00:36:52,520
this is a function oh I think the

712
00:36:50,660 --> 00:36:54,970
interesting thing about this function is

713
00:36:52,520 --> 00:36:58,250
that it has a pointer being passed to it

714
00:36:54,970 --> 00:37:00,520
so this function takes an argument one

715
00:36:58,250 --> 00:37:05,630
argument is a pointer or another is a

716
00:37:00,520 --> 00:37:08,420
integer value and you can see what it

717
00:37:05,630 --> 00:37:13,390
does is that dereferences that pointer

718
00:37:08,420 --> 00:37:16,790
to get a value code X it computes a

719
00:37:13,390 --> 00:37:21,410
value Y by summing X and the value

720
00:37:16,790 --> 00:37:24,770
passed to it it stores Y back at P but

721
00:37:21,410 --> 00:37:26,900
it returns X the original value of the

722
00:37:24,770 --> 00:37:29,300
pointer not the updated version of the

723
00:37:26,900 --> 00:37:32,510
pointer and you can see that in the code

724
00:37:29,300 --> 00:37:35,240
here it's code pretty short remember

725
00:37:32,510 --> 00:37:38,000
that in general Rd I will hold the first

726
00:37:35,240 --> 00:37:39,980
argument in this case it's a pointer so

727
00:37:38,000 --> 00:37:43,040
it will do a read from that pointer and

728
00:37:39,980 --> 00:37:46,010
it will put the value in our ax which is

729
00:37:43,040 --> 00:37:50,240
where the return value should be anyhow

730
00:37:46,010 --> 00:37:53,810
and then it will increment our si which

731
00:37:50,240 --> 00:37:56,330
has the value called Val here initially

732
00:37:53,810 --> 00:38:05,960
and now it has the value of x plus Val

733
00:37:56,330 --> 00:38:09,110
and then it will store that in the value

734
00:38:05,960 --> 00:38:11,060
pointed to by P and it will do a return

735
00:38:09,110 --> 00:38:13,850
so you see these three instructions do

736
00:38:11,060 --> 00:38:16,730
all the different parts of this and as

737
00:38:13,850 --> 00:38:18,920
this shows in general also you know

738
00:38:16,730 --> 00:38:20,450
register usage it's handy by the way to

739
00:38:18,920 --> 00:38:25,160
document this when you're looking at

740
00:38:20,450 --> 00:38:27,770
code rgi is the first argument RSI gets

741
00:38:25,160 --> 00:38:31,100
used initially it's Val but now it will

742
00:38:27,770 --> 00:38:36,020
be set to Y during the call and

743
00:38:31,100 --> 00:38:39,380
similarly our ax is initially the value

744
00:38:36,020 --> 00:38:41,650
well it's it's both what X is here and

745
00:38:39,380 --> 00:38:45,890
it's used as a return value

746
00:38:41,650 --> 00:38:47,180
okay so what's the reason to go through

747
00:38:45,890 --> 00:38:49,430
all that is to actually show you

748
00:38:47,180 --> 00:38:52,460
examples of calling this and how

749
00:38:49,430 --> 00:38:56,080
arguments get passed to the function and

750
00:38:52,460 --> 00:38:56,080
how it makes use of the stack

751
00:38:56,380 --> 00:39:02,900
so now there's a function called call

752
00:38:58,880 --> 00:39:07,040
incre and it's going to create a value

753
00:39:02,900 --> 00:39:10,880
called vet v1 and have to generate a

754
00:39:07,040 --> 00:39:13,220
pointer to that so what that means is v1

755
00:39:10,880 --> 00:39:14,690
can't just stay in a register because

756
00:39:13,220 --> 00:39:17,300
you can't create an address of a

757
00:39:14,690 --> 00:39:19,490
register it has to be stored in memory

758
00:39:17,300 --> 00:39:23,510
somewhere so that you can create a

759
00:39:19,490 --> 00:39:26,510
pointer an address of it and where does

760
00:39:23,510 --> 00:39:28,820
it store it what puts it in the stack so

761
00:39:26,510 --> 00:39:31,970
how does it find space on the stack will

762
00:39:28,820 --> 00:39:33,680
allocate so the function call inker then

763
00:39:31,970 --> 00:39:36,770
and we'll go through all the different

764
00:39:33,680 --> 00:39:42,020
parts of it but you see that this red

765
00:39:36,770 --> 00:39:44,980
code here is generated generates these

766
00:39:42,020 --> 00:39:44,980
two instructions

