1
00:00:00,000 --> 00:00:05,160
it's all good afternoon everybody

2
00:00:01,050 --> 00:00:06,870
welcome good to see you and welcome to

3
00:00:05,160 --> 00:00:11,519
all those who are watching on videotape

4
00:00:06,870 --> 00:00:13,860
as well I want to clear up I realized

5
00:00:11,519 --> 00:00:15,990
after the last lecture that I didn't

6
00:00:13,860 --> 00:00:18,000
explain the idea of peak memory

7
00:00:15,990 --> 00:00:20,730
utilization very well to you so I want

8
00:00:18,000 --> 00:00:22,710
to just explain that it's an important

9
00:00:20,730 --> 00:00:28,140
idea and I want to make sure that that

10
00:00:22,710 --> 00:00:32,430
we have it clear so if you recall recall

11
00:00:28,140 --> 00:00:42,390
from we have we're executing a series a

12
00:00:32,430 --> 00:00:48,989
sequence of requests R 0 R 1 R 2 R K up

13
00:00:42,390 --> 00:00:56,309
to our n minus 1 and at at any point in

14
00:00:48,989 --> 00:01:03,320
time after K 1 k plus 1 requests we have

15
00:00:56,309 --> 00:01:03,320
h K which is the the heap size

16
00:01:05,159 --> 00:01:28,659
after K plus-1 requests then we have an

17
00:01:18,310 --> 00:01:33,159
e K which is the aggregate the the sum

18
00:01:28,659 --> 00:01:38,439
of all of the payloads after k plus 1

19
00:01:33,159 --> 00:01:41,920
requests okay so what we're trying to do

20
00:01:38,439 --> 00:01:45,670
with this this PK measure this aggregate

21
00:01:41,920 --> 00:01:47,590
payload is at any point in time so as we

22
00:01:45,670 --> 00:01:50,979
as we execute requests one after the

23
00:01:47,590 --> 00:01:53,470
other the sum of all the payloads in the

24
00:01:50,979 --> 00:01:56,319
heap is going to increase or decrease

25
00:01:53,470 --> 00:01:58,929
right so if we execute a and allocate

26
00:01:56,319 --> 00:02:02,679
then this the size of the payloads will

27
00:01:58,929 --> 00:02:04,689
increase if we execute a free the size

28
00:02:02,679 --> 00:02:07,720
of all those allocated payloads will

29
00:02:04,689 --> 00:02:10,299
decrease right so so as we're executing

30
00:02:07,720 --> 00:02:12,370
this the sequence of requests these the

31
00:02:10,299 --> 00:02:14,730
aggregate the sum of all the payloads is

32
00:02:12,370 --> 00:02:18,190
going to be increasing and decreasing

33
00:02:14,730 --> 00:02:19,810
okay and so what we're what we're

34
00:02:18,190 --> 00:02:21,639
capturing with the sum of all these

35
00:02:19,810 --> 00:02:24,760
payloads it's like a perfect allocator

36
00:02:21,639 --> 00:02:28,060
that has no overheads and and even more

37
00:02:24,760 --> 00:02:30,430
so one that we can where we're allowed

38
00:02:28,060 --> 00:02:33,359
to compact blocks so the sum of all of

39
00:02:30,430 --> 00:02:37,750
the the payloads is the minimum possible

40
00:02:33,359 --> 00:02:41,079
heap size or it's the minimum possible

41
00:02:37,750 --> 00:02:44,019
number of bytes required by those

42
00:02:41,079 --> 00:02:45,970
allocated blocks okay so it's very very

43
00:02:44,019 --> 00:02:47,920
aggressive and it's impossible to

44
00:02:45,970 --> 00:02:51,459
achieve but we're going to use that as

45
00:02:47,920 --> 00:02:56,790
sort of our best case okay and so to

46
00:02:51,459 --> 00:02:56,790
measure a peak

47
00:02:57,980 --> 00:03:16,019
Piku memory utilization after K plus-1

48
00:03:09,180 --> 00:03:24,840
requests which will denote U of K that's

49
00:03:16,019 --> 00:03:28,489
going to be equal to the max for all I

50
00:03:24,840 --> 00:03:28,489
less than or equal to K

51
00:03:32,450 --> 00:03:40,910
of our aggregate payloads divided by the

52
00:03:38,330 --> 00:03:44,360
size of the heap after after K plus-1

53
00:03:40,910 --> 00:03:47,390
requests okay so what what we're doing

54
00:03:44,360 --> 00:03:50,720
with this knack is we're remembering the

55
00:03:47,390 --> 00:03:53,810
high-water mark you know as our as our

56
00:03:50,720 --> 00:03:55,610
aggregate payloads increase and decrease

57
00:03:53,810 --> 00:03:58,069
we're remembering the high-water mark

58
00:03:55,610 --> 00:03:59,840
right so that was sort of the worst that

59
00:03:58,069 --> 00:04:03,349
was like the biggest set of payloads

60
00:03:59,840 --> 00:04:06,620
that we had and then so the max is

61
00:04:03,349 --> 00:04:09,019
remembering its Ramez remembering that

62
00:04:06,620 --> 00:04:11,480
high-water mark and then we're dividing

63
00:04:09,019 --> 00:04:14,510
by the total size of the heap in order

64
00:04:11,480 --> 00:04:19,070
to get an efficiency measure okay so so

65
00:04:14,510 --> 00:04:21,739
this max DK is kind of this is the best

66
00:04:19,070 --> 00:04:26,889
we could have done divided by the total

67
00:04:21,739 --> 00:04:26,889
the total heap size okay so yes

68
00:04:30,250 --> 00:04:36,380
well the allocator keeps track of of how

69
00:04:33,650 --> 00:04:39,470
big the heap is so that's pretty easy

70
00:04:36,380 --> 00:04:41,780
right so it's every time it every time

71
00:04:39,470 --> 00:04:43,880
it does every time it calls s break it's

72
00:04:41,780 --> 00:04:45,860
just that that adds to the size of the

73
00:04:43,880 --> 00:04:49,759
heap and remember we're we're assuming

74
00:04:45,860 --> 00:04:53,780
that the heat in this case is always

75
00:04:49,759 --> 00:04:55,910
increasing okay so but even if even if

76
00:04:53,780 --> 00:04:58,970
we allow the heap size to decrease could

77
00:04:55,910 --> 00:05:02,590
just if the allocator is controlling the

78
00:04:58,970 --> 00:05:04,930
size of the heap by calls to s break

79
00:05:02,590 --> 00:05:10,449
okay so is that clear

80
00:05:04,930 --> 00:05:13,819
so for UK the higher the better okay and

81
00:05:10,449 --> 00:05:17,479
for any sequence of allocates and freeze

82
00:05:13,819 --> 00:05:20,210
this max PK will be the same okay that's

83
00:05:17,479 --> 00:05:22,610
constant right

84
00:05:20,210 --> 00:05:24,800
but what varies is H of K and that

85
00:05:22,610 --> 00:05:27,370
depends on how efficient your your

86
00:05:24,800 --> 00:05:28,520
allocator is is using the heap storage

87
00:05:27,370 --> 00:05:35,539
okay

88
00:05:28,520 --> 00:05:40,430
yes question so what we're doing is at

89
00:05:35,539 --> 00:05:42,860
any point in time after after k plus 1

90
00:05:40,430 --> 00:05:44,870
requests we're about we're evaluating

91
00:05:42,860 --> 00:05:53,180
the utilization of our heap up till that

92
00:05:44,870 --> 00:06:00,159
point so it should be k 4i i less than

93
00:05:53,180 --> 00:06:00,159
or equal to k oh i'm sorry

94
00:06:10,120 --> 00:06:13,900
yeah sorry good good catch that should

95
00:06:12,400 --> 00:06:17,940
be an eye right we want to look at all

96
00:06:13,900 --> 00:06:25,620
the all the for all the requests that

97
00:06:17,940 --> 00:06:25,620
came before okay any other questions

98
00:06:26,370 --> 00:06:29,370
okay

99
00:06:35,070 --> 00:06:40,900
all right so last time we looked at some

100
00:06:37,870 --> 00:06:43,060
simple the basics of dynamic storage

101
00:06:40,900 --> 00:06:46,770
allocation a we're going to look at some

102
00:06:43,060 --> 00:06:49,120
more sophisticated techniques using

103
00:06:46,770 --> 00:06:53,320
different data structures to store the

104
00:06:49,120 --> 00:06:55,750
free list primarily we'll look at

105
00:06:53,320 --> 00:06:57,910
implicit allocators so we'll get a sort

106
00:06:55,750 --> 00:06:59,650
of a brief survey of how garbage

107
00:06:57,910 --> 00:07:02,949
collectors work and we'll just look at

108
00:06:59,650 --> 00:07:04,210
one just just one very simple kind of

109
00:07:02,949 --> 00:07:07,720
garbage collector but it'll give you an

110
00:07:04,210 --> 00:07:11,530
idea of what that means and then we'll

111
00:07:07,720 --> 00:07:12,850
finish up we'll finish up by looking at

112
00:07:11,530 --> 00:07:16,030
it at all the ways you can get yourself

113
00:07:12,850 --> 00:07:18,580
into trouble by using dynamically

114
00:07:16,030 --> 00:07:20,560
allocated storage so once once you once

115
00:07:18,580 --> 00:07:22,810
you use once you start dynamically

116
00:07:20,560 --> 00:07:25,930
allocating storage things can go really

117
00:07:22,810 --> 00:07:28,180
bad really quickly and so we'll go over

118
00:07:25,930 --> 00:07:31,449
some of those some of those bad things

119
00:07:28,180 --> 00:07:33,010
that can happen and try to alert you to

120
00:07:31,449 --> 00:07:35,460
those so you don't do them in your

121
00:07:33,010 --> 00:07:35,460
programs

122
00:07:43,690 --> 00:07:49,970
okay so we looked at how to store a free

123
00:07:47,840 --> 00:07:53,090
look free list in this sort of implicit

124
00:07:49,970 --> 00:07:55,880
form by just walking the entire heat and

125
00:07:53,090 --> 00:07:58,250
and thereby sort of being able to visit

126
00:07:55,880 --> 00:08:01,460
all the free blocks but we can do better

127
00:07:58,250 --> 00:08:03,319
if we actually have a doubly if we store

128
00:08:01,460 --> 00:08:08,900
the free bought the free list is using

129
00:08:03,319 --> 00:08:11,660
as a doubly linked list so in we call

130
00:08:08,900 --> 00:08:15,410
these explicit free lists so the idea

131
00:08:11,660 --> 00:08:19,400
with an explicit free list is that we

132
00:08:15,410 --> 00:08:21,580
put pointers we put the pointers that

133
00:08:19,400 --> 00:08:25,280
implement this the doubly linked list

134
00:08:21,580 --> 00:08:28,030
inside the the body of a free block

135
00:08:25,280 --> 00:08:30,349
where the old payload used to go so

136
00:08:28,030 --> 00:08:32,120
allocated blocks look exactly the same

137
00:08:30,349 --> 00:08:34,610
as they did the floor right there's a

138
00:08:32,120 --> 00:08:37,130
header boundary tag optional boundary

139
00:08:34,610 --> 00:08:41,390
tag splitter and then this the payload

140
00:08:37,130 --> 00:08:42,860
and any padding free blocks though the

141
00:08:41,390 --> 00:08:46,610
allocated and the allocator is not

142
00:08:42,860 --> 00:08:50,390
allowed to touch anything in the inside

143
00:08:46,610 --> 00:08:52,579
the the payload of an allocated block

144
00:08:50,390 --> 00:08:55,250
but free blocks are free right nobody's

145
00:08:52,579 --> 00:08:58,970
using them and so we the allocator can

146
00:08:55,250 --> 00:09:01,430
put the pointers that implement the data

147
00:08:58,970 --> 00:09:06,050
structure inside the what was the old

148
00:09:01,430 --> 00:09:08,270
payload so logically this is just a

149
00:09:06,050 --> 00:09:13,160
simple doubly linked list that you've

150
00:09:08,270 --> 00:09:15,260
all seen before but actually these

151
00:09:13,160 --> 00:09:19,370
things can be anywhere in memory right

152
00:09:15,260 --> 00:09:23,300
and so you know here we have we have a

153
00:09:19,370 --> 00:09:25,339
block of size six and it has a forward

154
00:09:23,300 --> 00:09:27,440
pointer that points to some other link

155
00:09:25,339 --> 00:09:29,890
and it has a backwards pointer that

156
00:09:27,440 --> 00:09:32,779
points to this block which happens to be

157
00:09:29,890 --> 00:09:37,360
have a greater memory address than than

158
00:09:32,779 --> 00:09:40,010
it okay so just the idea is you can't

159
00:09:37,360 --> 00:09:42,920
you know unless unless you make unless

160
00:09:40,010 --> 00:09:48,009
you go to great pains to maintain this

161
00:09:42,920 --> 00:09:50,329
sort of address ordered structure these

162
00:09:48,009 --> 00:09:57,620
these these blocks can be sort of

163
00:09:50,329 --> 00:10:00,350
scattered anywhere in memory oh yeah so

164
00:09:57,620 --> 00:10:02,899
this is after several you know just sort

165
00:10:00,350 --> 00:10:11,269
of indefinite number of Malik's and

166
00:10:02,899 --> 00:10:12,740
fries and yes oh yeah good question it's

167
00:10:11,269 --> 00:10:14,629
like so the question is what would

168
00:10:12,740 --> 00:10:17,269
happen if you free to a block that was

169
00:10:14,629 --> 00:10:18,860
in between two free blocks and so you

170
00:10:17,269 --> 00:10:22,910
have to coalesce it gets a little tricky

171
00:10:18,860 --> 00:10:31,850
and I'll show you in a second good now

172
00:10:22,910 --> 00:10:33,560
allocating oh yes questions so the

173
00:10:31,850 --> 00:10:36,740
question is what happens with locality

174
00:10:33,560 --> 00:10:39,800
so you still get you still get block

175
00:10:36,740 --> 00:10:45,560
locality you know use blocks are still

176
00:10:39,800 --> 00:10:49,430
contiguous so if but if if you're

177
00:10:45,560 --> 00:10:51,230
scanning sort of a set of allocated

178
00:10:49,430 --> 00:10:53,720
blocks it would be better if you could

179
00:10:51,230 --> 00:10:58,850
keep them all contiguous right that so

180
00:10:53,720 --> 00:11:03,529
it's really and so there's a you know

181
00:10:58,850 --> 00:11:04,939
that's a trade-off I don't it gets

182
00:11:03,529 --> 00:11:06,769
difficult if you think how can you

183
00:11:04,939 --> 00:11:08,870
maintain so you don't really care about

184
00:11:06,769 --> 00:11:13,129
the locality of free blocks right you're

185
00:11:08,870 --> 00:11:14,689
just walking a linked list well no I

186
00:11:13,129 --> 00:11:17,449
shouldn't say that that's if you're

187
00:11:14,689 --> 00:11:20,480
walking that list if you hit one one

188
00:11:17,449 --> 00:11:23,329
free block it would it would bring in a

189
00:11:20,480 --> 00:11:25,910
whole page so it'd be better if you were

190
00:11:23,329 --> 00:11:27,500
walking if the list you know if as much

191
00:11:25,910 --> 00:11:30,459
of that list was contained within that

192
00:11:27,500 --> 00:11:34,430
page so even that so you would benefit

193
00:11:30,459 --> 00:11:35,839
you could benefit with both allocated

194
00:11:34,430 --> 00:11:38,360
blocks because applications would be

195
00:11:35,839 --> 00:11:40,790
using them and with free blocks because

196
00:11:38,360 --> 00:11:44,680
the allocator would be walking that that

197
00:11:40,790 --> 00:11:44,680
free list so question

198
00:11:44,740 --> 00:11:52,209
we could make sense to have a program

199
00:11:48,820 --> 00:11:55,089
that effectively energy to a pre break

200
00:11:52,209 --> 00:11:57,760
so even though they only need two even

201
00:11:55,089 --> 00:11:59,560
though they only alkane into a couple of

202
00:11:57,760 --> 00:12:03,520
mono sir if you know in the future

203
00:11:59,560 --> 00:12:05,380
mentality at Domino them somehow the

204
00:12:03,520 --> 00:12:08,890
alkanes are they we're going to try to

205
00:12:05,380 --> 00:12:10,000
you can help you knowledge about it work

206
00:12:08,890 --> 00:12:11,500
that's a really good question so the

207
00:12:10,000 --> 00:12:14,110
question is could would it be possible

208
00:12:11,500 --> 00:12:16,750
for an application to sort of give hints

209
00:12:14,110 --> 00:12:18,670
to the allocator that would increase

210
00:12:16,750 --> 00:12:22,660
them improve the allocators performance

211
00:12:18,670 --> 00:12:27,700
or memory utilization the the answer you

212
00:12:22,660 --> 00:12:29,200
absolutely could but it's if you did it

213
00:12:27,700 --> 00:12:31,149
wouldn't be a general-purpose allocator

214
00:12:29,200 --> 00:12:34,270
so like malloc it's a general-purpose

215
00:12:31,149 --> 00:12:36,190
allocator so it and it provides no

216
00:12:34,270 --> 00:12:38,020
there's no option it doesn't provide any

217
00:12:36,190 --> 00:12:40,540
arguments in its interface for passing

218
00:12:38,020 --> 00:12:42,790
that information in but it absolutely if

219
00:12:40,540 --> 00:12:45,339
it had some knowledge about the future

220
00:12:42,790 --> 00:12:48,010
behavior of a program that could benefit

221
00:12:45,339 --> 00:12:49,420
right so especially I consider you

222
00:12:48,010 --> 00:12:51,550
always have this decision when you place

223
00:12:49,420 --> 00:12:54,339
an allocated block whether to split that

224
00:12:51,550 --> 00:12:57,550
block or not well if you knew that you

225
00:12:54,339 --> 00:12:59,709
were going to get a request you know for

226
00:12:57,550 --> 00:13:00,760
if you split that block and you knew

227
00:12:59,709 --> 00:13:03,700
that you're going to give requests

228
00:13:00,760 --> 00:13:04,899
coming in the future first for sizes of

229
00:13:03,700 --> 00:13:07,420
the original block then you wouldn't

230
00:13:04,899 --> 00:13:09,520
want to split it because then you would

231
00:13:07,420 --> 00:13:12,610
want it you would just keep it unsplit

232
00:13:09,520 --> 00:13:13,899
and then when you freed it then you'd

233
00:13:12,610 --> 00:13:17,649
have a block that would be the right

234
00:13:13,899 --> 00:13:19,899
size for that that future request and so

235
00:13:17,649 --> 00:13:22,779
it's you can absolutely benefit from

236
00:13:19,899 --> 00:13:24,820
that and so although you can't if

237
00:13:22,779 --> 00:13:26,770
general-purpose allocators there's no

238
00:13:24,820 --> 00:13:28,240
provision for that kind of hinting but

239
00:13:26,770 --> 00:13:30,790
there's nothing to prevent an alligator

240
00:13:28,240 --> 00:13:33,910
from doing predictions based on the the

241
00:13:30,790 --> 00:13:35,230
previous pattern of requests you know so

242
00:13:33,910 --> 00:13:37,029
if you're getting a pattern of requests

243
00:13:35,230 --> 00:13:39,220
it's alternating large block small block

244
00:13:37,029 --> 00:13:41,440
large box small block you could you

245
00:13:39,220 --> 00:13:43,420
could exploit that maybe maybe predict

246
00:13:41,440 --> 00:13:46,329
that the next request will be for a you

247
00:13:43,420 --> 00:13:47,920
know it it's the previous request is for

248
00:13:46,329 --> 00:13:50,279
a large block the next one might be for

249
00:13:47,920 --> 00:13:52,360
a small block and you could

250
00:13:50,279 --> 00:13:54,160
that's a good question any other

251
00:13:52,360 --> 00:14:08,620
questions wizard yep

252
00:13:54,160 --> 00:14:10,899
I don't know I so the question is other

253
00:14:08,620 --> 00:14:13,540
are there intelligent alligators that do

254
00:14:10,899 --> 00:14:15,160
that kind of prediction and if there are

255
00:14:13,540 --> 00:14:29,920
I don't know of them but I wouldn't I

256
00:14:15,160 --> 00:14:32,200
wouldn't say no yes question what would

257
00:14:29,920 --> 00:14:38,200
happen you end up with a free buck up a

258
00:14:32,200 --> 00:14:40,690
block just like it's just a single block

259
00:14:38,200 --> 00:14:44,440
oh so the question is what if you ended

260
00:14:40,690 --> 00:14:47,230
up with a free block that's a single

261
00:14:44,440 --> 00:14:49,750
block surrounded by two allocated blocks

262
00:14:47,230 --> 00:14:52,690
well in fact I mean that's one of the

263
00:14:49,750 --> 00:14:54,850
invariants that a good alligator has to

264
00:14:52,690 --> 00:14:57,010
maintain you should never have two

265
00:14:54,850 --> 00:14:59,380
contiguous free blocks right the

266
00:14:57,010 --> 00:15:02,170
alligator should always be coalescing as

267
00:14:59,380 --> 00:15:05,410
much as it can and if it if it does that

268
00:15:02,170 --> 00:15:07,000
coalescing is it it always does that

269
00:15:05,410 --> 00:15:10,709
coalescing then then there will never be

270
00:15:07,000 --> 00:15:19,769
two contiguous free blocks okay

271
00:15:10,709 --> 00:15:22,529
yes a question oh you'll see when we it

272
00:15:19,769 --> 00:15:25,000
comes into play when we free a block

273
00:15:22,529 --> 00:15:27,820
because you have to sort of stitch up

274
00:15:25,000 --> 00:15:32,079
when you free a block you have to sort

275
00:15:27,820 --> 00:15:34,810
of stitch up the the linked list and so

276
00:15:32,079 --> 00:15:36,640
you need both you need both pointers you

277
00:15:34,810 --> 00:15:38,890
can do it with singly linked list so in

278
00:15:36,640 --> 00:15:41,949
your in the knr book there's a an

279
00:15:38,890 --> 00:15:44,740
alligator that uses a singly linked list

280
00:15:41,949 --> 00:15:46,660
but the the disadvantages that free

281
00:15:44,740 --> 00:15:48,850
requires a search so it requires a

282
00:15:46,660 --> 00:15:52,769
search from the beginning of the list to

283
00:15:48,850 --> 00:15:52,769
find the previous block

284
00:15:54,820 --> 00:16:06,910
and there are questions these are good

285
00:15:56,410 --> 00:16:08,380
yes question okay so the question is for

286
00:16:06,910 --> 00:16:10,750
memory utilization how does the header

287
00:16:08,380 --> 00:16:13,690
and footer count towards memory

288
00:16:10,750 --> 00:16:16,510
utilization and so those those are

289
00:16:13,690 --> 00:16:18,430
overhead that decrease memory

290
00:16:16,510 --> 00:16:20,230
utilization okay because they're not

291
00:16:18,430 --> 00:16:23,170
payload so when we were computing memory

292
00:16:20,230 --> 00:16:26,050
utilization we're doing it by we're

293
00:16:23,170 --> 00:16:31,960
using the payload the aggregate payload

294
00:16:26,050 --> 00:16:34,180
to to to estimate our utilization or to

295
00:16:31,960 --> 00:16:39,270
compute our utilization so anything

296
00:16:34,180 --> 00:16:43,660
that's not payload SAR is is overhead

297
00:16:39,270 --> 00:16:49,180
one word and everything like okay was

298
00:16:43,660 --> 00:16:51,160
also one word so we had if all of our

299
00:16:49,180 --> 00:16:56,280
payloads were one word and our overhead

300
00:16:51,160 --> 00:16:56,280
was was one word then there'd be 50%

301
00:16:58,360 --> 00:17:04,670
yes if you have to book this point into

302
00:17:02,480 --> 00:17:09,230
the next and previously glossy Sony

303
00:17:04,670 --> 00:17:10,400
like whatever like every time yeah so

304
00:17:09,230 --> 00:17:12,800
the question is do you still need a

305
00:17:10,400 --> 00:17:14,360
boundary tag if you have these these

306
00:17:12,800 --> 00:17:17,900
next and previous pointers and the

307
00:17:14,360 --> 00:17:33,290
answer is yes absolutely and you'll see

308
00:17:17,900 --> 00:17:35,090
in a second why yes okay that's a really

309
00:17:33,290 --> 00:17:38,260
good question so you know what do you do

310
00:17:35,090 --> 00:17:40,760
if you have next and previous pointers

311
00:17:38,260 --> 00:17:44,960
what happens if there's a request for a

312
00:17:40,760 --> 00:17:46,970
smaller a smaller block so the answer is

313
00:17:44,960 --> 00:17:48,650
that all of those things the header the

314
00:17:46,970 --> 00:17:51,830
footer the next and previous pointers

315
00:17:48,650 --> 00:17:54,580
impose a minimum block size so if you

316
00:17:51,830 --> 00:17:59,720
have a one-word header one-word footer

317
00:17:54,580 --> 00:18:02,150
one word pre even one word next then

318
00:17:59,720 --> 00:18:04,010
you're your minimum block sizes is four

319
00:18:02,150 --> 00:18:07,190
bytes and that would be with a zero of

320
00:18:04,010 --> 00:18:09,560
zero size payload so you can never

321
00:18:07,190 --> 00:18:11,780
allocate a block smaller than your

322
00:18:09,560 --> 00:18:15,500
minimum block size so that's a very good

323
00:18:11,780 --> 00:18:18,980
very good question so it makes a

324
00:18:15,500 --> 00:18:20,150
difference right even though even though

325
00:18:18,980 --> 00:18:22,520
we're you know it looks like we're

326
00:18:20,150 --> 00:18:25,550
getting these it looks like we're

327
00:18:22,520 --> 00:18:27,170
getting these pointers here for free but

328
00:18:25,550 --> 00:18:33,680
we're not really because of this minimum

329
00:18:27,170 --> 00:18:36,860
block size requirement yep there we go

330
00:18:33,680 --> 00:18:38,990
or allocated gigantic luckily for self

331
00:18:36,860 --> 00:18:43,280
to give you specific different parts of

332
00:18:38,990 --> 00:18:45,380
that because they say one day when I'll

333
00:18:43,280 --> 00:18:49,560
get on a truck analogy since I don't

334
00:18:45,380 --> 00:18:53,430
refresh my page or it's one space so

335
00:18:49,560 --> 00:18:55,620
right but if you want to like take first

336
00:18:53,430 --> 00:18:58,320
half make them drugs take Technic and a

337
00:18:55,620 --> 00:19:03,900
certain something and if we say all of

338
00:18:58,320 --> 00:19:05,880
this up my program ridiculous like so

339
00:19:03,900 --> 00:19:09,510
it's like your movie option for that one

340
00:19:05,880 --> 00:19:13,770
which I get Nick bakas wake up yeah okay

341
00:19:09,510 --> 00:19:16,230
so the question is can you just get a

342
00:19:13,770 --> 00:19:17,880
get one large block and then split it up

343
00:19:16,230 --> 00:19:19,730
and I guess you're assuming that the

344
00:19:17,880 --> 00:19:23,460
requests would be four equally sized

345
00:19:19,730 --> 00:19:26,360
objects right so this and and that's a

346
00:19:23,460 --> 00:19:29,850
really good strategy actually so if you

347
00:19:26,360 --> 00:19:32,520
if you know or if you think that your

348
00:19:29,850 --> 00:19:33,960
workload is going to have no you can't

349
00:19:32,520 --> 00:19:35,850
do this in general-purpose allocators

350
00:19:33,960 --> 00:19:36,840
but for like a special-purpose allocator

351
00:19:35,850 --> 00:19:38,850
if you know that you're going to be

352
00:19:36,840 --> 00:19:41,430
asking for objects that are all the same

353
00:19:38,850 --> 00:19:44,220
size like compilers for example make

354
00:19:41,430 --> 00:19:46,860
maintain abstract syntax trees and

355
00:19:44,220 --> 00:19:50,550
they're allocating nodes dynamically and

356
00:19:46,860 --> 00:19:52,140
those nodes are the same size so if you

357
00:19:50,550 --> 00:19:55,370
can you can exploit that by just

358
00:19:52,140 --> 00:19:57,540
allocating a large chunk and then

359
00:19:55,370 --> 00:20:00,000
allocating all the objects of that size

360
00:19:57,540 --> 00:20:01,890
out of that chunk it's very efficient

361
00:20:00,000 --> 00:20:04,170
you don't even need pointers or anything

362
00:20:01,890 --> 00:20:05,940
all you need is a bit vector to tell you

363
00:20:04,170 --> 00:20:08,340
which chunks are allocated in which

364
00:20:05,940 --> 00:20:10,640
chunks are free and then and you also as

365
00:20:08,340 --> 00:20:13,110
a side-effect you'll get that contiguous

366
00:20:10,640 --> 00:20:17,400
that contiguous access so if a program

367
00:20:13,110 --> 00:20:19,110
access those those objects like to be

368
00:20:17,400 --> 00:20:20,580
part of a linked list there was

369
00:20:19,110 --> 00:20:25,520
something that it was going to traverse

370
00:20:20,580 --> 00:20:26,780
you could allocate those in order and

371
00:20:25,520 --> 00:20:29,070
contiguously

372
00:20:26,780 --> 00:20:31,070
now with with a general-purpose

373
00:20:29,070 --> 00:20:37,190
allocator where you don't really know

374
00:20:31,070 --> 00:20:37,190
what's going to be requested it's

375
00:20:39,510 --> 00:20:44,020
ASL is a sector insulting absolutely you

376
00:20:42,970 --> 00:20:46,240
could do that you can make general

377
00:20:44,020 --> 00:20:47,610
assumptions about the sort of behavior

378
00:20:46,240 --> 00:20:50,320
of your programs and you know you could

379
00:20:47,610 --> 00:20:51,700
you could run traces or like in the case

380
00:20:50,320 --> 00:20:55,210
of malok lab you could look at the

381
00:20:51,700 --> 00:20:58,690
traces but that's no that's a really

382
00:20:55,210 --> 00:21:01,929
good thing you know you can't you're you

383
00:20:58,690 --> 00:21:04,390
can't just like do if statements to say

384
00:21:01,929 --> 00:21:06,600
well if the size is 42 and then the next

385
00:21:04,390 --> 00:21:09,280
size is 24 then I know it's this trace

386
00:21:06,600 --> 00:21:12,100
okay but you can look at a trace and say

387
00:21:09,280 --> 00:21:14,230
there's an interesting pattern here I'm

388
00:21:12,100 --> 00:21:15,820
going to account for that pattern I'm

389
00:21:14,230 --> 00:21:17,650
going to optimize for that pattern and

390
00:21:15,820 --> 00:21:19,270
that that would just and that's

391
00:21:17,650 --> 00:21:21,400
perfectly valid that's just like taking

392
00:21:19,270 --> 00:21:25,860
advantage of your workload right that's

393
00:21:21,400 --> 00:21:25,860
what we do in systems all the time yeah

394
00:21:29,040 --> 00:21:41,970
can we divided up our data which is

395
00:21:38,740 --> 00:21:41,970
stored in some other party

396
00:21:42,669 --> 00:21:47,799
Oh Oh so the question is why can't we

397
00:21:45,359 --> 00:21:49,989
why can't we sort of have separate areas

398
00:21:47,799 --> 00:21:56,109
of the heap for the pointers and the

399
00:21:49,989 --> 00:22:01,779
payloads all right join them up with

400
00:21:56,109 --> 00:22:03,639
pointers oh why not

401
00:22:01,779 --> 00:22:06,820
okay so the question is why not why

402
00:22:03,639 --> 00:22:09,789
can't we split up payloads and link them

403
00:22:06,820 --> 00:22:11,769
together with pointers the answer is

404
00:22:09,789 --> 00:22:14,590
that the applications expecting a

405
00:22:11,769 --> 00:22:17,950
contiguous block you can't allocate or

406
00:22:14,590 --> 00:22:19,869
can't put anything in the payload it all

407
00:22:17,950 --> 00:22:22,389
I can do all it's allowed to do is

408
00:22:19,869 --> 00:22:24,820
return a contiguous block of the size of

409
00:22:22,389 --> 00:22:28,509
the application requested and after once

410
00:22:24,820 --> 00:22:33,489
it does that it can't touch it okay all

411
00:22:28,509 --> 00:22:36,070
right good good all right so let's look

412
00:22:33,489 --> 00:22:38,739
at how we'd allocate and free once if we

413
00:22:36,070 --> 00:22:41,679
have this this explicit list how we

414
00:22:38,739 --> 00:22:45,789
would allocate and free block so

415
00:22:41,679 --> 00:22:48,999
allocating is pretty simple we'll have

416
00:22:45,789 --> 00:22:52,809
so here's our sort of a graphic of our

417
00:22:48,999 --> 00:22:55,960
free list so we have forward pointers

418
00:22:52,809 --> 00:22:57,549
and backward pointers and the idea is we

419
00:22:55,960 --> 00:23:04,659
want to allocate out of this middle

420
00:22:57,549 --> 00:23:08,919
block so we allocate the block of the

421
00:23:04,659 --> 00:23:11,109
size that we need and then we just

422
00:23:08,919 --> 00:23:15,190
update the forward and back pointers of

423
00:23:11,109 --> 00:23:18,940
the previous and next blocks to point to

424
00:23:15,190 --> 00:23:21,100
this new free block okay so that's

425
00:23:18,940 --> 00:23:27,029
pretty simple we're just we're updating

426
00:23:21,100 --> 00:23:27,029
one two three four five six six pointers

427
00:23:28,440 --> 00:23:34,150
okay now give us it gets trickier when

428
00:23:31,300 --> 00:23:37,840
we have to free because because we

429
00:23:34,150 --> 00:23:40,800
require coalescing so when you free a

430
00:23:37,840 --> 00:23:42,970
block that that was previously allocated

431
00:23:40,800 --> 00:23:44,860
the question is what do you do with that

432
00:23:42,970 --> 00:23:47,160
free block right it wasn't in the free

433
00:23:44,860 --> 00:23:49,540
list because it was an allocated block

434
00:23:47,160 --> 00:23:51,460
so now that you've freed the block where

435
00:23:49,540 --> 00:23:54,730
do you put it as you've got to put it

436
00:23:51,460 --> 00:23:57,190
somewhere so that the simplest thing is

437
00:23:54,730 --> 00:23:59,050
this life--all policy so the simplest

438
00:23:57,190 --> 00:24:01,720
thing is just put it at the beginning of

439
00:23:59,050 --> 00:24:04,870
the list so the last block freed is the

440
00:24:01,720 --> 00:24:08,820
first block allocated if it's it's okay

441
00:24:04,870 --> 00:24:10,990
so that's so-called like oh now this is

442
00:24:08,820 --> 00:24:12,250
simple because you're always doing the

443
00:24:10,990 --> 00:24:14,830
same thing you're just putting the block

444
00:24:12,250 --> 00:24:16,510
at the beginning the list and it's

445
00:24:14,830 --> 00:24:20,710
constant time you're just updating a few

446
00:24:16,510 --> 00:24:23,890
pointers okay but the study suggests

447
00:24:20,710 --> 00:24:26,230
that the the fragmentation can be worse

448
00:24:23,890 --> 00:24:28,680
than the alternative technique which is

449
00:24:26,230 --> 00:24:32,830
to keep the blocks ordered by address

450
00:24:28,680 --> 00:24:34,630
okay so when uh if you if you if you

451
00:24:32,830 --> 00:24:37,710
choose this address ordered policy when

452
00:24:34,630 --> 00:24:40,090
you when you free an allocated block

453
00:24:37,710 --> 00:24:42,220
you're going to somehow figure out

454
00:24:40,090 --> 00:24:44,860
you're going to somehow place that block

455
00:24:42,220 --> 00:24:47,230
in the list so that the previous block

456
00:24:44,860 --> 00:24:50,020
begins at a smaller address and the next

457
00:24:47,230 --> 00:24:51,610
block begins at a larger address right

458
00:24:50,020 --> 00:24:54,370
so this generally involves some kind of

459
00:24:51,610 --> 00:24:56,770
search right you don't you're just given

460
00:24:54,370 --> 00:24:58,450
this allocated block and then somehow

461
00:24:56,770 --> 00:25:00,640
you've got and you know its address and

462
00:24:58,450 --> 00:25:04,210
so now you've got to somehow search the

463
00:25:00,640 --> 00:25:06,910
the free list to find the you know the

464
00:25:04,210 --> 00:25:08,590
proper place to insert it now I suppose

465
00:25:06,910 --> 00:25:10,690
you could do better if you had some kind

466
00:25:08,590 --> 00:25:13,270
of so if you could speed up that search

467
00:25:10,690 --> 00:25:16,720
with some kind of balance tree that

468
00:25:13,270 --> 00:25:18,550
would be one option right but then that

469
00:25:16,720 --> 00:25:21,490
the problem we always run into with

470
00:25:18,550 --> 00:25:23,320
balance trees and usually is one student

471
00:25:21,490 --> 00:25:24,970
at lea somebody always tries to

472
00:25:23,320 --> 00:25:26,590
implement malloc with a some kind of

473
00:25:24,970 --> 00:25:30,700
balance tree red-black tree or something

474
00:25:26,590 --> 00:25:32,980
and it seems like a really good idea but

475
00:25:30,700 --> 00:25:37,210
you have to realize that you're you're

476
00:25:32,980 --> 00:25:40,240
competing with with other techniques

477
00:25:37,210 --> 00:25:43,000
specifically segregated lists that are

478
00:25:40,240 --> 00:25:46,029
very fast and have very small constant

479
00:25:43,000 --> 00:25:48,460
factors and there's even though even

480
00:25:46,029 --> 00:25:51,460
though ordered lists are I think it's

481
00:25:48,460 --> 00:25:54,970
usually n log in to update an order tree

482
00:25:51,460 --> 00:25:56,950
upon your ordered tree that constant

483
00:25:54,970 --> 00:25:59,799
factors can be can be quite large and so

484
00:25:56,950 --> 00:26:03,279
usually get nailed up with the constant

485
00:25:59,799 --> 00:26:05,169
factors of maintaining the tree and you

486
00:26:03,279 --> 00:26:08,380
don't get help that the search time is

487
00:26:05,169 --> 00:26:13,809
log n but as we'll see with segregated

488
00:26:08,380 --> 00:26:15,970
lists in the in the limit as in the

489
00:26:13,809 --> 00:26:18,850
limit as the number of different size

490
00:26:15,970 --> 00:26:21,190
classes increases the the search time

491
00:26:18,850 --> 00:26:23,679
approaches constant time and if you if

492
00:26:21,190 --> 00:26:25,779
you have size classes that cover ranges

493
00:26:23,679 --> 00:26:28,210
of powers of two then the search time

494
00:26:25,779 --> 00:26:31,000
reduces to a long time anyway because

495
00:26:28,210 --> 00:26:36,669
the the size of each classes are now

496
00:26:31,000 --> 00:26:40,330
logarithmic the log so you know I would

497
00:26:36,669 --> 00:26:41,919
suggest done you know just doing a

498
00:26:40,330 --> 00:26:44,679
simple thing usually whenever you're

499
00:26:41,919 --> 00:26:46,360
you're dealt with sort of large design

500
00:26:44,679 --> 00:26:48,970
space like malakut you're better off

501
00:26:46,360 --> 00:26:50,649
doing the simple thing and then

502
00:26:48,970 --> 00:26:54,039
optimizing only when you see that

503
00:26:50,649 --> 00:26:56,320
there's that you need to optimize okay

504
00:26:54,039 --> 00:26:58,840
so remember last time we talked about

505
00:26:56,320 --> 00:27:01,690
this trick to to eliminate the boundary

506
00:26:58,840 --> 00:27:03,520
tag footer and allocated blocks that's

507
00:27:01,690 --> 00:27:08,500
an example of an optimization you should

508
00:27:03,520 --> 00:27:10,450
defer so that wait you know wait get do

509
00:27:08,500 --> 00:27:14,860
the simple thing and then try to improve

510
00:27:10,450 --> 00:27:17,110
incrementally by int by you know there's

511
00:27:14,860 --> 00:27:21,010
just this optimization or another

512
00:27:17,110 --> 00:27:22,750
optimization so there's this phenomena

513
00:27:21,010 --> 00:27:24,370
of a lot of lot of programmers make a

514
00:27:22,750 --> 00:27:26,919
mistake of what we call premature

515
00:27:24,370 --> 00:27:28,990
optimization so try to think of all the

516
00:27:26,919 --> 00:27:30,480
fancy things they can do and then they

517
00:27:28,990 --> 00:27:32,679
put all those in at the beginning and

518
00:27:30,480 --> 00:27:33,460
before they even know that it needs to

519
00:27:32,679 --> 00:27:36,070
be optimized

520
00:27:33,460 --> 00:27:39,010
okay so D so the way you want to work on

521
00:27:36,070 --> 00:27:42,220
this and any any sort of complex problem

522
00:27:39,010 --> 00:27:44,020
like like an alligator is to you know

523
00:27:42,220 --> 00:27:46,510
first do fairly simple things and then

524
00:27:44,020 --> 00:27:48,669
look and see where where the slowdowns

525
00:27:46,510 --> 00:27:49,380
are inefficiencies are and then just

526
00:27:48,669 --> 00:27:51,180
sort of

527
00:27:49,380 --> 00:27:52,710
hit those one after the other and

528
00:27:51,180 --> 00:27:55,890
optimize only for the things that are

529
00:27:52,710 --> 00:28:01,860
necessary and this is a good example of

530
00:27:55,890 --> 00:28:10,020
that okay now to get to your question

531
00:28:01,860 --> 00:28:11,670
about freeing freeing is tough because

532
00:28:10,020 --> 00:28:13,200
we always have to do this coalescing

533
00:28:11,670 --> 00:28:17,250
right because of this invariant that we

534
00:28:13,200 --> 00:28:20,070
can never have to free blocks to

535
00:28:17,250 --> 00:28:22,080
adjacent free blocks so let's go through

536
00:28:20,070 --> 00:28:23,790
each of those four cases that we went

537
00:28:22,080 --> 00:28:28,440
over last time and see how we would do

538
00:28:23,790 --> 00:28:31,740
it now that we have this just this

539
00:28:28,440 --> 00:28:34,410
explicit free list so here we have the

540
00:28:31,740 --> 00:28:36,840
root of our free list pointing to the

541
00:28:34,410 --> 00:28:39,390
first block in the free list there's a

542
00:28:36,840 --> 00:28:41,100
null back pointer and then that there's

543
00:28:39,390 --> 00:28:43,800
a null pre pointer and then the next

544
00:28:41,100 --> 00:28:47,370
next pointer points to some unspecified

545
00:28:43,800 --> 00:28:49,590
block and so we have this yellow block

546
00:28:47,370 --> 00:28:51,930
which is allocated and now the

547
00:28:49,590 --> 00:28:53,400
application is called free free with a

548
00:28:51,930 --> 00:28:57,330
pointer that points the beginning of

549
00:28:53,400 --> 00:28:59,070
this block so what do we do well this

550
00:28:57,330 --> 00:29:02,130
case is pretty simple because there's no

551
00:28:59,070 --> 00:29:06,770
coalescing because both the predecessor

552
00:29:02,130 --> 00:29:10,440
and successor blocks are are allocated

553
00:29:06,770 --> 00:29:12,090
okay so we just this newly freed block

554
00:29:10,440 --> 00:29:14,400
now becomes we're going to do a LIFO

555
00:29:12,090 --> 00:29:17,430
policy so this becomes the first block

556
00:29:14,400 --> 00:29:19,800
in the free list and so we update the

557
00:29:17,430 --> 00:29:21,900
route to point to this this newly freed

558
00:29:19,800 --> 00:29:23,580
block and we update the forward pointer

559
00:29:21,900 --> 00:29:27,410
of that block to point to what used to

560
00:29:23,580 --> 00:29:27,410
be the first block in the heap

561
00:29:29,000 --> 00:29:36,120
now I'm going to be careful it's a

562
00:29:33,480 --> 00:29:39,450
little bit confusing because we've got

563
00:29:36,120 --> 00:29:42,330
sort of two notions of like previous and

564
00:29:39,450 --> 00:29:44,510
next right there's the you know given

565
00:29:42,330 --> 00:29:47,610
some given some block

566
00:29:44,510 --> 00:29:50,730
there's the predecessor block in memory

567
00:29:47,610 --> 00:29:52,260
which may or may not be allocated or

568
00:29:50,730 --> 00:29:55,650
free right it may or may not be in a

569
00:29:52,260 --> 00:29:57,480
free list and there's a successor block

570
00:29:55,650 --> 00:30:02,310
okay so we'll use predecessor and

571
00:29:57,480 --> 00:30:05,580
successor to distinguish adjacency in

572
00:30:02,310 --> 00:30:08,250
memory okay and we'll use pre even next

573
00:30:05,580 --> 00:30:13,710
to denote adjacency in the free list

574
00:30:08,250 --> 00:30:15,990
okay so this this block is the next

575
00:30:13,710 --> 00:30:19,880
block for the current block and it has

576
00:30:15,990 --> 00:30:19,880
no previous block okay

577
00:30:20,290 --> 00:30:26,530
all right now what about case to number

578
00:30:22,540 --> 00:30:29,920
case to the predecessor block is free

579
00:30:26,530 --> 00:30:33,340
and the successor block is is allocated

580
00:30:29,920 --> 00:30:38,200
and now we want to free this what was an

581
00:30:33,340 --> 00:30:41,620
allocated block denoted by yellow and we

582
00:30:38,200 --> 00:30:43,240
have this this successor this

583
00:30:41,620 --> 00:30:46,570
predecessor block is part of the free

584
00:30:43,240 --> 00:30:48,640
list right so it has it has previous and

585
00:30:46,570 --> 00:30:51,490
next blocks that are just part of the

586
00:30:48,640 --> 00:30:52,930
free list and so our route points to the

587
00:30:51,490 --> 00:30:57,040
first block in the list and then

588
00:30:52,930 --> 00:30:59,560
eventually you get to this free block

589
00:30:57,040 --> 00:31:02,920
which points to this free block which

590
00:30:59,560 --> 00:31:05,830
points to this free block okay so what

591
00:31:02,920 --> 00:31:09,430
we have to do then is we have to

592
00:31:05,830 --> 00:31:12,880
coalesce these two these two blocks into

593
00:31:09,430 --> 00:31:14,860
one big free block okay and then we have

594
00:31:12,880 --> 00:31:20,500
to splice it out and stick it at the

595
00:31:14,860 --> 00:31:20,980
beginning of the list okay so what that

596
00:31:20,500 --> 00:31:25,300
looks like

597
00:31:20,980 --> 00:31:27,400
conceptually is we we we coalesce these

598
00:31:25,300 --> 00:31:32,910
two blocks now to form this one free

599
00:31:27,400 --> 00:31:36,160
block and then we splice it out by

600
00:31:32,910 --> 00:31:38,920
having what was the what was its

601
00:31:36,160 --> 00:31:40,660
previous block now point to what used to

602
00:31:38,920 --> 00:31:46,170
be the next block okay

603
00:31:40,660 --> 00:31:46,170
fix of the current block okay so this

604
00:31:46,800 --> 00:31:53,200
the pointer from this block now points

605
00:31:50,410 --> 00:31:55,210
to this block okay and then the so we've

606
00:31:53,200 --> 00:31:58,270
effectively spliced that that current

607
00:31:55,210 --> 00:32:00,310
block out of the free list and then the

608
00:31:58,270 --> 00:32:02,560
root we have the root point to that

609
00:32:00,310 --> 00:32:05,010
block so that's now the new first block

610
00:32:02,560 --> 00:32:05,010
of the list

611
00:32:07,020 --> 00:32:11,260
okay and then we have to update what

612
00:32:09,670 --> 00:32:14,740
used to be the first block in the list

613
00:32:11,260 --> 00:32:19,150
so now it points back to the the newly

614
00:32:14,740 --> 00:32:25,510
freed coalesce block so that cleared

615
00:32:19,150 --> 00:32:27,280
everybody its yep so with the rupiah

616
00:32:25,510 --> 00:32:31,600
global variable it could be or it could

617
00:32:27,280 --> 00:32:32,830
be there's there's two ways to do this

618
00:32:31,600 --> 00:32:38,200
right it could just be a global variable

619
00:32:32,830 --> 00:32:40,600
or it could be a it could be a struct

620
00:32:38,200 --> 00:32:42,370
that of like previous the next pointer

621
00:32:40,600 --> 00:32:44,170
so sometimes it's easier if you keep the

622
00:32:42,370 --> 00:32:46,120
same you know when you're doing linked

623
00:32:44,170 --> 00:32:47,800
lists that the route if you just make it

624
00:32:46,120 --> 00:32:49,780
the same as all the other nodes it can

625
00:32:47,800 --> 00:32:51,760
simplify things but yeah it could be a

626
00:32:49,780 --> 00:33:00,040
global variable global scalar in the

627
00:32:51,760 --> 00:33:01,600
allocator okay so case oh now one thing

628
00:33:00,040 --> 00:33:05,260
one thing that comes to mind there is

629
00:33:01,600 --> 00:33:10,390
like there is an optimization that we

630
00:33:05,260 --> 00:33:13,750
could do in this case do you see when we

631
00:33:10,390 --> 00:33:16,120
when we coalesce we could just leave

632
00:33:13,750 --> 00:33:18,820
that block right there in the free list

633
00:33:16,120 --> 00:33:20,920
right we did although I believe adopted

634
00:33:18,820 --> 00:33:24,540
so the examples I'm going to show you

635
00:33:20,920 --> 00:33:27,010
are assuming a LIFO policy for insertion

636
00:33:24,540 --> 00:33:29,200
we could just leave it there right that

637
00:33:27,010 --> 00:33:31,210
and just don't update anything just

638
00:33:29,200 --> 00:33:34,000
increase create this newly coalesce

639
00:33:31,210 --> 00:33:35,470
block and then mentally we don't require

640
00:33:34,000 --> 00:33:38,800
in this case we wouldn't require any

641
00:33:35,470 --> 00:33:40,350
free list manipulation okay but that

642
00:33:38,800 --> 00:33:43,650
would be that would be one of these

643
00:33:40,350 --> 00:33:43,650
optimizations right

644
00:33:43,940 --> 00:33:51,620
now case three if you recall is the case

645
00:33:49,400 --> 00:33:54,790
where the the predecessor block is

646
00:33:51,620 --> 00:33:57,790
allocated and the successor block is

647
00:33:54,790 --> 00:33:57,790
freed

648
00:34:00,380 --> 00:34:05,690
the successor block is free so in this

649
00:34:04,309 --> 00:34:08,569
case what we have to do is we have to

650
00:34:05,690 --> 00:34:13,310
create we have to coalesce the newly

651
00:34:08,569 --> 00:34:16,609
freed block with the with the successor

652
00:34:13,310 --> 00:34:20,379
block and then we have to splice it out

653
00:34:16,609 --> 00:34:25,940
in just the same way we did in case two

654
00:34:20,379 --> 00:34:27,859
so we splice it out of the the list and

655
00:34:25,940 --> 00:34:30,020
then put it at the beginning of the list

656
00:34:27,859 --> 00:34:32,780
by pointing the root at it and then

657
00:34:30,020 --> 00:34:35,329
updating what used to be the first block

658
00:34:32,780 --> 00:34:38,419
in the list updating its back pointer

659
00:34:35,329 --> 00:34:41,000
it's pre pointer to point to the this

660
00:34:38,419 --> 00:34:43,369
newly coalesced block okay so it's this

661
00:34:41,000 --> 00:34:46,849
is completely symmetric with the case

662
00:34:43,369 --> 00:34:48,889
that we looked at before but now we no

663
00:34:46,849 --> 00:34:50,839
longer have it's a little bit trickier

664
00:34:48,889 --> 00:34:53,540
if we just wanted to leave this block in

665
00:34:50,839 --> 00:34:56,300
the free list we'd have to update all

666
00:34:53,540 --> 00:34:57,859
these pointers to point back to the

667
00:34:56,300 --> 00:35:03,170
beginning of the newly created block

668
00:34:57,859 --> 00:35:06,440
okay so there's so in this case there's

669
00:35:03,170 --> 00:35:07,730
no performance optimization right we're

670
00:35:06,440 --> 00:35:09,710
still updating the same number of

671
00:35:07,730 --> 00:35:11,869
pointers whether we put it in the

672
00:35:09,710 --> 00:35:15,670
beginning of the list or if we if we

673
00:35:11,869 --> 00:35:15,670
splice it or if we leave it there

674
00:35:17,200 --> 00:35:22,720
and now case four is the that's the case

675
00:35:21,099 --> 00:35:26,799
where both the predecessor and successor

676
00:35:22,720 --> 00:35:32,109
blocks are free so we have to apply the

677
00:35:26,799 --> 00:35:36,369
same slicing technique to both the the

678
00:35:32,109 --> 00:35:39,819
predecessor block and we have to we have

679
00:35:36,369 --> 00:35:43,720
to create this new coalesced block and

680
00:35:39,819 --> 00:35:45,069
then we have to splice we have to we

681
00:35:43,720 --> 00:35:50,740
have to sort of splice it out by

682
00:35:45,069 --> 00:35:56,349
updating two different sets of previous

683
00:35:50,740 --> 00:36:00,010
and successor blocks okay so when we

684
00:35:56,349 --> 00:36:01,930
when we're finished with that the this

685
00:36:00,010 --> 00:36:07,030
newly coalesced block now is the first

686
00:36:01,930 --> 00:36:09,849
block in the in the heap the four in the

687
00:36:07,030 --> 00:36:11,470
free list and we spliced it we spliced

688
00:36:09,849 --> 00:36:14,970
it out from these two different parts of

689
00:36:11,470 --> 00:36:14,970
the the free list

690
00:36:17,440 --> 00:36:27,080
okay so any questions about this is this

691
00:36:22,670 --> 00:36:30,770
is where you really it looks it looks

692
00:36:27,080 --> 00:36:34,850
really simple to do but I guarantee you

693
00:36:30,770 --> 00:36:36,560
this will be some of the hardest it's

694
00:36:34,850 --> 00:36:37,820
only like 200 lines of code but some of

695
00:36:36,560 --> 00:36:41,900
the hardest code you'll have to write

696
00:36:37,820 --> 00:36:43,370
because you you're sort of free of the

697
00:36:41,900 --> 00:36:45,440
C's type system you have to do

698
00:36:43,370 --> 00:36:47,150
everything by explicitly casting these

699
00:36:45,440 --> 00:36:52,490
pointers are just in the middle of

700
00:36:47,150 --> 00:36:54,290
arbitrary blocks and so it looks simple

701
00:36:52,490 --> 00:36:55,520
with the diagram but you're going to

702
00:36:54,290 --> 00:37:00,680
have to be really careful when you do

703
00:36:55,520 --> 00:37:03,680
this in fact what I would suggest the

704
00:37:00,680 --> 00:37:05,690
best suggestion I can give you is it is

705
00:37:03,680 --> 00:37:08,420
to start with the implicit list

706
00:37:05,690 --> 00:37:10,040
allocator that we describe in the book

707
00:37:08,420 --> 00:37:12,140
which is too slow to get any credit

708
00:37:10,040 --> 00:37:16,610
terrible allocator but it contains all

709
00:37:12,140 --> 00:37:19,040
the basic ideas and then write function

710
00:37:16,610 --> 00:37:20,570
write a function called insert block and

711
00:37:19,040 --> 00:37:23,810
write another function called remove

712
00:37:20,570 --> 00:37:26,210
block that inserts a block into the free

713
00:37:23,810 --> 00:37:29,300
list and removes a block from the free

714
00:37:26,210 --> 00:37:31,640
list respectively and if you if you

715
00:37:29,300 --> 00:37:33,050
write if you abstract it like that if

716
00:37:31,640 --> 00:37:36,050
you use that kind of abstraction it's

717
00:37:33,050 --> 00:37:37,940
pretty simple to to convert the implicit

718
00:37:36,050 --> 00:37:42,050
list allocator to an explicit list

719
00:37:37,940 --> 00:37:45,020
allocator okay it'll still be too slow

720
00:37:42,050 --> 00:37:50,150
to get so then that will go from like an

721
00:37:45,020 --> 00:37:52,490
F allocator to a b- allocator and then

722
00:37:50,150 --> 00:37:54,740
to really make a good allocator like an

723
00:37:52,490 --> 00:37:58,660
a allocator you need to use sugar is

724
00:37:54,740 --> 00:37:58,660
lists which we'll look at in a second

725
00:37:59,040 --> 00:38:04,390
okay so the explicit list now the the

726
00:38:02,290 --> 00:38:06,339
allocation time is linear in the number

727
00:38:04,390 --> 00:38:11,170
of free blocks instead of the total size

728
00:38:06,339 --> 00:38:13,119
of the instead of the total size of the

729
00:38:11,170 --> 00:38:14,500
heap so it's this is much faster than

730
00:38:13,119 --> 00:38:17,470
that when you have a lot of allocated

731
00:38:14,500 --> 00:38:19,660
blocks it's a little more complicated

732
00:38:17,470 --> 00:38:24,300
because of all the splicing business and

733
00:38:19,660 --> 00:38:27,490
and you do need some extra space in your

734
00:38:24,300 --> 00:38:29,290
for these pointers which increases the

735
00:38:27,490 --> 00:38:36,369
minimum block size and creates

736
00:38:29,290 --> 00:38:38,770
additional overhead now the link list

737
00:38:36,369 --> 00:38:41,470
the explicit list allocators aren't

738
00:38:38,770 --> 00:38:43,800
really sufficient enough to be used for

739
00:38:41,470 --> 00:38:47,890
sort of general purpose real-life

740
00:38:43,800 --> 00:38:49,809
allocator but they are useful in as part

741
00:38:47,890 --> 00:38:52,660
of a segregated list allocator so you

742
00:38:49,809 --> 00:38:54,780
can have you can have multiple free

743
00:38:52,660 --> 00:38:57,640
lists each of which is an explicit list

744
00:38:54,780 --> 00:39:01,420
and it's fine for that for that

745
00:38:57,640 --> 00:39:03,760
application alright so let's look at our

746
00:39:01,420 --> 00:39:07,359
third method which is to create call a

747
00:39:03,760 --> 00:39:09,549
segregated free list which is to have

748
00:39:07,359 --> 00:39:14,700
multiple free lists with different size

749
00:39:09,549 --> 00:39:20,349
classes so the the idea is that each

750
00:39:14,700 --> 00:39:23,020
each class of sizes block sizes has its

751
00:39:20,349 --> 00:39:24,700
own free list and that that class can be

752
00:39:23,020 --> 00:39:27,549
singleton you know maybe a one

753
00:39:24,700 --> 00:39:30,160
particular size or it can be a range of

754
00:39:27,549 --> 00:39:32,740
sizes so you might you might have a

755
00:39:30,160 --> 00:39:35,859
number of different you know if your if

756
00:39:32,740 --> 00:39:37,690
your if your workload consists of a lot

757
00:39:35,859 --> 00:39:38,980
of these small blocks and you know that

758
00:39:37,690 --> 00:39:42,040
there's going to be a lot of requests

759
00:39:38,980 --> 00:39:45,880
for blocks of 1 through 4 you can have

760
00:39:42,040 --> 00:39:48,309
different free lists for those small for

761
00:39:45,880 --> 00:39:50,440
those small block sizes and then after

762
00:39:48,309 --> 00:39:52,720
that you can go and just do ranges of

763
00:39:50,440 --> 00:39:55,660
power of 2 so that's a that's a common

764
00:39:52,720 --> 00:39:57,849
technique so here we have a size class

765
00:39:55,660 --> 00:40:02,859
that covers blocks from size 5 to 8 and

766
00:39:57,849 --> 00:40:05,460
then another size class that covers

767
00:40:02,859 --> 00:40:05,460
everything else

768
00:40:06,309 --> 00:40:11,510
so the idea with the seg list allocators

769
00:40:09,230 --> 00:40:14,329
that given a given an array of these

770
00:40:11,510 --> 00:40:17,059
free lists one each one for for some

771
00:40:14,329 --> 00:40:20,450
size class if we want to allocate a

772
00:40:17,059 --> 00:40:22,849
block of size n then we we go to the

773
00:40:20,450 --> 00:40:25,279
appropriate free list right there's only

774
00:40:22,849 --> 00:40:29,089
there's always going to be one free list

775
00:40:25,279 --> 00:40:31,069
for any any end and then we search that

776
00:40:29,089 --> 00:40:34,579
list just like we did before

777
00:40:31,069 --> 00:40:40,010
for some size if a block size M greater

778
00:40:34,579 --> 00:40:43,880
than n and then if we find it then we

779
00:40:40,010 --> 00:40:46,039
place we place the new block we place

780
00:40:43,880 --> 00:40:49,339
the block in that in the block that we

781
00:40:46,039 --> 00:40:51,020
found we split it and we take this the

782
00:40:49,339 --> 00:40:53,299
split block and we put it into the

783
00:40:51,020 --> 00:40:55,730
appropriate size class so that the block

784
00:40:53,299 --> 00:40:57,559
that we split off may or may not may or

785
00:40:55,730 --> 00:40:59,660
may not belong to the current size class

786
00:40:57,559 --> 00:41:02,359
anymore and so we may have to move it

787
00:40:59,660 --> 00:41:06,950
and insert it into a whatever the

788
00:41:02,359 --> 00:41:09,049
appropriate size class is if there's no

789
00:41:06,950 --> 00:41:11,079
block if we can't find a block then we

790
00:41:09,049 --> 00:41:14,180
have to try the next larger size class

791
00:41:11,079 --> 00:41:16,220
okay so it's possible for a given size

792
00:41:14,180 --> 00:41:22,069
class they're just there might not be a

793
00:41:16,220 --> 00:41:24,109
block that fits so I mean one so we just

794
00:41:22,069 --> 00:41:26,029
have to we go to the next size we try

795
00:41:24,109 --> 00:41:28,099
the next larger class and chances are

796
00:41:26,029 --> 00:41:31,849
we'll find a block that fits there and

797
00:41:28,099 --> 00:41:33,559
if we and you keep doing that until you

798
00:41:31,849 --> 00:41:35,569
eventually if you can't find it you're

799
00:41:33,559 --> 00:41:38,119
eventually looking in the size class

800
00:41:35,569 --> 00:41:41,059
that that that covers all the rest the

801
00:41:38,119 --> 00:41:44,920
last size class and if then you can't

802
00:41:41,059 --> 00:41:48,980
find it then that the allocator has to

803
00:41:44,920 --> 00:41:51,279
allocate more memory with by colleen s

804
00:41:48,980 --> 00:41:51,279
break

805
00:41:52,570 --> 00:41:57,050
okay to free a block you coalesce like

806
00:41:55,610 --> 00:41:59,630
before and then you place it on the

807
00:41:57,050 --> 00:42:01,430
appropriate list so that's that's

808
00:41:59,630 --> 00:42:03,710
straightforward and again you have this

809
00:42:01,430 --> 00:42:05,690
option to try to maintain the listed

810
00:42:03,710 --> 00:42:07,070
address ordered or just do the simple

811
00:42:05,690 --> 00:42:12,940
thing and put it at the beginning of the

812
00:42:07,070 --> 00:42:17,410
list okay so say egg list alligators are

813
00:42:12,940 --> 00:42:20,390
that by far the best type of alligator

814
00:42:17,410 --> 00:42:23,320
because they they offer you improvements

815
00:42:20,390 --> 00:42:26,990
in both performance throughput and

816
00:42:23,320 --> 00:42:28,640
memory utilization so they're faster

817
00:42:26,990 --> 00:42:31,580
they have higher throughputs because the

818
00:42:28,640 --> 00:42:34,370
the individual size classes are are

819
00:42:31,580 --> 00:42:37,100
smaller then than just like the one

820
00:42:34,370 --> 00:42:41,270
giant free list but also you're

821
00:42:37,100 --> 00:42:43,250
searching you know that the list that

822
00:42:41,270 --> 00:42:44,810
you're searching is going to be close to

823
00:42:43,250 --> 00:42:47,690
the size that you're looking for so the

824
00:42:44,810 --> 00:42:50,420
chances of finding something quickly in

825
00:42:47,690 --> 00:42:52,310
that in that particular size class are

826
00:42:50,420 --> 00:42:55,250
higher than they are if you're just

827
00:42:52,310 --> 00:42:57,200
searching on you know a single free list

828
00:42:55,250 --> 00:42:59,390
that holds all different size classes

829
00:42:57,200 --> 00:43:03,920
okay so search is faster so that

830
00:42:59,390 --> 00:43:06,350
increases increases throughput but the

831
00:43:03,920 --> 00:43:09,080
big thing about egg list alligators is

832
00:43:06,350 --> 00:43:11,540
that like we talked about before they

833
00:43:09,080 --> 00:43:14,240
approximate best fit without sacrificing

834
00:43:11,540 --> 00:43:16,970
performance right before if we wanted to

835
00:43:14,240 --> 00:43:18,590
do best fit on a single a free list we

836
00:43:16,970 --> 00:43:21,250
had to search the whole free list and

837
00:43:18,590 --> 00:43:24,830
then choose the block that's it the best

838
00:43:21,250 --> 00:43:28,100
in this case we get we get best fit for

839
00:43:24,830 --> 00:43:34,880
free by by virtue of having these size

840
00:43:28,100 --> 00:43:36,800
classes and so this is you know this is

841
00:43:34,880 --> 00:43:40,780
this is how you can improve your your

842
00:43:36,800 --> 00:43:40,780
memory utilization yes

843
00:43:44,259 --> 00:43:52,819
to me this alligator and more bite or

844
00:43:50,049 --> 00:43:56,930
next oh yeah yeah good question so the

845
00:43:52,819 --> 00:43:59,420
question is is is break constant time it

846
00:43:56,930 --> 00:44:01,970
is but it's very expensive so it's a

847
00:43:59,420 --> 00:44:04,729
Cisco so it has to pass from user space

848
00:44:01,970 --> 00:44:08,239
into the kernel that involves changing

849
00:44:04,729 --> 00:44:12,710
contacts changing stacks so it's this

850
00:44:08,239 --> 00:44:14,630
call generally you can you can count on

851
00:44:12,710 --> 00:44:17,660
assist call being like several hundred

852
00:44:14,630 --> 00:44:21,349
microseconds okay it's a non-trivial

853
00:44:17,660 --> 00:44:22,880
overhead and so in that case you

854
00:44:21,349 --> 00:44:25,910
wouldn't want you you want to amortize

855
00:44:22,880 --> 00:44:28,940
the cost of the of the break by

856
00:44:25,910 --> 00:44:30,140
allocating a somewhat larger chunk but

857
00:44:28,940 --> 00:44:32,239
you have to be careful if you allocate

858
00:44:30,140 --> 00:44:34,190
too large of a chunk then your memory

859
00:44:32,239 --> 00:44:35,420
utilization goes down so it's a

860
00:44:34,190 --> 00:44:41,059
trade-off it's another one of these

861
00:44:35,420 --> 00:44:43,970
space-time trade-offs question so where

862
00:44:41,059 --> 00:44:45,319
do you store this array of free list so

863
00:44:43,970 --> 00:44:50,269
you store it in the beginning of the

864
00:44:45,319 --> 00:44:52,579
heat yeah in fact for your Mallik lab we

865
00:44:50,269 --> 00:44:56,599
require you to do that we don't know and

866
00:44:52,579 --> 00:44:59,690
the reason is we can't bat that array of

867
00:44:56,599 --> 00:45:01,219
sex in some small part depending on how

868
00:44:59,690 --> 00:45:04,009
large that array is it affects your

869
00:45:01,219 --> 00:45:06,880
memory utilization and so it should be

870
00:45:04,009 --> 00:45:06,880
at the beginning of the heat

871
00:45:12,200 --> 00:45:19,530
okay there's a allocators have been

872
00:45:16,050 --> 00:45:24,900
around forever and the the the classic

873
00:45:19,530 --> 00:45:26,940
references Canute's the 1973 text and

874
00:45:24,900 --> 00:45:29,940
there's also this great paper which you

875
00:45:26,940 --> 00:45:33,390
can get from the book's website from

876
00:45:29,940 --> 00:45:35,580
1995 that does a survey of you know

877
00:45:33,390 --> 00:45:37,020
little dozens and dozens of techniques

878
00:45:35,580 --> 00:45:39,270
like we're just scratching the surface

879
00:45:37,020 --> 00:45:42,480
here so if you're really interested in

880
00:45:39,270 --> 00:45:44,310
this stuff that that papers a

881
00:45:42,480 --> 00:45:50,220
fascinating read and it may give you

882
00:45:44,310 --> 00:45:53,850
some ideas for your prelab okay now so

883
00:45:50,220 --> 00:45:55,650
far we're assuming that the application

884
00:45:53,850 --> 00:45:59,910
is responsible for both allocating

885
00:45:55,650 --> 00:46:02,700
storage and freeing storage but there's

886
00:45:59,910 --> 00:46:06,690
there a form of memory managers called

887
00:46:02,700 --> 00:46:09,720
implicit memory managers that do the

888
00:46:06,690 --> 00:46:11,280
freeing for you so so applications

889
00:46:09,720 --> 00:46:13,320
allocate space but they never have to

890
00:46:11,280 --> 00:46:18,630
worry about freeing space the system

891
00:46:13,320 --> 00:46:24,090
does that automatically and so the the

892
00:46:18,630 --> 00:46:26,490
idea is to identify so-called garbage so

893
00:46:24,090 --> 00:46:29,490
areas of memory that can never be

894
00:46:26,490 --> 00:46:31,760
referenced anymore and then free up

895
00:46:29,490 --> 00:46:34,680
those blocks

896
00:46:31,760 --> 00:46:36,900
so what's garbage well here's an example

897
00:46:34,680 --> 00:46:40,680
we have a function foo that now likes

898
00:46:36,900 --> 00:46:44,460
128 bytes it stores the address in this

899
00:46:40,680 --> 00:46:47,280
pointer P and then at some point when it

900
00:46:44,460 --> 00:46:48,840
returns from foo this pointer is lost

901
00:46:47,280 --> 00:46:52,230
forever right because P is a local

902
00:46:48,840 --> 00:46:54,960
variable on the stack so once once this

903
00:46:52,230 --> 00:46:57,750
function returns that the block of

904
00:46:54,960 --> 00:47:00,390
memory pointed to by P is garbage can

905
00:46:57,750 --> 00:47:01,860
never be referenced again because

906
00:47:00,390 --> 00:47:05,550
there's no way there's no way for the

907
00:47:01,860 --> 00:47:08,190
program to get get access to that and so

908
00:47:05,550 --> 00:47:10,800
what an allocator will recognize at some

909
00:47:08,190 --> 00:47:12,960
point that this block of of memory is

910
00:47:10,800 --> 00:47:14,790
garbage and that it will free those

911
00:47:12,960 --> 00:47:18,060
blocks by calling free it's the same

912
00:47:14,790 --> 00:47:22,020
kind of exactly the same free call as

913
00:47:18,060 --> 00:47:23,460
we've discussed but now it's called by

914
00:47:22,020 --> 00:47:26,040
the garbage collector not

915
00:47:23,460 --> 00:47:29,670
the application okay so you see this in

916
00:47:26,040 --> 00:47:31,590
all different kinds of dynamic languages

917
00:47:29,670 --> 00:47:35,220
and there's there's there's also

918
00:47:31,590 --> 00:47:40,440
variants available for C but because of

919
00:47:35,220 --> 00:47:42,420
C's pointer properties that the garbage

920
00:47:40,440 --> 00:47:44,490
collectors for C are conservative in the

921
00:47:42,420 --> 00:47:47,280
sense that there's some blocks won't be

922
00:47:44,490 --> 00:47:49,740
freed there's some garbage blocks that

923
00:47:47,280 --> 00:47:53,790
that won't be free because the allocator

924
00:47:49,740 --> 00:47:55,890
can't determine that that they are

925
00:47:53,790 --> 00:47:59,430
indeed garbage so it has to be careful

926
00:47:55,890 --> 00:48:01,830
when it whenever there's a doubt it it

927
00:47:59,430 --> 00:48:08,460
leaves it doesn't reclaim the the

928
00:48:01,830 --> 00:48:09,690
allocated block so it gets to this

929
00:48:08,460 --> 00:48:13,520
question of like how does the memory

930
00:48:09,690 --> 00:48:17,160
manager know when memory can be free and

931
00:48:13,520 --> 00:48:18,720
you know if we knew if somehow we knew

932
00:48:17,160 --> 00:48:21,600
we could predict all of the future

933
00:48:18,720 --> 00:48:23,490
requests and then if we knew that there

934
00:48:21,600 --> 00:48:25,830
were no future requests access that

935
00:48:23,490 --> 00:48:30,620
block and we could free it okay but we

936
00:48:25,830 --> 00:48:33,630
can't predict that okay so we have to

937
00:48:30,620 --> 00:48:35,400
but if there's no pointers if no

938
00:48:33,630 --> 00:48:37,130
pointers exist to a particular block

939
00:48:35,400 --> 00:48:39,570
then we know that it can't be accessed

940
00:48:37,130 --> 00:48:42,780
okay and so that we can predict right if

941
00:48:39,570 --> 00:48:46,590
there's some way we can sort of a scan

942
00:48:42,780 --> 00:48:48,960
the program identify or scan the memory

943
00:48:46,590 --> 00:48:51,930
identify all the pointers in that memory

944
00:48:48,960 --> 00:48:54,600
and and see which which blocks have

945
00:48:51,930 --> 00:48:56,310
pointed to and it's there if they're not

946
00:48:54,600 --> 00:49:00,090
pointed to by any pointer then then

947
00:48:56,310 --> 00:49:04,380
they're garbage by definition okay so to

948
00:49:00,090 --> 00:49:06,450
do this though it's difficult so first

949
00:49:04,380 --> 00:49:07,980
of all the memory manager has to be able

950
00:49:06,450 --> 00:49:10,830
to distinguish pointers from non

951
00:49:07,980 --> 00:49:11,670
pointers which we can't do and see right

952
00:49:10,830 --> 00:49:14,640
they're just these

953
00:49:11,670 --> 00:49:18,360
they're just these integral values right

954
00:49:14,640 --> 00:49:20,820
we don't know it could be it if we see

955
00:49:18,360 --> 00:49:24,990
this large integral value this large

956
00:49:20,820 --> 00:49:26,640
long eight byte value it could be it

957
00:49:24,990 --> 00:49:28,230
could be pointing to a data structure it

958
00:49:26,640 --> 00:49:33,720
could just be a large integer right we

959
00:49:28,230 --> 00:49:35,160
don't know and then we also all pointers

960
00:49:33,720 --> 00:49:37,549
have to point to the start of a block

961
00:49:35,160 --> 00:49:41,130
which is not true and see either

962
00:49:37,549 --> 00:49:43,140
okay so if we have a pointer and we

963
00:49:41,130 --> 00:49:45,359
identify that at the pointer then we

964
00:49:43,140 --> 00:49:47,640
know that it points it points to some

965
00:49:45,359 --> 00:49:49,140
block if it points inside of a block how

966
00:49:47,640 --> 00:49:51,630
do we how do we find the beginning of

967
00:49:49,140 --> 00:49:53,910
that block you know how do we know how

968
00:49:51,630 --> 00:49:55,460
big that block is so it has to point to

969
00:49:53,910 --> 00:50:01,619
the beginning of the block or the header

970
00:49:55,460 --> 00:50:02,970
tells us the size and the and and and

971
00:50:01,619 --> 00:50:04,559
there can't be a way to hide pointers

972
00:50:02,970 --> 00:50:07,099
the point that the property of being a

973
00:50:04,559 --> 00:50:11,849
pointer has to be some kind of static

974
00:50:07,099 --> 00:50:13,079
saying that doesn't that can't change so

975
00:50:11,849 --> 00:50:14,280
that's sort of the challenges if you're

976
00:50:13,079 --> 00:50:15,630
thinking about how in the world can you

977
00:50:14,280 --> 00:50:17,819
implement a garbage collector so those

978
00:50:15,630 --> 00:50:20,579
are some of the challenges that that

979
00:50:17,819 --> 00:50:23,490
they present and because of that it's

980
00:50:20,579 --> 00:50:26,750
been a history of research and garbage

981
00:50:23,490 --> 00:50:29,880
collectors it is old its ancient and

982
00:50:26,750 --> 00:50:31,710
ongoing it's still it's still ongoing

983
00:50:29,880 --> 00:50:33,890
today particularly in the context of

984
00:50:31,710 --> 00:50:35,819
parallel programs and garbage collecting

985
00:50:33,890 --> 00:50:37,799
programs that are running multiple

986
00:50:35,819 --> 00:50:40,950
threads so there's a whole bunch of

987
00:50:37,799 --> 00:50:43,500
these things that people have looked at

988
00:50:40,950 --> 00:50:46,200
going all the way back to 1960

989
00:50:43,500 --> 00:50:48,660
today we'll look at we'll look at the

990
00:50:46,200 --> 00:50:50,460
simplest what one of the simpler

991
00:50:48,660 --> 00:50:52,589
variants called mark-and-sweep and we

992
00:50:50,460 --> 00:50:53,670
won't we won't discuss the rest but if

993
00:50:52,589 --> 00:50:55,980
you're interested in them there's a

994
00:50:53,670 --> 00:51:00,540
pretty good book that describes that

995
00:50:55,980 --> 00:51:03,119
describes these things all right so how

996
00:51:00,540 --> 00:51:05,910
do we build an allocator so we start by

997
00:51:03,119 --> 00:51:10,559
viewing memory as a directed graph where

998
00:51:05,910 --> 00:51:18,200
each each node in the graph corresponds

999
00:51:10,559 --> 00:51:18,200
to a block okay a block a heap block and

1000
00:51:18,500 --> 00:51:26,970
eaten out an allocated heap block and

1001
00:51:23,660 --> 00:51:30,329
each edge is a pointer that's contained

1002
00:51:26,970 --> 00:51:34,170
somewhere within that block pointer to

1003
00:51:30,329 --> 00:51:36,510
another block and then there's a and

1004
00:51:34,170 --> 00:51:39,240
then there's special nodes called root

1005
00:51:36,510 --> 00:51:40,710
nodes that contain pointers into the

1006
00:51:39,240 --> 00:51:43,170
heap but they're not part of the heap so

1007
00:51:40,710 --> 00:51:45,510
for example pointers that are stored on

1008
00:51:43,170 --> 00:51:48,839
the stack pointers that are stored in

1009
00:51:45,510 --> 00:51:49,770
registers they point to memory locations

1010
00:51:48,839 --> 00:51:54,960
in the heap

1011
00:51:49,770 --> 00:51:57,210
but nothing nothing and but there

1012
00:51:54,960 --> 00:51:59,250
outside of the heat so and we call those

1013
00:51:57,210 --> 00:52:00,690
root notes so nothing points to them or

1014
00:51:59,250 --> 00:52:03,050
at least if something does point to them

1015
00:52:00,690 --> 00:52:05,100
we don't care about what it is okay

1016
00:52:03,050 --> 00:52:08,940
we're only we're only concerned about

1017
00:52:05,100 --> 00:52:12,920
characterizing nodes that correspond to

1018
00:52:08,940 --> 00:52:15,630
memory in the heap so I we say that a

1019
00:52:12,920 --> 00:52:20,400
node or a block is reachable if there's

1020
00:52:15,630 --> 00:52:22,860
some path from a root node from a root

1021
00:52:20,400 --> 00:52:24,930
node to that block so and we've denoted

1022
00:52:22,860 --> 00:52:27,000
those by green so all of these green

1023
00:52:24,930 --> 00:52:28,590
blocks in the heap are reachable because

1024
00:52:27,000 --> 00:52:31,080
you can start at a root node and just

1025
00:52:28,590 --> 00:52:34,550
follow some some sequence of pointers to

1026
00:52:31,080 --> 00:52:39,390
get to that node okay

1027
00:52:34,550 --> 00:52:41,670
notes that aren't reachable are called

1028
00:52:39,390 --> 00:52:44,010
our garbage because there's no there's

1029
00:52:41,670 --> 00:52:46,530
no way to get to them from the root

1030
00:52:44,010 --> 00:52:48,810
nodes okay so there's no node inside the

1031
00:52:46,530 --> 00:52:51,600
heat that points to them and there's no

1032
00:52:48,810 --> 00:52:53,250
node there's no root node that points to

1033
00:52:51,600 --> 00:52:55,380
them so basically there's just no path

1034
00:52:53,250 --> 00:52:58,740
from a root node that'll get you to one

1035
00:52:55,380 --> 00:53:03,150
of these non reachable or garbage nodes

1036
00:52:58,740 --> 00:53:04,440
and since they're non reachable the

1037
00:53:03,150 --> 00:53:06,540
application will never be able to

1038
00:53:04,440 --> 00:53:08,910
reference them in the future so we can

1039
00:53:06,540 --> 00:53:12,500
predict with certainty that that those

1040
00:53:08,910 --> 00:53:15,030
are garbage and they can be freed okay

1041
00:53:12,500 --> 00:53:17,990
so basically after we free these then

1042
00:53:15,030 --> 00:53:17,990
they're removed from the graph

1043
00:53:22,510 --> 00:53:28,970
so now we can we can build a simple

1044
00:53:27,079 --> 00:53:30,920
garbage collector on top of the existing

1045
00:53:28,970 --> 00:53:32,839
malloc and free package right so you

1046
00:53:30,920 --> 00:53:39,200
implement now I can free just like

1047
00:53:32,839 --> 00:53:42,230
before and then you if the program calls

1048
00:53:39,200 --> 00:53:44,089
malloc just like before and you just you

1049
00:53:42,230 --> 00:53:46,430
do malloc exactly the same way until you

1050
00:53:44,089 --> 00:53:48,079
run out of space by whatever definition

1051
00:53:46,430 --> 00:53:50,390
you want to use of running out of space

1052
00:53:48,079 --> 00:53:52,849
maybe you have some kind of maximum each

1053
00:53:50,390 --> 00:53:54,470
size you're willing to use or at some

1054
00:53:52,849 --> 00:53:59,619
point the OS will just stop giving you

1055
00:53:54,470 --> 00:53:59,619
virtual memory when you run out of space

1056
00:54:00,280 --> 00:54:07,040
you you add an extra mark bit into the

1057
00:54:05,210 --> 00:54:08,440
header of each block so this could be

1058
00:54:07,040 --> 00:54:11,240
you know we have like three or four

1059
00:54:08,440 --> 00:54:13,369
spare bits that we can use in the header

1060
00:54:11,240 --> 00:54:16,520
so we can denote one of those that's the

1061
00:54:13,369 --> 00:54:21,170
mark bit and then we are garbage

1062
00:54:16,520 --> 00:54:24,130
collection our garbage collection phase

1063
00:54:21,170 --> 00:54:26,960
when we run out of space consists of two

1064
00:54:24,130 --> 00:54:28,819
two different sub phases one is the mark

1065
00:54:26,960 --> 00:54:32,300
phase which starts at all the roots and

1066
00:54:28,819 --> 00:54:35,660
then and it just traverses this from the

1067
00:54:32,300 --> 00:54:37,339
roots it traverses the set of of nodes

1068
00:54:35,660 --> 00:54:39,140
that are reachable from the root and it

1069
00:54:37,339 --> 00:54:43,460
sets the mark that in each each one of

1070
00:54:39,140 --> 00:54:46,579
those nodes ok and then once after you

1071
00:54:43,460 --> 00:54:48,440
finish marking all of the all of the

1072
00:54:46,579 --> 00:54:50,270
reachable blocks then you sweep through

1073
00:54:48,440 --> 00:54:53,829
the entire heap starting at the very

1074
00:54:50,270 --> 00:54:56,540
beginning of the heap and you look for

1075
00:54:53,829 --> 00:54:58,849
you look for all allocated blocks that

1076
00:54:56,540 --> 00:55:00,170
aren't marked okay because they're not

1077
00:54:58,849 --> 00:55:02,109
marked they're not reachable in their

1078
00:55:00,170 --> 00:55:06,800
garbage

1079
00:55:02,109 --> 00:55:10,490
sofirst so you do this so you sort of do

1080
00:55:06,800 --> 00:55:12,050
- you do a search from the from the

1081
00:55:10,490 --> 00:55:14,650
roots and then you do a sweep of the

1082
00:55:12,050 --> 00:55:14,650
entire heat

1083
00:55:17,070 --> 00:55:24,640
so let's say before the for mark we have

1084
00:55:20,140 --> 00:55:26,170
a before the marks phase we have a heap

1085
00:55:24,640 --> 00:55:29,860
that looks like this we have a single

1086
00:55:26,170 --> 00:55:30,670
root that points to this block and what

1087
00:55:29,860 --> 00:55:33,550
we're going to do here we're always

1088
00:55:30,670 --> 00:55:35,890
going to point to the payload right of

1089
00:55:33,550 --> 00:55:39,100
the of the block just a convention that

1090
00:55:35,890 --> 00:55:41,050
we use so we're pointing to the

1091
00:55:39,100 --> 00:55:44,560
beginning of the block because we know

1092
00:55:41,050 --> 00:55:49,390
that it's we know that the the header is

1093
00:55:44,560 --> 00:55:53,410
one one word behind it and so let's say

1094
00:55:49,390 --> 00:55:55,150
and in this case the the edges denote

1095
00:55:53,410 --> 00:55:56,920
pointers that are contained in the block

1096
00:55:55,150 --> 00:55:58,510
so they're not the previous and next

1097
00:55:56,920 --> 00:56:00,190
pointers that we were maintaining these

1098
00:55:58,510 --> 00:56:04,840
are just pointers that the application

1099
00:56:00,190 --> 00:56:06,480
has put into those blocks so we have so

1100
00:56:04,840 --> 00:56:10,510
here we have the root pointing to this

1101
00:56:06,480 --> 00:56:12,220
central block and then there's and and

1102
00:56:10,510 --> 00:56:14,020
there's a pointer that points to this

1103
00:56:12,220 --> 00:56:16,450
block and there's another pointer that

1104
00:56:14,020 --> 00:56:18,040
points to this block and and there's a

1105
00:56:16,450 --> 00:56:21,970
pointer in this block that points to

1106
00:56:18,040 --> 00:56:25,270
this block so after we do the mark and

1107
00:56:21,970 --> 00:56:28,119
we search this we search these blocks

1108
00:56:25,270 --> 00:56:30,310
and all of the reachable blocks have the

1109
00:56:28,119 --> 00:56:33,400
mark bit set which is denoted by tink

1110
00:56:30,310 --> 00:56:35,440
and so then you see a net and then the

1111
00:56:33,400 --> 00:56:39,430
the blocks that aren't aren't marked

1112
00:56:35,440 --> 00:56:41,460
then we can free and return to the free

1113
00:56:39,430 --> 00:56:41,460
list

1114
00:56:42,720 --> 00:56:46,890
okay so let's look at the assumptions

1115
00:56:44,849 --> 00:56:49,650
for a simple implementation just to make

1116
00:56:46,890 --> 00:56:52,500
make sure this is clear so the

1117
00:56:49,650 --> 00:56:54,390
application calls new to get a pointer

1118
00:56:52,500 --> 00:56:59,160
to a block with with all those values

1119
00:56:54,390 --> 00:57:03,290
cleared it calls read D I to read

1120
00:56:59,160 --> 00:57:07,230
location I of Block B and it uses write

1121
00:57:03,290 --> 00:57:09,869
div to write a value V into location I

1122
00:57:07,230 --> 00:57:12,180
of Block B then each block will have a

1123
00:57:09,869 --> 00:57:17,640
header word which will address as B of

1124
00:57:12,180 --> 00:57:22,020
minus 1 and then the garbage collector

1125
00:57:17,640 --> 00:57:25,470
has it has functions that it uses to

1126
00:57:22,020 --> 00:57:27,599
identify whether a pointer whether its

1127
00:57:25,470 --> 00:57:29,069
input parameter is indeed a pointer ok

1128
00:57:27,599 --> 00:57:31,800
so there's some way to distinguish a

1129
00:57:29,069 --> 00:57:34,740
pointer from an on pointer and it can

1130
00:57:31,800 --> 00:57:36,240
get the length of some block not

1131
00:57:34,740 --> 00:57:42,290
including the header and it can get a

1132
00:57:36,240 --> 00:57:45,660
set of all of the routes so given those

1133
00:57:42,290 --> 00:57:50,849
given those assumptions we our

1134
00:57:45,660 --> 00:57:54,390
pseudocode for the mark step it takes so

1135
00:57:50,849 --> 00:57:58,920
this initially is a is a pointer a route

1136
00:57:54,390 --> 00:58:01,680
pointer okay and then we check as our

1137
00:57:58,920 --> 00:58:03,839
terminating condition we check to see if

1138
00:58:01,680 --> 00:58:08,490
that that input is indeed a pointer and

1139
00:58:03,839 --> 00:58:11,099
if so we return okay and then then we do

1140
00:58:08,490 --> 00:58:16,230
a depth-first traversal of the of the

1141
00:58:11,099 --> 00:58:17,880
graph so if and this so we're doing a

1142
00:58:16,230 --> 00:58:19,109
depth-first traversal of the graph and

1143
00:58:17,880 --> 00:58:21,089
this is pointer is sort of our

1144
00:58:19,109 --> 00:58:24,660
terminating condition for that that

1145
00:58:21,089 --> 00:58:26,460
depth-first traversal then we check the

1146
00:58:24,660 --> 00:58:27,869
mark bit and if it's set then that's

1147
00:58:26,460 --> 00:58:30,990
another terminating condition there's no

1148
00:58:27,869 --> 00:58:35,099
there's no reason to search once we find

1149
00:58:30,990 --> 00:58:36,869
a marked marked node we know that all of

1150
00:58:35,099 --> 00:58:39,720
everything reachable from that node is

1151
00:58:36,869 --> 00:58:42,930
is marked so we we can terminate our

1152
00:58:39,720 --> 00:58:45,089
return and just stop the search if it's

1153
00:58:42,930 --> 00:58:50,089
not set then we set the mark bit and

1154
00:58:45,089 --> 00:58:50,089
then we look at each word in the block

1155
00:58:50,820 --> 00:58:55,350
and we recursively call mark on each one

1156
00:58:53,430 --> 00:58:57,120
of those words now each one of those

1157
00:58:55,350 --> 00:58:59,820
words may or may not be a pointer right

1158
00:58:57,120 --> 00:59:03,540
so if it's not a pointer then mark will

1159
00:58:59,820 --> 00:59:05,450
just return instantly immediately if it

1160
00:59:03,540 --> 00:59:09,180
is a pointer then it will continue the

1161
00:59:05,450 --> 00:59:10,680
recursive depth first search okay so

1162
00:59:09,180 --> 00:59:13,650
does that make sense it's just a

1163
00:59:10,680 --> 00:59:18,710
familiar the familiar depth-first graph

1164
00:59:13,650 --> 00:59:23,130
traversal of it that we all know about

1165
00:59:18,710 --> 00:59:25,200
okay and then the sweep sweep take a

1166
00:59:23,130 --> 00:59:27,210
pointer to the beginning of the heat

1167
00:59:25,200 --> 00:59:29,970
this first take the pointer to the first

1168
00:59:27,210 --> 00:59:33,960
block in the heat and then some pointer

1169
00:59:29,970 --> 00:59:36,900
to the end of the heat and then in a

1170
00:59:33,960 --> 00:59:40,500
while loop then it scans the heap each

1171
00:59:36,900 --> 00:59:42,740
block if the mark bit is set it clears

1172
00:59:40,500 --> 00:59:42,740
it

1173
00:59:44,770 --> 00:59:51,930
if it if it's allocated it frees it

1174
00:59:49,510 --> 00:59:51,930
right

1175
00:59:53,070 --> 00:59:57,570
and then it updates and then it gets the

1176
00:59:55,230 --> 01:00:05,670
address of the the next block and then

1177
00:59:57,570 --> 01:00:07,500
just continues until the end okay so how

1178
01:00:05,670 --> 01:00:08,970
do we do such a thing in C right because

1179
01:00:07,500 --> 01:00:11,250
all of these assumptions I've made don't

1180
01:00:08,970 --> 01:00:13,290
hold and C you can't tell a pointer from

1181
01:00:11,250 --> 01:00:19,590
an on pointer pointers can point

1182
01:00:13,290 --> 01:00:27,770
anywhere so what you could do so the big

1183
01:00:19,590 --> 01:00:30,180
issue is that if we get some value we it

1184
01:00:27,770 --> 01:00:33,830
even if it is a pointer it could point

1185
01:00:30,180 --> 01:00:33,830
right into the middle of the block so

1186
01:00:34,160 --> 01:00:38,910
given that so first of all we don't know

1187
01:00:37,230 --> 01:00:41,160
if that value really is a pointer it

1188
01:00:38,910 --> 01:00:42,840
could just be a big integer but it also

1189
01:00:41,160 --> 01:00:46,770
could be a pointer that's pointing into

1190
01:00:42,840 --> 01:00:49,260
some data structure so if it is a

1191
01:00:46,770 --> 01:00:52,800
pointer how do we how do we find the

1192
01:00:49,260 --> 01:00:55,770
beginning of the block so what we could

1193
01:00:52,800 --> 01:00:58,740
do is just assume that every value is a

1194
01:00:55,770 --> 01:01:00,540
pointer and then we maintain a balance

1195
01:00:58,740 --> 01:01:02,730
tree to keep track of all the allocated

1196
01:01:00,540 --> 01:01:05,280
blocks and so whenever we encounter a

1197
01:01:02,730 --> 01:01:08,550
particular value we would search that

1198
01:01:05,280 --> 01:01:11,880
binary tree to see if it assuming it is

1199
01:01:08,550 --> 01:01:13,770
a pointer is it falls within the the

1200
01:01:11,880 --> 01:01:17,580
beginning and end of some allocated

1201
01:01:13,770 --> 01:01:19,650
block okay if if that condition is true

1202
01:01:17,580 --> 01:01:21,420
then we assume that it's pointing that

1203
01:01:19,650 --> 01:01:24,390
that's a pointer to an allocated block

1204
01:01:21,420 --> 01:01:26,370
and we assume that that block is

1205
01:01:24,390 --> 01:01:28,080
reachable now the reason it's

1206
01:01:26,370 --> 01:01:29,250
conservative is because it really may

1207
01:01:28,080 --> 01:01:31,380
not be a pointer it might be this

1208
01:01:29,250 --> 01:01:33,720
integer and we'll we'll assume it's a

1209
01:01:31,380 --> 01:01:36,360
pointer and assume that the block that

1210
01:01:33,720 --> 01:01:39,120
it purportedly points to is allocated

1211
01:01:36,360 --> 01:01:41,130
but it may in fact be not be a pointer

1212
01:01:39,120 --> 01:01:43,440
and the block that it points to is

1213
01:01:41,130 --> 01:01:46,890
garbage right so what with this with

1214
01:01:43,440 --> 01:01:51,420
this scheme we would leave some some non

1215
01:01:46,890 --> 01:01:53,490
non reachable blocks we will indicate

1216
01:01:51,420 --> 01:01:56,300
that some non reachable blocks are are

1217
01:01:53,490 --> 01:01:56,300
really reachable

1218
01:01:56,640 --> 01:02:03,519
okay so so once now that we've got this

1219
01:02:01,359 --> 01:02:07,450
great tool to dynamically allocate

1220
01:02:03,519 --> 01:02:09,489
memory we can use it in our programs and

1221
01:02:07,450 --> 01:02:11,289
shoot ourselves in the foot in all

1222
01:02:09,489 --> 01:02:13,989
different kinds of ways okay so I'm

1223
01:02:11,289 --> 01:02:16,839
going to I'm going to try to help help

1224
01:02:13,989 --> 01:02:18,910
you out here by identifying some of the

1225
01:02:16,839 --> 01:02:21,390
perils and pitfalls that that we can run

1226
01:02:18,910 --> 01:02:26,130
into it with with memory related

1227
01:02:21,390 --> 01:02:29,650
operations or operations on memory and

1228
01:02:26,130 --> 01:02:34,960
opera errors errors involving memory are

1229
01:02:29,650 --> 01:02:37,569
the worst the worst kinds of bugs to try

1230
01:02:34,960 --> 01:02:39,609
to find out and the reason is that

1231
01:02:37,569 --> 01:02:42,190
they're distant in both space and time

1232
01:02:39,609 --> 01:02:44,019
so let's say you write to the wrong

1233
01:02:42,190 --> 01:02:47,769
memory location and corrupt some data

1234
01:02:44,019 --> 01:02:51,579
structures the right doesn't elicit any

1235
01:02:47,769 --> 01:02:53,769
error you only find out about that illy

1236
01:02:51,579 --> 01:02:55,450
that erroneous right when you try to

1237
01:02:53,769 --> 01:02:56,979
reference that data structure or that

1238
01:02:55,450 --> 01:02:59,319
particular part of the data structure

1239
01:02:56,979 --> 01:03:01,479
which may be in a part of the code

1240
01:02:59,319 --> 01:03:04,539
that's way far away from the right that

1241
01:03:01,479 --> 01:03:06,460
caused the problem both in space you

1242
01:03:04,539 --> 01:03:07,539
know in distance you know lines of code

1243
01:03:06,460 --> 01:03:08,859
it could be a completely different

1244
01:03:07,539 --> 01:03:11,739
function and a completely different

1245
01:03:08,859 --> 01:03:13,719
module but also in time it may not you

1246
01:03:11,739 --> 01:03:16,809
know you may do the right and then eons

1247
01:03:13,719 --> 01:03:18,160
later other some read and it fails right

1248
01:03:16,809 --> 01:03:20,769
so this is a fundamental thing that

1249
01:03:18,160 --> 01:03:26,130
makes memory related bugs just so nasty

1250
01:03:20,769 --> 01:03:30,700
and another big thing another thing that

1251
01:03:26,130 --> 01:03:32,680
makes them hard to deal with is people's

1252
01:03:30,700 --> 01:03:34,660
misunderstanding and misuse of pointers

1253
01:03:32,680 --> 01:03:38,440
right so usually an erroneous right is

1254
01:03:34,660 --> 01:03:40,960
some is some either a misunderstanding

1255
01:03:38,440 --> 01:03:43,180
of pointers or an improperly initialized

1256
01:03:40,960 --> 01:03:48,579
pointer so it all boils down to these

1257
01:03:43,180 --> 01:03:52,719
pointers okay and so I'm going to show

1258
01:03:48,579 --> 01:03:55,650
you how to understand pointers okay for

1259
01:03:52,719 --> 01:03:55,650
the first time in your lives

1260
01:03:55,690 --> 01:04:02,290
I don't know about you but when I

1261
01:03:57,640 --> 01:04:04,150
learned C I learned about pointers I

1262
01:04:02,290 --> 01:04:06,310
just knew about what a few different

1263
01:04:04,150 --> 01:04:08,980
types of pointers were by and I did it

1264
01:04:06,310 --> 01:04:12,640
by pattern matching so I knew that int

1265
01:04:08,980 --> 01:04:15,490
star P was a pointer to an int I knew

1266
01:04:12,640 --> 01:04:19,540
that int star star P was was an array

1267
01:04:15,490 --> 01:04:21,730
I knew that int star key Open bracket

1268
01:04:19,540 --> 01:04:24,460
close bracket was also an array just a

1269
01:04:21,730 --> 01:04:27,730
different way to express that a race I

1270
01:04:24,460 --> 01:04:29,650
had a small handful of pointers types

1271
01:04:27,730 --> 01:04:31,810
that I could deal with but I had no

1272
01:04:29,650 --> 01:04:33,339
underlying understanding of what that

1273
01:04:31,810 --> 01:04:35,829
meant or anything was just pure pattern

1274
01:04:33,339 --> 01:04:37,349
matching and I'll bet you that's the way

1275
01:04:35,829 --> 01:04:39,190
you do it too

1276
01:04:37,349 --> 01:04:40,829
all right but that's all going to change

1277
01:04:39,190 --> 01:04:44,619
today

1278
01:04:40,829 --> 01:04:47,140
all right so in order to really

1279
01:04:44,619 --> 01:04:50,290
understand pointers you need to

1280
01:04:47,140 --> 01:04:53,890
understand the precedence of various

1281
01:04:50,290 --> 01:04:55,900
operators in C because the pointer types

1282
01:04:53,890 --> 01:04:59,710
are declared using these operators and

1283
01:04:55,900 --> 01:05:03,339
so my copy of K and R it has a dog-eared

1284
01:04:59,710 --> 01:05:06,130
at page 53 this table comes from page 53

1285
01:05:03,339 --> 01:05:09,630
of knr and you should have a paper clip

1286
01:05:06,130 --> 01:05:13,900
or have that folded over for reference

1287
01:05:09,630 --> 01:05:16,390
now the thing to notice is that function

1288
01:05:13,900 --> 01:05:18,819
and array and then and these struct

1289
01:05:16,390 --> 01:05:22,950
these various struct operators have the

1290
01:05:18,819 --> 01:05:26,230
highest priority highest precedence and

1291
01:05:22,950 --> 01:05:28,119
that and then that's followed by unary

1292
01:05:26,230 --> 01:05:30,940
operators so the star this is the

1293
01:05:28,119 --> 01:05:34,690
dereference operator and then the the

1294
01:05:30,940 --> 01:05:39,220
address of operator these there they

1295
01:05:34,690 --> 01:05:42,579
fall right below the highest the highest

1296
01:05:39,220 --> 01:05:44,770
precedence operators and then the binary

1297
01:05:42,579 --> 01:05:47,579
versions of operators in order to use in

1298
01:05:44,770 --> 01:05:50,980
arithmetic operations are below those

1299
01:05:47,579 --> 01:05:56,320
okay so just remember that function and

1300
01:05:50,980 --> 01:06:00,820
array is higher than star okay

1301
01:05:56,320 --> 01:06:03,160
that to do the dereference now the great

1302
01:06:00,820 --> 01:06:05,680
thing about pointers although they

1303
01:06:03,160 --> 01:06:09,100
always seem really complicated is that

1304
01:06:05,680 --> 01:06:12,160
there's there's an algorithm for it for

1305
01:06:09,100 --> 01:06:14,050
there's an algorithm for constructing an

1306
01:06:12,160 --> 01:06:17,280
English sentence that explains exactly

1307
01:06:14,050 --> 01:06:21,520
what what that pointer what that

1308
01:06:17,280 --> 01:06:23,260
definition of the pointer means okay and

1309
01:06:21,520 --> 01:06:27,610
if you're interested it's in the KN are

1310
01:06:23,260 --> 01:06:31,330
in Section 5.1 - but I'll I'll explain

1311
01:06:27,610 --> 01:06:32,620
it to you now now I don't know I don't

1312
01:06:31,330 --> 01:06:35,080
know how much in this class you're going

1313
01:06:32,620 --> 01:06:36,400
to remember okay but I guarantee you

1314
01:06:35,080 --> 01:06:40,620
you're going to remember this as the day

1315
01:06:36,400 --> 01:06:40,620
you finally understood pointers okay so

1316
01:06:42,090 --> 01:06:47,980
all right so here's how it works you

1317
01:06:44,400 --> 01:06:51,340
always start it the this is a definition

1318
01:06:47,980 --> 01:06:56,070
of a pointer some kind you always start

1319
01:06:51,340 --> 01:06:56,070
with the variable name

1320
01:07:00,020 --> 01:07:04,650
and then you use your precedence then

1321
01:07:02,940 --> 01:07:06,720
you look for operators on either side of

1322
01:07:04,650 --> 01:07:09,500
that varial variable name and you choose

1323
01:07:06,720 --> 01:07:12,870
the one that has the highest precedence

1324
01:07:09,500 --> 01:07:17,970
okay so we start with the variable so we

1325
01:07:12,870 --> 01:07:19,170
say t is a then we look to the left and

1326
01:07:17,970 --> 01:07:21,030
the right there's nothing to the right

1327
01:07:19,170 --> 01:07:25,500
but there's a there's a pointer symbol

1328
01:07:21,030 --> 01:07:27,390
to the left so we say t is a pointer and

1329
01:07:25,500 --> 01:07:29,340
there's nothing more and then we always

1330
01:07:27,390 --> 01:07:35,210
end up with the the type of thing that

1331
01:07:29,340 --> 01:07:35,210
it points that so P is a pointer to int

1332
01:07:43,030 --> 01:07:50,920
like Sookie is P as a pointer to some to

1333
01:07:48,910 --> 01:07:53,470
some integer in memory okay so we all

1334
01:07:50,920 --> 01:07:56,200
know that one that's pretty easy okay

1335
01:07:53,470 --> 01:07:58,170
what about the next one you've probably

1336
01:07:56,200 --> 01:08:01,240
seen something like this

1337
01:07:58,170 --> 01:08:05,290
some programs declare our D using this

1338
01:08:01,240 --> 01:08:11,260
notation and so this you can have an

1339
01:08:05,290 --> 01:08:15,370
optional size or not so so we always

1340
01:08:11,260 --> 01:08:16,900
start out we say T is a well now in this

1341
01:08:15,370 --> 01:08:17,440
case there's operators to the left and

1342
01:08:16,900 --> 01:08:19,090
the right

1343
01:08:17,440 --> 01:08:22,210
remember the array operator has higher

1344
01:08:19,090 --> 01:08:24,070
precedence than that the the

1345
01:08:22,210 --> 01:08:29,800
dereferencing operator the pointer

1346
01:08:24,070 --> 01:08:35,920
operators so we say so T is an array 13

1347
01:08:29,800 --> 01:08:39,400
array of size 13 of so there's nothing

1348
01:08:35,920 --> 01:08:45,690
more so we go to the left of pointers so

1349
01:08:39,400 --> 01:08:45,690
T is an array 13 of pointers to ends

1350
01:08:49,929 --> 01:09:05,329
so t is an array of 13 pointers each of

1351
01:09:00,440 --> 01:09:06,920
which points to an end right in this

1352
01:09:05,329 --> 01:09:12,020
case P is just that the name of the

1353
01:09:06,920 --> 01:09:13,880
array so bytes by default P P is a is

1354
01:09:12,020 --> 01:09:16,279
equivalent is the address of the array

1355
01:09:13,880 --> 01:09:18,529
when you reference an array name you're

1356
01:09:16,279 --> 01:09:20,509
you're you're addressing your active

1357
01:09:18,529 --> 01:09:27,109
dressing the address of the first

1358
01:09:20,509 --> 01:09:28,849
element okay how about the next one here

1359
01:09:27,109 --> 01:09:31,159
we're being if we put parentheses around

1360
01:09:28,849 --> 01:09:33,770
things then we can be explicit okay and

1361
01:09:31,159 --> 01:09:36,349
this is a good practice so here we're

1362
01:09:33,770 --> 01:09:40,339
saying T and we have to look at this one

1363
01:09:36,349 --> 01:09:43,040
first because of the parenthesis so T is

1364
01:09:40,339 --> 01:09:44,989
an array thirteen of pointers to ends so

1365
01:09:43,040 --> 01:09:46,179
that's the same thing and here we're

1366
01:09:44,989 --> 01:09:51,739
just being more explicit

1367
01:09:46,179 --> 01:09:56,719
now what about star star T so P is a

1368
01:09:51,739 --> 01:10:00,070
pointer to a pointer to an int okay so

1369
01:09:56,719 --> 01:10:00,070
this is a different type of array

1370
01:10:01,360 --> 01:10:15,970
so P is a pointer to a pointer to an end

1371
01:10:09,810 --> 01:10:20,980
okay and and typically so this is

1372
01:10:15,970 --> 01:10:23,460
another way to do a raise so the same

1373
01:10:20,980 --> 01:10:28,480
way the char star points to a string

1374
01:10:23,460 --> 01:10:30,580
this this can point it points to it

1375
01:10:28,480 --> 01:10:32,950
points to up a pointer but then you can

1376
01:10:30,580 --> 01:10:40,870
index on that each one of those ven

1377
01:10:32,950 --> 01:10:46,270
points corresponds to a pointer whoops

1378
01:10:40,870 --> 01:10:47,470
okay here's another one now P because

1379
01:10:46,270 --> 01:10:50,860
and because of the parentheses we have

1380
01:10:47,470 --> 01:10:57,400
to go left so P is a pointer to an array

1381
01:10:50,860 --> 01:11:03,720
13 of Imps okay so P isn't a pointer to

1382
01:10:57,400 --> 01:11:03,720
an array of 13 inch

1383
01:11:10,620 --> 01:11:19,900
all right now what about this one

1384
01:11:13,410 --> 01:11:24,010
f is a function or is it a function or a

1385
01:11:19,900 --> 01:11:27,930
pointer F is a function right because of

1386
01:11:24,010 --> 01:11:32,950
the precedence so f is a F is a function

1387
01:11:27,930 --> 01:11:39,790
returning pointer to int okay so if we

1388
01:11:32,950 --> 01:11:45,390
go if we go P equal F then that returns

1389
01:11:39,790 --> 01:11:45,390
that initialized P to point to some int

1390
01:11:48,760 --> 01:11:56,530
all right and I'm going to do this one

1391
01:11:53,060 --> 01:11:58,970
let's jump down in the interest of time

1392
01:11:56,530 --> 01:12:01,360
totally ridiculous case just so you can

1393
01:11:58,970 --> 01:12:07,430
see that this algorithm works

1394
01:12:01,360 --> 01:12:16,160
all right so X is an array of pointers

1395
01:12:07,430 --> 01:12:19,970
to functions returning pointers to an

1396
01:12:16,160 --> 01:12:22,820
array five events and if you ever use

1397
01:12:19,970 --> 01:12:27,050
anything like that in your code shame on

1398
01:12:22,820 --> 01:12:28,730
you all right so there you go

1399
01:12:27,050 --> 01:12:30,950
so that's now you know now you

1400
01:12:28,730 --> 01:12:33,740
understand pointers simplest can be and

1401
01:12:30,950 --> 01:12:36,950
all you need is page 53 of knr is a

1402
01:12:33,740 --> 01:12:38,360
handy reference all right so let's we'll

1403
01:12:36,950 --> 01:12:41,420
take the last five minutes and I'll show

1404
01:12:38,360 --> 01:12:43,880
you some some of the ways you can trip

1405
01:12:41,420 --> 01:12:46,610
yourself up when you're accessing memory

1406
01:12:43,880 --> 01:12:48,380
okay so first it's a classic scanf bug

1407
01:12:46,610 --> 01:12:50,420
you probably just probably all done this

1408
01:12:48,380 --> 01:12:54,710
where you forget to tacit the address of

1409
01:12:50,420 --> 01:12:57,770
a variable instead you pass it the

1410
01:12:54,710 --> 01:13:04,370
address so scanf doesn't know where to

1411
01:12:57,770 --> 01:13:06,020
put the you know put the put the data ok

1412
01:13:04,370 --> 01:13:08,090
another another common mistake is to

1413
01:13:06,020 --> 01:13:09,500
read uninitialized memory so you can't

1414
01:13:08,090 --> 01:13:13,790
really assume that your heap data is

1415
01:13:09,500 --> 01:13:17,150
initialized to zero so here we're we're

1416
01:13:13,790 --> 01:13:18,260
Malachy an array of an int and then

1417
01:13:17,150 --> 01:13:21,860
we're going through and we're doing

1418
01:13:18,260 --> 01:13:24,500
we're updating at this vector this Y

1419
01:13:21,860 --> 01:13:28,010
vector we're reading Y I

1420
01:13:24,500 --> 01:13:31,670
we're taking Y it's why I equal Y I plus

1421
01:13:28,010 --> 01:13:35,560
a IJ times XJ okay so we're using we're

1422
01:13:31,670 --> 01:13:38,480
assuming that Y that malloc returns

1423
01:13:35,560 --> 01:13:40,690
memory that's all zeros so that'll get

1424
01:13:38,480 --> 01:13:40,690
you

1425
01:13:42,280 --> 01:13:47,800
it's also easy to allocate the wrong

1426
01:13:45,130 --> 01:13:53,710
sized object so here we want to create

1427
01:13:47,800 --> 01:13:56,770
an array of end pointers of n pointers

1428
01:13:53,710 --> 01:13:59,140
to ends okay and then for each one we

1429
01:13:56,770 --> 01:14:01,150
want to allocate em in all right so this

1430
01:13:59,140 --> 01:14:07,080
work we're creating a two-dimensional

1431
01:14:01,150 --> 01:14:07,080
array and can you see the mistake which

1432
01:14:09,260 --> 01:14:21,540
which line is buggy this one this one or

1433
01:14:18,090 --> 01:14:24,420
this one the first one right because we

1434
01:14:21,540 --> 01:14:26,070
really want size events are right so

1435
01:14:24,420 --> 01:14:28,530
we're we're erroneous incorrectly

1436
01:14:26,070 --> 01:14:33,840
assuming that intz are the same sizes as

1437
01:14:28,530 --> 01:14:36,030
pointers this is a classic on this

1438
01:14:33,840 --> 01:14:38,040
assumption is true for 32-bit code and

1439
01:14:36,030 --> 01:14:40,800
pointers are the same size but it's not

1440
01:14:38,040 --> 01:14:43,500
true for 64-bit and so this is why when

1441
01:14:40,800 --> 01:14:46,920
you when you port when people port

1442
01:14:43,500 --> 01:14:48,540
32-bit code to 64-bit machine a lot of

1443
01:14:46,920 --> 01:14:53,040
times it breaks because they have this

1444
01:14:48,540 --> 01:14:57,060
assumption ok another way it's easy to

1445
01:14:53,040 --> 01:14:59,520
overwrite memory so here we're creating

1446
01:14:57,060 --> 01:15:01,679
correctly creating this array but then

1447
01:14:59,520 --> 01:15:05,280
when we create each of the each of the

1448
01:15:01,679 --> 01:15:07,080
sub arrays instead of I less than or

1449
01:15:05,280 --> 01:15:09,000
equal to n we're actually we only

1450
01:15:07,080 --> 01:15:10,830
created n of these things but we're

1451
01:15:09,000 --> 01:15:12,810
traversing n plus 1 because of this

1452
01:15:10,830 --> 01:15:17,400
lesson are equal so this is a classic

1453
01:15:12,810 --> 01:15:19,350
off by one bug ok another another

1454
01:15:17,400 --> 01:15:21,119
problem you saw it with the code

1455
01:15:19,350 --> 01:15:24,420
injection attacks from your attack lab

1456
01:15:21,119 --> 01:15:27,650
not checking the the size of a buffer so

1457
01:15:24,420 --> 01:15:31,340
get get as is a classic example of this

1458
01:15:27,650 --> 01:15:31,340
so that will get you into trouble

1459
01:15:31,830 --> 01:15:36,330
another another classic mistake is

1460
01:15:33,900 --> 01:15:42,050
misunderstanding pointer arithmetic all

1461
01:15:36,330 --> 01:15:45,030
right so if you incremental pointer then

1462
01:15:42,050 --> 01:15:48,000
it point is incremented by the size of

1463
01:15:45,030 --> 01:15:50,639
the object that pointer points to right

1464
01:15:48,000 --> 01:15:53,060
so if you increment an int star by one

1465
01:15:50,639 --> 01:15:57,050
it actually increments it by four

1466
01:15:53,060 --> 01:15:57,050
because that's the size of an int

1467
01:15:57,620 --> 01:16:04,040
got that's a really important

1468
01:15:59,330 --> 01:16:06,290
distinction and so people often so here

1469
01:16:04,040 --> 01:16:08,480
it's assuming that incrementing so P is

1470
01:16:06,290 --> 01:16:10,280
the pointer and the programmer here

1471
01:16:08,480 --> 01:16:12,830
assumed that he wants to increment the

1472
01:16:10,280 --> 01:16:14,420
pointer to sort of traverse an array so

1473
01:16:12,830 --> 01:16:18,200
he he doesn't understand pointer

1474
01:16:14,420 --> 01:16:21,590
arithmetic and so to get to the next in

1475
01:16:18,200 --> 01:16:23,870
increments P by size event okay this

1476
01:16:21,590 --> 01:16:29,420
will really increment it by sixteen not

1477
01:16:23,870 --> 01:16:32,720
but four okay overriding memory that's a

1478
01:16:29,420 --> 01:16:34,910
really nasty one and a lot of times this

1479
01:16:32,720 --> 01:16:38,870
can happen if you don't understand the

1480
01:16:34,910 --> 01:16:41,150
precedence of the of the operators that

1481
01:16:38,870 --> 01:16:42,500
you're working with so this is a heat

1482
01:16:41,150 --> 01:16:43,850
not not to kind of heap we've been

1483
01:16:42,500 --> 01:16:46,370
talking about but oh the heap data

1484
01:16:43,850 --> 01:16:48,230
structure and this is a this is a

1485
01:16:46,370 --> 01:16:49,730
function to delete from the heat this

1486
01:16:48,230 --> 01:16:54,950
actually is from my own code I have to

1487
01:16:49,730 --> 01:16:59,210
admit and so I wanted to leet I want to

1488
01:16:54,950 --> 01:17:01,280
delete an element I want to delete the

1489
01:16:59,210 --> 01:17:04,160
first element of the heap right and then

1490
01:17:01,280 --> 01:17:06,140
I want to reheat the fly it okay so I

1491
01:17:04,160 --> 01:17:08,930
and then I want to return I want to

1492
01:17:06,140 --> 01:17:14,600
return that so I I get the first element

1493
01:17:08,930 --> 01:17:17,420
the heap I that the size of the heap or

1494
01:17:14,600 --> 01:17:23,420
I take the last element and make that

1495
01:17:17,420 --> 01:17:25,760
the first element and and now I want to

1496
01:17:23,420 --> 01:17:28,130
decrease the size of the heat because

1497
01:17:25,760 --> 01:17:31,220
this delete operation will delete the

1498
01:17:28,130 --> 01:17:34,070
heap size by one so notice here we

1499
01:17:31,220 --> 01:17:36,200
passed size n as a pointer and when this

1500
01:17:34,070 --> 01:17:37,760
when this function terminate when this

1501
01:17:36,200 --> 01:17:41,120
function returns size should be updated

1502
01:17:37,760 --> 01:17:42,140
dated size of the pointer the value that

1503
01:17:41,120 --> 01:17:44,930
it points to you should be decremented

1504
01:17:42,140 --> 01:17:46,670
okay that's our intent and we do it

1505
01:17:44,930 --> 01:17:48,530
right here with the size minus minus

1506
01:17:46,670 --> 01:17:52,460
star so what we want to do is we want to

1507
01:17:48,530 --> 01:17:58,250
dereference size and then decrement that

1508
01:17:52,460 --> 01:18:01,880
value but because the unary minus minus

1509
01:17:58,250 --> 01:18:04,430
has higher precedence than then the

1510
01:18:01,880 --> 01:18:07,070
dereference what we're really doing is

1511
01:18:04,430 --> 01:18:09,380
we're decrementing the pointer and then

1512
01:18:07,070 --> 01:18:14,750
be referencing the value that's

1513
01:18:09,380 --> 01:18:17,090
one word less than our size variable all

1514
01:18:14,750 --> 01:18:20,929
right so these are nasty and it would

1515
01:18:17,090 --> 01:18:23,840
have been much cleaner if I just put

1516
01:18:20,929 --> 01:18:27,770
parentheses around like I intended just

1517
01:18:23,840 --> 01:18:29,090
parentheses star sized parentheses all

1518
01:18:27,770 --> 01:18:31,520
right another another way you can mess

1519
01:18:29,090 --> 01:18:33,920
up is referencing forgetting the local

1520
01:18:31,520 --> 01:18:36,260
variables disappear so if you have a

1521
01:18:33,920 --> 01:18:39,770
function that returns an address of a

1522
01:18:36,260 --> 01:18:42,619
local variable no good okay no good at

1523
01:18:39,770 --> 01:18:45,560
all it might be okay for a while until

1524
01:18:42,619 --> 01:18:47,960
somebody another function reuses that

1525
01:18:45,560 --> 01:18:50,239
space it could be a return address it

1526
01:18:47,960 --> 01:18:55,849
could be another another functions local

1527
01:18:50,239 --> 01:18:57,590
variable another terrible mistake that's

1528
01:18:55,849 --> 01:19:00,530
a really bad one is freeing a block

1529
01:18:57,590 --> 01:19:02,449
multiple time now you know from from

1530
01:19:00,530 --> 01:19:04,969
your understanding now as malloc that

1531
01:19:02,449 --> 01:19:06,739
free actually writes to the heap right

1532
01:19:04,969 --> 01:19:09,980
it's coalescing it's changing pointers

1533
01:19:06,739 --> 01:19:11,750
it's changing size block sizes so if you

1534
01:19:09,980 --> 01:19:17,270
free a block that's already been freed

1535
01:19:11,750 --> 01:19:18,949
terrible things will happen another

1536
01:19:17,270 --> 01:19:20,449
thing you can do wrong is to reference a

1537
01:19:18,949 --> 01:19:22,190
block you forget that you freed a block

1538
01:19:20,449 --> 01:19:25,099
and then you reference it so here we

1539
01:19:22,190 --> 01:19:29,150
free of this block X and then we're

1540
01:19:25,099 --> 01:19:31,610
referencing it here another another big

1541
01:19:29,150 --> 01:19:34,730
problem is memory leaks so failing to

1542
01:19:31,610 --> 01:19:37,070
free block so allocating some block in a

1543
01:19:34,730 --> 01:19:38,480
function and then returning that block

1544
01:19:37,070 --> 01:19:40,869
will stay there forever right because

1545
01:19:38,480 --> 01:19:40,869
it's garbage

1546
01:19:42,580 --> 01:19:47,830
okay so there's a there's a number of

1547
01:19:45,620 --> 01:19:49,969
ways to deal with memory bugs gdb is

1548
01:19:47,830 --> 01:19:52,700
sometimes good at least it'll tell you

1549
01:19:49,969 --> 01:19:55,160
where a seg fault occurs then you gotta

1550
01:19:52,700 --> 01:19:59,060
track down what the right that sort of

1551
01:19:55,160 --> 01:20:01,880
caused that seg fault the best thing you

1552
01:19:59,060 --> 01:20:05,000
can do but gdb falls down whenever

1553
01:20:01,880 --> 01:20:05,890
you're doing manipulation of complex

1554
01:20:05,000 --> 01:20:08,180
data structures

1555
01:20:05,890 --> 01:20:10,100
it's just simple sort of looking one

1556
01:20:08,180 --> 01:20:12,770
instruction at a time what you really

1557
01:20:10,100 --> 01:20:15,160
need to do is identify any complex data

1558
01:20:12,770 --> 01:20:17,390
structure like a heap for example is

1559
01:20:15,160 --> 01:20:19,070
identify invariance for that structure

1560
01:20:17,390 --> 01:20:21,739
that that data structure should always

1561
01:20:19,070 --> 01:20:24,050
maintain and then you write a function

1562
01:20:21,739 --> 01:20:25,850
that iterates over that structure that

1563
01:20:24,050 --> 01:20:28,700
data structure and checks that all those

1564
01:20:25,850 --> 01:20:33,170
invariants are true so for example in it

1565
01:20:28,700 --> 01:20:35,810
and in allocator one of the invariance

1566
01:20:33,170 --> 01:20:37,430
is that there should be no there should

1567
01:20:35,810 --> 01:20:40,040
never be two contiguous free blocks

1568
01:20:37,430 --> 01:20:41,780
right so your your consistency checker

1569
01:20:40,040 --> 01:20:46,060
should go through the heat and make sure

1570
01:20:41,780 --> 01:20:48,380
there's no no contiguous free blocks or

1571
01:20:46,060 --> 01:20:50,140
another invariant is that every free

1572
01:20:48,380 --> 01:20:53,060
block should be in a free list somewhere

1573
01:20:50,140 --> 01:20:55,070
right so you would you would you would

1574
01:20:53,060 --> 01:20:56,660
up your consistency checker would scan

1575
01:20:55,070 --> 01:20:58,640
the heap count the number of free blocks

1576
01:20:56,660 --> 01:21:00,620
and then scan the free list and make

1577
01:20:58,640 --> 01:21:02,540
sure that the number of blocks in the

1578
01:21:00,620 --> 01:21:04,790
free list is the same as the number of

1579
01:21:02,540 --> 01:21:06,170
free blocks okay so this idea of a

1580
01:21:04,790 --> 01:21:07,760
consistency checker is something you'll

1581
01:21:06,170 --> 01:21:09,980
use in your malloc lab but it's

1582
01:21:07,760 --> 01:21:11,960
something it's also something you should

1583
01:21:09,980 --> 01:21:15,890
you should use whenever you're updating

1584
01:21:11,960 --> 01:21:18,200
any kind of complex data structure and

1585
01:21:15,890 --> 01:21:19,700
the and you know about valgrind but the

1586
01:21:18,200 --> 01:21:22,880
great thing about these deep checkers

1587
01:21:19,700 --> 01:21:26,000
I'm passionate about heat checkers or

1588
01:21:22,880 --> 01:21:27,890
consistency checkers this is a really

1589
01:21:26,000 --> 01:21:30,920
powerful thing about them is you write

1590
01:21:27,890 --> 01:21:32,719
them to run silently they don't print

1591
01:21:30,920 --> 01:21:36,650
anything unless they find that a

1592
01:21:32,719 --> 01:21:38,570
violation of the invariants if you write

1593
01:21:36,650 --> 01:21:40,880
your consistency checker like this then

1594
01:21:38,570 --> 01:21:43,790
you can use it like a probe so your

1595
01:21:40,880 --> 01:21:45,620
program crashes so you do if you use

1596
01:21:43,790 --> 01:21:49,489
this heap checker to do a binary search

1597
01:21:45,620 --> 01:21:52,090
to isolate the cause so you know you put

1598
01:21:49,489 --> 01:21:54,920
your you put your heap checker here

1599
01:21:52,090 --> 01:21:55,340
everything is okay and then later the

1600
01:21:54,920 --> 01:21:57,650
program

1601
01:21:55,340 --> 01:22:01,400
Crash's so now you stick the Heep

1602
01:21:57,650 --> 01:22:04,489
checker here and now I crash the Heep

1603
01:22:01,400 --> 01:22:06,650
checker detection in violation so you

1604
01:22:04,489 --> 01:22:07,760
know that the problem is somewhere here

1605
01:22:06,650 --> 01:22:10,310
and you can just keep narrowing it down

1606
01:22:07,760 --> 01:22:12,530
so it's just like a probe surgical probe

1607
01:22:10,310 --> 01:22:16,849
that you can use to to track down bugs

1608
01:22:12,530 --> 01:22:18,500
and so that if you do this like it's I

1609
01:22:16,849 --> 01:22:22,179
don't know how anybody debugs now like

1610
01:22:18,500 --> 01:22:22,179
without this kind of tool

1611
01:22:24,210 --> 01:22:32,180
okay so that's it for today have a good

1612
01:22:28,800 --> 01:22:32,180
weekend we'll see you on Tuesday

