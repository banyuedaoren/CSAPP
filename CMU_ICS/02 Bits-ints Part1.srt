1
00:00:00,000 --> 00:00:06,450
I see a lot of people figure it out to

2
00:00:02,820 --> 00:00:09,389
come early so good for you so if you

3
00:00:06,450 --> 00:00:11,340
recall my name is Randy Bryant and I'm

4
00:00:09,389 --> 00:00:14,969
Co instructor of this course along with

5
00:00:11,340 --> 00:00:17,940
Dave O'Halloran and for the next couple

6
00:00:14,969 --> 00:00:20,970
lectures the first part of this course

7
00:00:17,940 --> 00:00:23,730
really will be talking about sort of

8
00:00:20,970 --> 00:00:25,019
data representations in particular how

9
00:00:23,730 --> 00:00:27,660
numbers are represented in different

10
00:00:25,019 --> 00:00:30,539
forms and some of the properties and you

11
00:00:27,660 --> 00:00:32,460
saw that when I talked last week I

12
00:00:30,539 --> 00:00:34,410
showed you things like you can multiply

13
00:00:32,460 --> 00:00:37,739
some numbers together that are positive

14
00:00:34,410 --> 00:00:39,750
and get negative result so what we want

15
00:00:37,739 --> 00:00:42,300
to understand is what is the bit level

16
00:00:39,750 --> 00:00:45,329
representation of numbers and how does

17
00:00:42,300 --> 00:00:47,370
that affect some of the properties you

18
00:00:45,329 --> 00:00:49,230
have when you operate them on and

19
00:00:47,370 --> 00:00:52,050
especially looking at the corner cases

20
00:00:49,230 --> 00:00:55,110
when things overflow or we sort of don't

21
00:00:52,050 --> 00:00:57,360
do what you might expect them to do so

22
00:00:55,110 --> 00:01:00,449
we'll start off with very basic stuff of

23
00:00:57,360 --> 00:01:02,820
how numbers are represented especially

24
00:01:00,449 --> 00:01:08,010
integer valued numbers are represented

25
00:01:02,820 --> 00:01:10,080
in bits so I think you've pretty well

26
00:01:08,010 --> 00:01:12,240
figured out in this world that the whole

27
00:01:10,080 --> 00:01:18,060
digital world is sort of based on on

28
00:01:12,240 --> 00:01:20,430
binary values and that wasn't always the

29
00:01:18,060 --> 00:01:23,040
case I mean since humans have ten

30
00:01:20,430 --> 00:01:25,619
fingers and ten toes a lot of the world

31
00:01:23,040 --> 00:01:28,430
was based on the decimal system and it

32
00:01:25,619 --> 00:01:31,700
was really only and in fact the first

33
00:01:28,430 --> 00:01:35,040
electronic computer the ENIAC built in

34
00:01:31,700 --> 00:01:37,229
University of Pennsylvania basically

35
00:01:35,040 --> 00:01:40,770
encoded did all of its arithmetic using

36
00:01:37,229 --> 00:01:43,920
base ten they had 10 vacuum tubes per

37
00:01:40,770 --> 00:01:46,259
digit they wanted to represent so they

38
00:01:43,920 --> 00:01:49,560
basically turned on or off those tubes

39
00:01:46,259 --> 00:01:52,020
to represent which of the 10 possible

40
00:01:49,560 --> 00:01:55,829
digits you could want and it really

41
00:01:52,020 --> 00:01:59,070
didn't come to people until later than

42
00:01:55,829 --> 00:02:00,960
that so that's 1948 that they really

43
00:01:59,070 --> 00:02:02,000
should just think about base tube for

44
00:02:00,960 --> 00:02:07,439
everything

45
00:02:02,000 --> 00:02:09,869
and the reason why bits are great is in

46
00:02:07,439 --> 00:02:12,620
the digital world you can sort of take

47
00:02:09,869 --> 00:02:14,040
what otherwise an analog signal and

48
00:02:12,620 --> 00:02:16,470
quantify it

49
00:02:14,040 --> 00:02:18,239
and just say I'm going to say that one

50
00:02:16,470 --> 00:02:20,670
range of values would say it's a low

51
00:02:18,239 --> 00:02:23,489
voltage I'm going to call that a zero

52
00:02:20,670 --> 00:02:27,290
and a high range of values I'm going to

53
00:02:23,489 --> 00:02:29,220
call it a one and if there's noise or

54
00:02:27,290 --> 00:02:32,670
imperfections in the circuit or

55
00:02:29,220 --> 00:02:35,930
anything's going on as long as that

56
00:02:32,670 --> 00:02:38,730
doesn't exceed these bit these

57
00:02:35,930 --> 00:02:40,709
thresholds you've set up then you'll get

58
00:02:38,730 --> 00:02:43,769
a nice clean signal out of it and that's

59
00:02:40,709 --> 00:02:47,970
the main advantage of digital processing

60
00:02:43,769 --> 00:02:50,099
over analog processing and so that sort

61
00:02:47,970 --> 00:02:52,379
of at the core why everything we do and

62
00:02:50,099 --> 00:02:54,930
especially for storing information it

63
00:02:52,379 --> 00:02:57,900
turns out it's much easier to store one

64
00:02:54,930 --> 00:03:03,379
bit of information or a digital value

65
00:02:57,900 --> 00:03:07,859
than it is to store an analog value and

66
00:03:03,379 --> 00:03:11,129
sorry this kind of slides went a little

67
00:03:07,859 --> 00:03:12,870
crazy on animation so the point is that

68
00:03:11,129 --> 00:03:16,139
we represent all the numbers in a

69
00:03:12,870 --> 00:03:17,909
computer as sets of bits and I think you

70
00:03:16,139 --> 00:03:20,910
generally understand that fairly well

71
00:03:17,909 --> 00:03:22,889
and so of course the familiar binary

72
00:03:20,910 --> 00:03:27,000
representation of integers which we'll

73
00:03:22,889 --> 00:03:29,609
go over today just uses a bit position

74
00:03:27,000 --> 00:03:32,819
for each power of two we can also

75
00:03:29,609 --> 00:03:35,040
represent values that are fractional and

76
00:03:32,819 --> 00:03:37,440
we'll talk about that a week from today

77
00:03:35,040 --> 00:03:39,930
when we do a floating-point numbers

78
00:03:37,440 --> 00:03:44,060
where what you do is to the right of the

79
00:03:39,930 --> 00:03:47,549
binary point so this is no longer a

80
00:03:44,060 --> 00:03:49,590
decimal point it's a binary point and so

81
00:03:47,549 --> 00:03:54,120
something to the left of that would have

82
00:03:49,590 --> 00:03:55,949
a weight one two to the zero and the

83
00:03:54,120 --> 00:03:58,889
next one over would have weight to the

84
00:03:55,949 --> 00:04:01,849
one but what you do is is you go to the

85
00:03:58,889 --> 00:04:05,449
right that adds weight to the minus one

86
00:04:01,849 --> 00:04:09,510
to the minus two in other words this is

87
00:04:05,449 --> 00:04:13,290
1 this is 2 this is one half and this is

88
00:04:09,510 --> 00:04:15,419
1/4 so we can represent just like you do

89
00:04:13,290 --> 00:04:17,849
the decimal representation of fractions

90
00:04:15,419 --> 00:04:19,909
we can do the binary representation of

91
00:04:17,849 --> 00:04:23,690
fractions so that's the core of

92
00:04:19,909 --> 00:04:26,060
floating-point number of representations

93
00:04:23,690 --> 00:04:28,760
and so

94
00:04:26,060 --> 00:04:33,260
it gets very annoying if you have say 32

95
00:04:28,760 --> 00:04:35,750
or even 64-bit numbers to be writing the

96
00:04:33,260 --> 00:04:39,410
strings of ones and zeros out and so

97
00:04:35,750 --> 00:04:41,270
what we use and what's become largely

98
00:04:39,410 --> 00:04:45,310
the the most common is to group

99
00:04:41,270 --> 00:04:48,530
collections of four bits at a time into

100
00:04:45,310 --> 00:04:49,850
and then represent that in base 16 or

101
00:04:48,530 --> 00:04:52,400
what's known as hexadecimal

102
00:04:49,850 --> 00:04:56,270
representation using the letters A

103
00:04:52,400 --> 00:04:58,610
through F as values 10 through 15 and

104
00:04:56,270 --> 00:05:01,280
you'll spend a lot of time staring at

105
00:04:58,610 --> 00:05:03,260
exa decimal numbers this year and you'll

106
00:05:01,280 --> 00:05:07,030
get pretty good at being able to look at

107
00:05:03,260 --> 00:05:10,610
a hex number just write it out in binary

108
00:05:07,030 --> 00:05:20,650
the way I do it just to tell you is I

109
00:05:10,610 --> 00:05:24,950
mean I've got the values from 0 to 9

110
00:05:20,650 --> 00:05:27,590
wired down pretty well and then I keep

111
00:05:24,950 --> 00:05:38,620
track of a few special cases 1 0 1 0

112
00:05:27,590 --> 00:05:44,660
it's a 1 1 0 0 is C and 1 1 1 1 F and

113
00:05:38,620 --> 00:05:47,479
for B D and E I kind of interpolate

114
00:05:44,660 --> 00:05:49,010
between those so if you want to develop

115
00:05:47,479 --> 00:05:50,630
that skill that's the way you can do it

116
00:05:49,010 --> 00:05:55,039
you're looking for Jesse my connector

117
00:05:50,630 --> 00:05:59,080
that was an HDMI - what no I don't think

118
00:05:55,039 --> 00:05:59,080
there's any connector here you know No

119
00:06:02,610 --> 00:06:09,790
so that's something you're going to end

120
00:06:05,020 --> 00:06:13,560
up wanting to be able to do so in C we

121
00:06:09,790 --> 00:06:16,090
don't in most

122
00:06:13,560 --> 00:06:19,120
declarations you don't actually are told

123
00:06:16,090 --> 00:06:22,870
exactly how many bytes abide is eight

124
00:06:19,120 --> 00:06:25,390
bits each data value is represented as

125
00:06:22,870 --> 00:06:27,880
and that's partly C was designed

126
00:06:25,390 --> 00:06:31,150
actually back when microprocessors only

127
00:06:27,880 --> 00:06:34,630
had 16-bit words it was actually before

128
00:06:31,150 --> 00:06:36,520
micro processors so 16-bit words were a

129
00:06:34,630 --> 00:06:39,940
fairly standard thing and over time

130
00:06:36,520 --> 00:06:43,360
that's expanded from 16 to 32 to now 64

131
00:06:39,940 --> 00:06:45,190
and so C rather than a sort of an

132
00:06:43,360 --> 00:06:47,890
advanced saying here is how many bytes

133
00:06:45,190 --> 00:06:51,400
every value will have has these slightly

134
00:06:47,890 --> 00:06:56,350
ambiguous terms that vary actually from

135
00:06:51,400 --> 00:06:58,890
one machine to the next and if you're a

136
00:06:56,350 --> 00:07:02,620
very careful C programmer you have to

137
00:06:58,890 --> 00:07:06,580
anticipate that zone but what won't deal

138
00:07:02,620 --> 00:07:09,250
with is x86 64 is the class of machines

139
00:07:06,580 --> 00:07:11,410
will be working with exclusively this

140
00:07:09,250 --> 00:07:14,320
term and so you can see that when you

141
00:07:11,410 --> 00:07:16,810
declare something to be a care sometimes

142
00:07:14,320 --> 00:07:23,820
people call it a char that the one byte

143
00:07:16,810 --> 00:07:28,060
value a short is 16 by a bit an INT is

144
00:07:23,820 --> 00:07:32,260
32 and if you want to get all 64 bits

145
00:07:28,060 --> 00:07:33,580
you have to declare it to be along and

146
00:07:32,260 --> 00:07:35,140
then again there's two different

147
00:07:33,580 --> 00:07:37,660
Precision's of floating-point there's

148
00:07:35,140 --> 00:07:40,390
four byte or 32-bit floating point

149
00:07:37,660 --> 00:07:44,140
numbers and 64 bits there's also a

150
00:07:40,390 --> 00:07:47,830
slightly obscure holdover from ancient

151
00:07:44,140 --> 00:07:49,900
days of of floating point where there's

152
00:07:47,830 --> 00:07:52,810
a special representation in Intel

153
00:07:49,900 --> 00:07:55,990
machines that uses a 10 bite or 80 bit

154
00:07:52,810 --> 00:08:00,850
representation and when you use that on

155
00:07:55,990 --> 00:08:03,970
a 64-bit machine they sort of waste an

156
00:08:00,850 --> 00:08:07,300
extra six bit bytes out of that so that

157
00:08:03,970 --> 00:08:10,030
everything is aligned in sixteen byte

158
00:08:07,300 --> 00:08:12,690
increments the other thing and this is

159
00:08:10,030 --> 00:08:13,780
an important feature is any address is

160
00:08:12,690 --> 00:08:17,380
defined

161
00:08:13,780 --> 00:08:19,300
to be the sort of the word size of the

162
00:08:17,380 --> 00:08:20,950
machine when they say it's a 64-bit

163
00:08:19,300 --> 00:08:25,150
machine what they really mean is that

164
00:08:20,950 --> 00:08:27,130
the addresses are 64 bit values or 8

165
00:08:25,150 --> 00:08:30,880
byte values and that's different for

166
00:08:27,130 --> 00:08:33,250
example if you use a older machine a 32

167
00:08:30,880 --> 00:08:40,990
bit machine those will only be 32-bit

168
00:08:33,250 --> 00:08:43,990
addresses so the basis and I imagine

169
00:08:40,990 --> 00:08:46,930
you've had this at some point of how do

170
00:08:43,990 --> 00:08:50,410
we then think about bits is based on

171
00:08:46,930 --> 00:08:54,339
boolean algebra which is actually comes

172
00:08:50,410 --> 00:08:57,040
from the 1890s that a guy named George

173
00:08:54,339 --> 00:09:00,730
Boole who recognized it's sort of

174
00:08:57,040 --> 00:09:05,490
relation between what we'd call bits but

175
00:09:00,730 --> 00:09:08,110
they weren't called bits beck 1001 and

176
00:09:05,490 --> 00:09:10,960
logic are basically truth values in

177
00:09:08,110 --> 00:09:13,660
logic I'm thinking of an algebra sort of

178
00:09:10,960 --> 00:09:15,310
a structured set of operations you could

179
00:09:13,660 --> 00:09:18,940
apply that would capture some of the

180
00:09:15,310 --> 00:09:22,180
concepts that people assume is in logic

181
00:09:18,940 --> 00:09:25,240
so for example if we think of 1 being

182
00:09:22,180 --> 00:09:28,450
true and 0 being false then the end

183
00:09:25,240 --> 00:09:31,930
operation is true if both of the inputs

184
00:09:28,450 --> 00:09:33,670
both of the arguments are true so we get

185
00:09:31,930 --> 00:09:37,630
this chart here and similarly the or

186
00:09:33,670 --> 00:09:42,310
operation is true if either input is

187
00:09:37,630 --> 00:09:45,490
true or 1 the not is just to flip the

188
00:09:42,310 --> 00:09:48,100
bit and then the exclusive-or is what

189
00:09:45,490 --> 00:09:50,800
you get when you say it's one or the

190
00:09:48,100 --> 00:09:54,130
other but not both and so it has this

191
00:09:50,800 --> 00:09:57,940
representation so just as a bit of

192
00:09:54,130 --> 00:10:00,880
history it was a master's degree student

193
00:09:57,940 --> 00:10:04,930
at MIT named Claude Shannon who had

194
00:10:00,880 --> 00:10:07,380
taken a course in logic as an

195
00:10:04,930 --> 00:10:10,030
undergraduate at University of Michigan

196
00:10:07,380 --> 00:10:13,540
and he was the one who made the

197
00:10:10,030 --> 00:10:17,100
connection between thinking about this

198
00:10:13,540 --> 00:10:20,140
this what was at the time very obscure

199
00:10:17,100 --> 00:10:22,660
branch of something a rather of logic

200
00:10:20,140 --> 00:10:24,790
and applying it to digital systems back

201
00:10:22,660 --> 00:10:27,460
in an era when they actually built these

202
00:10:24,790 --> 00:10:30,820
things out of electromechanical

203
00:10:27,460 --> 00:10:34,240
and so his master's thesis is probably

204
00:10:30,820 --> 00:10:37,110
the most impactful master's thesis in

205
00:10:34,240 --> 00:10:40,570
the history of humankind

206
00:10:37,110 --> 00:10:42,490
and you always wonder well what did they

207
00:10:40,570 --> 00:10:45,190
do before that then you know how do they

208
00:10:42,490 --> 00:10:48,310
even think about these things so anyways

209
00:10:45,190 --> 00:10:51,220
the idea of applying this algebra then

210
00:10:48,310 --> 00:10:53,740
to bits is not something that should

211
00:10:51,220 --> 00:10:55,540
have been true since the world began

212
00:10:53,740 --> 00:11:00,840
it's something that's a relatively

213
00:10:55,540 --> 00:11:04,030
modern concept now what's an important

214
00:11:00,840 --> 00:11:07,330
thing that might be less obvious is we

215
00:11:04,030 --> 00:11:09,520
can also do these over words we can do

216
00:11:07,330 --> 00:11:13,060
these boolean operations where we apply

217
00:11:09,520 --> 00:11:16,030
them on each successive bit in that word

218
00:11:13,060 --> 00:11:18,730
and these symbols we use the ampersand

219
00:11:16,030 --> 00:11:20,830
vertical bar carrot and tilde are

220
00:11:18,730 --> 00:11:24,220
actually the ones that see uses to

221
00:11:20,830 --> 00:11:26,590
represent these operations and so again

222
00:11:24,220 --> 00:11:31,210
if we look at here the one is only if

223
00:11:26,590 --> 00:11:34,420
both of the values of 1 and the of for

224
00:11:31,210 --> 00:11:38,500
the or for the and for the wants or if

225
00:11:34,420 --> 00:11:41,800
either of number 1 the exclusive or if 1

226
00:11:38,500 --> 00:11:45,250
is 1 and the other is 0 until it is just

227
00:11:41,800 --> 00:11:47,980
invert the bits of it so again we will

228
00:11:45,250 --> 00:11:49,780
spend a lot of time making use of the

229
00:11:47,980 --> 00:11:52,180
fact that in see and this is one of the

230
00:11:49,780 --> 00:11:53,860
features of C that people like is that

231
00:11:52,180 --> 00:11:56,590
you can do these sort of very low level

232
00:11:53,860 --> 00:12:01,990
of bitna manipulations directly in the

233
00:11:56,590 --> 00:12:05,200
language and this actually turns out to

234
00:12:01,990 --> 00:12:07,900
be useful in practice and it's sort of

235
00:12:05,200 --> 00:12:10,870
implicit of a way of representing sets

236
00:12:07,900 --> 00:12:14,400
of values so this example is a imagine

237
00:12:10,870 --> 00:12:16,780
we want to represent sets where the

238
00:12:14,400 --> 00:12:20,200
elements of the set are numbers ranging

239
00:12:16,780 --> 00:12:25,180
between 0 & 7 so one bite is enough to

240
00:12:20,200 --> 00:12:28,060
capture 8 cases and we'll just if we

241
00:12:25,180 --> 00:12:31,150
number the bits and we number them from

242
00:12:28,060 --> 00:12:34,720
right to left so this is bit zero so

243
00:12:31,150 --> 00:12:37,800
that would represent whether or not the

244
00:12:34,720 --> 00:12:40,630
value 0 is an element of the set and

245
00:12:37,800 --> 00:12:44,560
similarly here you'll see 0 1 2

246
00:12:40,630 --> 00:12:46,450
three so we're saying that bit three

247
00:12:44,560 --> 00:12:54,970
being one here means three is an element

248
00:12:46,450 --> 00:12:57,730
of the set and so forth and the so the

249
00:12:54,970 --> 00:13:00,580
idea is then the end operation becomes

250
00:12:57,730 --> 00:13:04,420
like set intersection the or operation

251
00:13:00,580 --> 00:13:07,390
becomes like set Union and the X

252
00:13:04,420 --> 00:13:12,010
exclusive or operation is what's called

253
00:13:07,390 --> 00:13:14,170
symmetric difference and so these are

254
00:13:12,010 --> 00:13:16,030
actually and tilde is like set

255
00:13:14,170 --> 00:13:23,740
complement so these are actually very

256
00:13:16,030 --> 00:13:25,920
common for example there's a operations

257
00:13:23,740 --> 00:13:30,190
you'll learn later when we look at a

258
00:13:25,920 --> 00:13:33,790
file i/o about i/o that you can track I

259
00:13:30,190 --> 00:13:36,040
want to know which set of possible

260
00:13:33,790 --> 00:13:38,620
inputs to the system think of different

261
00:13:36,040 --> 00:13:43,000
network connections have an input ready

262
00:13:38,620 --> 00:13:45,640
for me to read and there is a data

263
00:13:43,000 --> 00:13:47,770
structure that it's sort of hidden away

264
00:13:45,640 --> 00:13:49,650
among some seeing library calls but it

265
00:13:47,770 --> 00:13:52,840
basically is using exactly this

266
00:13:49,650 --> 00:13:55,330
representation about a thousand a bits

267
00:13:52,840 --> 00:13:58,600
worth of information to represent these

268
00:13:55,330 --> 00:14:02,410
sets and do manipulation on those sets

269
00:13:58,600 --> 00:14:04,990
so this is a very common and why do we

270
00:14:02,410 --> 00:14:09,580
use representation of sets in computer

271
00:14:04,990 --> 00:14:12,940
science so as I mentioned those are

272
00:14:09,580 --> 00:14:17,110
available directly and see the ampersand

273
00:14:12,940 --> 00:14:19,350
vertical bar tilde and caret one thing

274
00:14:17,110 --> 00:14:21,370
that's really really important and that

275
00:14:19,350 --> 00:14:23,470
programmers screw it up all the time

276
00:14:21,370 --> 00:14:25,240
beginning programmers a lot and even

277
00:14:23,470 --> 00:14:29,920
experienced programmers from time to

278
00:14:25,240 --> 00:14:32,080
time is to mix up the single ampersand

279
00:14:29,920 --> 00:14:33,850
in the double ampersand or the single

280
00:14:32,080 --> 00:14:37,540
vertical bar in the double vertical bar

281
00:14:33,850 --> 00:14:42,270
and the tilde versus the exclamation

282
00:14:37,540 --> 00:14:47,230
mark which is often pronounced bang so

283
00:14:42,270 --> 00:14:48,970
and the reason so obviously there's sort

284
00:14:47,230 --> 00:14:51,070
of a syntactic similarity there's

285
00:14:48,970 --> 00:14:53,830
actually somewhat of a semantic relation

286
00:14:51,070 --> 00:14:56,290
to that this is another kind of

287
00:14:53,830 --> 00:14:59,680
another kind of or and another kind of

288
00:14:56,290 --> 00:15:01,930
not but if you mix and match these

289
00:14:59,680 --> 00:15:05,260
you're certainly going to have problems

290
00:15:01,930 --> 00:15:07,540
so the double bar ones aren't thinking

291
00:15:05,260 --> 00:15:09,430
about bitwise operations through

292
00:15:07,540 --> 00:15:12,850
thinking about something that's either

293
00:15:09,430 --> 00:15:16,420
true or false periods and in that

294
00:15:12,850 --> 00:15:18,550
representation the number zero is the

295
00:15:16,420 --> 00:15:20,980
thing that faults and anything else any

296
00:15:18,550 --> 00:15:26,440
other bit pattern is considered to be

297
00:15:20,980 --> 00:15:30,100
true and so it the other feature that

298
00:15:26,440 --> 00:15:33,220
the double bonds give you is what's

299
00:15:30,100 --> 00:15:39,940
called early termination so in

300
00:15:33,220 --> 00:15:44,820
particular if we do some examples on the

301
00:15:39,940 --> 00:15:48,550
some hex pattern for one so this is a a

302
00:15:44,820 --> 00:15:51,550
not a zero and so that's considered true

303
00:15:48,550 --> 00:15:54,340
in this interpretation and so the the

304
00:15:51,550 --> 00:15:56,380
bang of that the not of that is zero and

305
00:15:54,340 --> 00:16:01,150
similarly if you have zero the not event

306
00:15:56,380 --> 00:16:03,640
is one and if you apply bang to a number

307
00:16:01,150 --> 00:16:10,840
twice you'll get back a one unless it

308
00:16:03,640 --> 00:16:14,020
was zero and then similarly these

309
00:16:10,840 --> 00:16:16,510
patterns here are the reason why this

310
00:16:14,020 --> 00:16:20,500
returns one is because it's considered

311
00:16:16,510 --> 00:16:22,690
two cases that are true so it's not

312
00:16:20,500 --> 00:16:24,520
doing bitwise operations it's just

313
00:16:22,690 --> 00:16:26,290
trying to create true and false

314
00:16:24,520 --> 00:16:28,630
it's interpreting argument speeds or

315
00:16:26,290 --> 00:16:29,230
true or false and returning either true

316
00:16:28,630 --> 00:16:32,650
or false

317
00:16:29,230 --> 00:16:34,420
but when it returns true it returns one

318
00:16:32,650 --> 00:16:37,480
and not whatever number you happen to

319
00:16:34,420 --> 00:16:40,120
give it so obviously this is a very

320
00:16:37,480 --> 00:16:45,040
different operations than you have with

321
00:16:40,120 --> 00:16:48,250
the single versions of those and but

322
00:16:45,040 --> 00:16:50,680
it's easy just because you mentally slip

323
00:16:48,250 --> 00:16:52,840
or because you type something wrong to

324
00:16:50,680 --> 00:16:54,730
do the wrong time but in particularly

325
00:16:52,840 --> 00:16:57,370
this early termination is something that

326
00:16:54,730 --> 00:17:00,250
of course people use a lot if you want

327
00:16:57,370 --> 00:17:02,680
to make sure that you're not accessing a

328
00:17:00,250 --> 00:17:05,500
null pointer you can test whether that's

329
00:17:02,680 --> 00:17:07,180
a null pointer first before accessing it

330
00:17:05,500 --> 00:17:10,690
and this if this is zero

331
00:17:07,180 --> 00:17:14,080
No then it will do the the dereferencing

332
00:17:10,690 --> 00:17:18,700
of null so it's a fairly useful feature

333
00:17:14,080 --> 00:17:20,920
as well so anyways just that's an aside

334
00:17:18,700 --> 00:17:23,020
at this level we're mostly looking at

335
00:17:20,920 --> 00:17:34,000
bits but just as a programming note

336
00:17:23,020 --> 00:17:35,890
don't mix these up the other class of

337
00:17:34,000 --> 00:17:38,230
operations will make use of a lot are

338
00:17:35,890 --> 00:17:40,630
shifting which again is not something

339
00:17:38,230 --> 00:17:43,270
that you normally sort of as beginning

340
00:17:40,630 --> 00:17:45,580
programmers think about too much and if

341
00:17:43,270 --> 00:17:47,320
there's a curious feature that a left

342
00:17:45,580 --> 00:17:49,240
shifts are always the same but there's

343
00:17:47,320 --> 00:17:51,610
two different flavors of right shift and

344
00:17:49,240 --> 00:17:53,200
we'll see in a little bit later why

345
00:17:51,610 --> 00:18:00,520
there's two different flavors of right

346
00:17:53,200 --> 00:18:03,340
shift but um the idea then of shifting

347
00:18:00,520 --> 00:18:04,720
is that you have some argument X and you

348
00:18:03,340 --> 00:18:06,580
want to shift it some number of

349
00:18:04,720 --> 00:18:10,360
positions either to the left or to the

350
00:18:06,580 --> 00:18:13,060
right given by Y and so when you shift

351
00:18:10,360 --> 00:18:15,910
left you just fill in whatever value

352
00:18:13,060 --> 00:18:17,680
there was so you pick up the I'm

353
00:18:15,910 --> 00:18:20,470
shifting by three so I'll take the lower

354
00:18:17,680 --> 00:18:23,020
order five bits move them over three

355
00:18:20,470 --> 00:18:25,600
positions and then fill in with a zero

356
00:18:23,020 --> 00:18:27,880
and whatever was in the upper positions

357
00:18:25,600 --> 00:18:31,530
of that original word they just sort of

358
00:18:27,880 --> 00:18:34,060
disappear into the of into nowhere

359
00:18:31,530 --> 00:18:36,160
similarly if I do a right shift I kicked

360
00:18:34,060 --> 00:18:40,360
the upper six bits I move them over to

361
00:18:36,160 --> 00:18:43,330
positions and I fill in with zeros so

362
00:18:40,360 --> 00:18:46,330
that's a logical shift and that's well

363
00:18:43,330 --> 00:18:48,670
it's logical um there's another flavor

364
00:18:46,330 --> 00:18:50,890
called the arithmetic shift which it

365
00:18:48,670 --> 00:18:54,720
differs in that the rule for what bits

366
00:18:50,890 --> 00:18:57,520
you fill in with are not based on the

367
00:18:54,720 --> 00:18:59,770
are not zeros necessarily but it's

368
00:18:57,520 --> 00:19:02,710
whatever the most significant bit was in

369
00:18:59,770 --> 00:19:04,180
the original value so it doesn't matter

370
00:19:02,710 --> 00:19:06,400
here because the most significant bit

371
00:19:04,180 --> 00:19:12,940
was zero but you'll see in the case here

372
00:19:06,400 --> 00:19:16,240
of where the leading bit was a one that

373
00:19:12,940 --> 00:19:19,990
when I shift it to the right arithmetic

374
00:19:16,240 --> 00:19:20,960
we I'll fill it in with once and that'll

375
00:19:19,990 --> 00:19:22,820
make sense more

376
00:19:20,960 --> 00:19:26,419
when we understand how negative numbers

377
00:19:22,820 --> 00:19:27,919
get represented in a machine and that's

378
00:19:26,419 --> 00:19:34,600
the purpose of it and why it's called

379
00:19:27,919 --> 00:19:38,480
arithmetic oh the other thing that is

380
00:19:34,600 --> 00:19:40,850
kind of confusing to people is what what

381
00:19:38,480 --> 00:19:44,240
should happen if you say I want to shift

382
00:19:40,850 --> 00:19:57,830
an 8-bit number eight positions to the

383
00:19:44,240 --> 00:20:03,710
left and X is a single byte what do you

384
00:19:57,830 --> 00:20:05,450
think you should get zero that would be

385
00:20:03,710 --> 00:20:06,980
a pretty logical thing you kind of shift

386
00:20:05,450 --> 00:20:10,760
all those bits out you fill them with

387
00:20:06,980 --> 00:20:14,320
zeros on most machines you'll get

388
00:20:10,760 --> 00:20:14,320
whatever X was

389
00:20:16,799 --> 00:20:26,289
because what it will do is it will

390
00:20:19,840 --> 00:20:27,909
compute this number mod eight and the

391
00:20:26,289 --> 00:20:29,739
reason that happens is if you think

392
00:20:27,909 --> 00:20:32,379
about it it's looking at just the low

393
00:20:29,739 --> 00:20:34,809
order three bits of the shift amount and

394
00:20:32,379 --> 00:20:38,139
ignoring all the rest so that's

395
00:20:34,809 --> 00:20:40,779
effectively like module eight so that's

396
00:20:38,139 --> 00:20:42,820
just a warning I and some machines that

397
00:20:40,779 --> 00:20:45,190
does what you just thought it should and

398
00:20:42,820 --> 00:20:48,609
other machines that does this and so

399
00:20:45,190 --> 00:20:51,659
there's no no guarantee and see that it

400
00:20:48,609 --> 00:20:51,659
will be one way or the other

401
00:20:52,259 --> 00:20:58,299
same with if you try to shift left by a

402
00:20:55,659 --> 00:20:59,799
negative number that might be logically

403
00:20:58,299 --> 00:21:02,349
well I guess you really want to shift

404
00:20:59,799 --> 00:21:07,739
right then but that usually doesn't work

405
00:21:02,349 --> 00:21:12,879
either so now let's talk about number

406
00:21:07,739 --> 00:21:16,299
representation and this instead of a

407
00:21:12,879 --> 00:21:19,119
very core its idea that you have to

408
00:21:16,299 --> 00:21:23,249
really have wired in you and I'm going

409
00:21:19,119 --> 00:21:23,249
to illustrate it with some examples

410
00:21:27,210 --> 00:21:33,850
so the these two equations then are

411
00:21:31,440 --> 00:21:37,239
everything that we'll talk about sort of

412
00:21:33,850 --> 00:21:43,899
stems from them so one is if you have an

413
00:21:37,239 --> 00:21:48,039
unsigned number then basically it keeps

414
00:21:43,899 --> 00:21:51,460
jumping on you if you have an unsigned

415
00:21:48,039 --> 00:21:54,669
number then this is just the the

416
00:21:51,460 --> 00:21:57,820
conversion then BTU means from bit sum a

417
00:21:54,669 --> 00:22:00,519
bit level representation to an unsigned

418
00:21:57,820 --> 00:22:03,729
number of some bit pattern

419
00:22:00,519 --> 00:22:05,979
it just says we'll just add up the sum

420
00:22:03,729 --> 00:22:08,739
of the weighted bits where each bit is

421
00:22:05,979 --> 00:22:10,059
weighted by a power of two and the only

422
00:22:08,739 --> 00:22:11,529
difference when we look at two's

423
00:22:10,059 --> 00:22:14,679
complement which is a way to represent

424
00:22:11,529 --> 00:22:17,080
both negative and positive numbers is

425
00:22:14,679 --> 00:22:19,989
we'll consider the most significant bit

426
00:22:17,080 --> 00:22:22,960
to be what's called the time bit so it

427
00:22:19,989 --> 00:22:25,419
will have a negative value so let me

428
00:22:22,960 --> 00:22:27,970
just illustrate this with I'll use some

429
00:22:25,419 --> 00:22:30,399
running examples and we'll just use 5

430
00:22:27,970 --> 00:22:31,840
min umbers just as a way it really helps

431
00:22:30,399 --> 00:22:34,029
often if you're trying to understand

432
00:22:31,840 --> 00:22:40,859
this stuff to do it for some smaller

433
00:22:34,029 --> 00:22:40,859
cases so if we think about bit positions

434
00:22:48,760 --> 00:23:04,039
zero through four then those represent

435
00:23:00,140 --> 00:23:06,710
of different powers of two ways of as

436
00:23:04,039 --> 00:23:20,809
I've shown and so now if we take some

437
00:23:06,710 --> 00:23:24,830
bit of pattern like so so that's what

438
00:23:20,809 --> 00:23:27,760
I'll call X and I want to convert that

439
00:23:24,830 --> 00:23:33,909
to an unsigned number I will just

440
00:23:27,760 --> 00:23:39,799
combine eight plus four plus one and

441
00:23:33,909 --> 00:23:42,169
I'll get 13 all right so that's all that

442
00:23:39,799 --> 00:23:46,039
equation says the left-hand equation

443
00:23:42,169 --> 00:23:48,620
just take the positions that are ones

444
00:23:46,039 --> 00:23:51,380
use the corresponding power of two and

445
00:23:48,620 --> 00:23:55,150
you're done and similarly if I have a

446
00:23:51,380 --> 00:23:55,150
number where there's a leading bit

447
00:24:00,700 --> 00:24:13,270
it will be 16 plus 4 plus 2 so that will

448
00:24:08,210 --> 00:24:18,250
be 22 and so that's the unsigned case

449
00:24:13,270 --> 00:24:24,710
and the sign case is the same idea

450
00:24:18,250 --> 00:24:28,610
except that most significant debt has a

451
00:24:24,710 --> 00:24:36,680
negative value so it will still this is

452
00:24:28,610 --> 00:24:39,890
I and our weights will be 1/2 for a but

453
00:24:36,680 --> 00:24:42,710
this one I will be minus 16 so that's

454
00:24:39,890 --> 00:24:45,860
what the equation on the right is saying

455
00:24:42,710 --> 00:24:47,060
this bit now we're going to change it

456
00:24:45,860 --> 00:24:49,940
from being a negative number to a

457
00:24:47,060 --> 00:24:51,740
positive so obviously if I have this is

458
00:24:49,940 --> 00:24:54,260
my bit pattern it's going to be the same

459
00:24:51,740 --> 00:24:58,600
because the other bits stayed at the

460
00:24:54,260 --> 00:25:07,040
same so let's do it for this case of 1 0

461
00:24:58,600 --> 00:25:13,030
1 1 0 so that will be minus 16 plus 4

462
00:25:07,040 --> 00:25:16,490
plus 2 so that equal minus 10 all right

463
00:25:13,030 --> 00:25:21,080
so you see in this case we have the same

464
00:25:16,490 --> 00:25:23,060
bit pattern it's just if we interpret it

465
00:25:21,080 --> 00:25:26,060
you know how we think about what number

466
00:25:23,060 --> 00:25:29,030
this represents then in one case it's a

467
00:25:26,060 --> 00:25:32,930
positive number 22 and in another case

468
00:25:29,030 --> 00:25:36,460
it's a negative number minus 10 and

469
00:25:32,930 --> 00:25:36,460
that's what these equations do say

470
00:25:39,840 --> 00:25:45,270
and so the most significant bit is

471
00:25:42,630 --> 00:25:46,920
sometimes called the sign bit because if

472
00:25:45,270 --> 00:25:57,170
it's a one the number is going to be

473
00:25:46,920 --> 00:25:59,700
negative so let's say to think about

474
00:25:57,170 --> 00:26:01,830
what extreme what are the sort of

475
00:25:59,700 --> 00:26:05,600
extreme ranges of numbers we can get

476
00:26:01,830 --> 00:26:05,600
with these two different representations

477
00:26:09,070 --> 00:26:14,760
[Applause]

478
00:26:11,630 --> 00:26:20,220
so obviously if these are all zeros my

479
00:26:14,760 --> 00:26:22,820
number is going to equal zero and if

480
00:26:20,220 --> 00:26:22,820
it's all one

481
00:26:25,840 --> 00:26:38,840
it'll be 16 plus 8 plus 4 plus 2 plus 1

482
00:26:32,630 --> 00:26:44,030
will be 31 and over here for the two's

483
00:26:38,840 --> 00:26:51,020
complement the smallest number well the

484
00:26:44,030 --> 00:26:52,730
largest number will actually be let me

485
00:26:51,020 --> 00:26:55,010
do it this way actually the most

486
00:26:52,730 --> 00:26:56,780
negative number so the smallest number

487
00:26:55,010 --> 00:27:02,240
and the strictest sense of the word

488
00:26:56,780 --> 00:27:05,300
is this it's minus 16 you can argue this

489
00:27:02,240 --> 00:27:07,160
by the way that this is the only bit

490
00:27:05,300 --> 00:27:09,860
that has a negative weight all the other

491
00:27:07,160 --> 00:27:12,080
ones have positive one so certainly one

492
00:27:09,860 --> 00:27:14,240
and all the rest being zeros is going to

493
00:27:12,080 --> 00:27:21,370
be the smallest number consider away the

494
00:27:14,240 --> 00:27:28,870
largest number you can represent will be

495
00:27:21,370 --> 00:27:28,870
8 plus 4 plus 2 plus 1 which is 15

496
00:27:30,300 --> 00:27:44,140
and so we call this number you max and

497
00:27:38,140 --> 00:27:49,210
we call this number t max and we call

498
00:27:44,140 --> 00:27:51,300
this number 2 min so there's a few

499
00:27:49,210 --> 00:27:56,800
things to observe about these numbers

500
00:27:51,300 --> 00:28:02,580
all that remember this is a 5 bit word

501
00:27:56,800 --> 00:28:07,270
size right so you'll see that 31 is

502
00:28:02,580 --> 00:28:13,560
pretty close to 32 right in fact it's 2

503
00:28:07,270 --> 00:28:16,270
to the fifth minus 1 and in general if

504
00:28:13,560 --> 00:28:18,340
it's a fight and that's for a 5 bit word

505
00:28:16,270 --> 00:28:21,160
size so you would say in general it will

506
00:28:18,340 --> 00:28:26,200
have value 2 to the W if I have a W bit

507
00:28:21,160 --> 00:28:34,720
number minus 1 and that's what this

508
00:28:26,200 --> 00:28:40,960
shows and similarly over here this is 2

509
00:28:34,720 --> 00:28:43,330
to the minus 2 to the 4th and so we'd

510
00:28:40,960 --> 00:28:48,360
say in general that will be minus 2 to

511
00:28:43,330 --> 00:28:48,360
the W if it's the W bit number minus 1

512
00:28:48,480 --> 00:28:55,680
but all these make sense by the way

513
00:28:52,000 --> 00:28:55,680
you'll notice one other feature is

514
00:28:58,070 --> 00:29:05,960
a whole string of one like this if you

515
00:29:03,050 --> 00:29:10,790
sum up those digits 8 plus 4 plus 2 plus

516
00:29:05,960 --> 00:29:14,540
1 will be 1 less than the next bit

517
00:29:10,790 --> 00:29:19,010
position up and you can think about that

518
00:29:14,540 --> 00:29:21,110
if you were to count this number if you

519
00:29:19,010 --> 00:29:25,160
were to increment this number by 1 you'd

520
00:29:21,110 --> 00:29:26,540
get 1 1 is 0 carry 1 and so forth and

521
00:29:25,160 --> 00:29:28,460
you'd carry that value up to this

522
00:29:26,540 --> 00:29:32,600
position so these various ways you can

523
00:29:28,460 --> 00:29:38,750
think about that and then similarly this

524
00:29:32,600 --> 00:29:41,960
number is 2 to the 4th minus 1 and so

525
00:29:38,750 --> 00:29:55,130
that's equal to 2 to the W minus 1 minus

526
00:29:41,960 --> 00:29:57,500
1 as is shown here so you know there's a

527
00:29:55,130 --> 00:29:58,900
lot of the book goes through formulas

528
00:29:57,500 --> 00:30:01,520
and done starvation's

529
00:29:58,900 --> 00:30:04,850
but if you just think about it in these

530
00:30:01,520 --> 00:30:07,640
smaller scale ways the intuition is

531
00:30:04,850 --> 00:30:11,210
pretty easy to get and don't get lost in

532
00:30:07,640 --> 00:30:13,280
in formulas when really at the gut level

533
00:30:11,210 --> 00:30:16,330
it's a fairly straightforward sort of

534
00:30:13,280 --> 00:30:19,640
ideas well if you ever see some

535
00:30:16,330 --> 00:30:21,290
confusions and you confused try out some

536
00:30:19,640 --> 00:30:22,090
small examples and see what they're

537
00:30:21,290 --> 00:30:26,000
saying

538
00:30:22,090 --> 00:30:29,390
another interesting number in the world

539
00:30:26,000 --> 00:30:33,190
of two's complement is what happens when

540
00:30:29,390 --> 00:30:33,190
you have all ones in your bit pattern

541
00:30:34,780 --> 00:30:44,150
and that will have 8 minus 16 plus 8

542
00:30:38,390 --> 00:30:51,410
plus 4 plus 2 plus 1 and that will equal

543
00:30:44,150 --> 00:30:53,540
minus 1 so the bit pattern all one is

544
00:30:51,410 --> 00:30:55,730
always a minus 1 in this representation

545
00:30:53,540 --> 00:30:58,850
I should mention to complement it's not

546
00:30:55,730 --> 00:31:00,410
the only way to represent a positive and

547
00:30:58,850 --> 00:31:02,990
negative numbers but sometimes called

548
00:31:00,410 --> 00:31:05,540
signed numbers but it's so Universal

549
00:31:02,990 --> 00:31:08,420
that you'll hardly ever encounter

550
00:31:05,540 --> 00:31:10,550
another case so if you understand two's

551
00:31:08,420 --> 00:31:11,389
complement you have a pretty good

552
00:31:10,550 --> 00:31:16,209
understanding

553
00:31:11,389 --> 00:31:16,209
of what really is going on

554
00:31:21,160 --> 00:31:27,920
so these numbers I call you max the

555
00:31:25,310 --> 00:31:31,760
biggest unsigned number team n the

556
00:31:27,920 --> 00:31:34,100
smallest most negative to compliment

557
00:31:31,760 --> 00:31:37,550
lender and team X the largest most

558
00:31:34,100 --> 00:31:39,440
positive two's complement this chart

559
00:31:37,550 --> 00:31:42,170
shows the range of values for different

560
00:31:39,440 --> 00:31:47,570
word sizes or different numbers of bytes

561
00:31:42,170 --> 00:31:49,420
and so you'll see that with a with an 8

562
00:31:47,570 --> 00:31:55,280
bit number you only have 256

563
00:31:49,420 --> 00:31:59,480
possibilities right and so we can either

564
00:31:55,280 --> 00:32:02,390
choose to think of those as representing

565
00:31:59,480 --> 00:32:04,510
the range from 0 to 255 or basically

566
00:32:02,390 --> 00:32:07,130
with two's complement numbers we're just

567
00:32:04,510 --> 00:32:08,510
doing a sort of a wraparound we're

568
00:32:07,130 --> 00:32:10,910
saying well we're going to have half of

569
00:32:08,510 --> 00:32:17,360
them be negative and the other half will

570
00:32:10,910 --> 00:32:19,130
be either 0 or positive and so it's a

571
00:32:17,360 --> 00:32:23,330
pretty limited range of values of course

572
00:32:19,130 --> 00:32:25,970
and then 16 and believe me back when

573
00:32:23,330 --> 00:32:28,430
computers had 16-bit word sizes it was a

574
00:32:25,970 --> 00:32:31,340
nuisance to keep your numbers within

575
00:32:28,430 --> 00:32:33,460
that range and 32 gives you a pretty

576
00:32:31,340 --> 00:32:37,970
decent range it used to be said

577
00:32:33,460 --> 00:32:42,730
Microsoft had to go to 64-bit word size

578
00:32:37,970 --> 00:32:42,730
to represent Bill Gates's net worth but

579
00:32:42,940 --> 00:32:48,010
for me at least this would easily handle

580
00:32:45,710 --> 00:32:50,830
my range of normal day-to-day

581
00:32:48,010 --> 00:32:54,140
transaction so

582
00:32:50,830 --> 00:32:55,970
but now with 64-bit at least to us

583
00:32:54,140 --> 00:32:59,060
nowadays those seem like really big

584
00:32:55,970 --> 00:33:05,660
numbers and hard to imagine exceeding

585
00:32:59,060 --> 00:33:10,490
the bounds of those so one interesting

586
00:33:05,660 --> 00:33:28,570
feature that you noticed here was I was

587
00:33:10,490 --> 00:33:28,570
um like this case here in this case here

588
00:33:33,460 --> 00:33:47,180
and then this case here of all one I was

589
00:33:43,430 --> 00:33:50,690
comparing it to this case here of all

590
00:33:47,180 --> 00:33:55,780
one so in other words in both these

591
00:33:50,690 --> 00:33:58,460
cases and hard to jump boards here

592
00:33:55,780 --> 00:34:02,000
you're seeing that you have the same bit

593
00:33:58,460 --> 00:34:03,860
pattern in either case but they the

594
00:34:02,000 --> 00:34:05,240
numeric they represent different numeric

595
00:34:03,860 --> 00:34:08,480
values because one is the two's

596
00:34:05,240 --> 00:34:11,750
complement case and the other is an

597
00:34:08,480 --> 00:34:13,400
unsigned right and you can actually see

598
00:34:11,750 --> 00:34:15,950
the relation between them is pretty

599
00:34:13,400 --> 00:34:18,680
simple because basically what we're

600
00:34:15,950 --> 00:34:24,050
doing is we're jumping between a plus

601
00:34:18,680 --> 00:34:27,500
sixteen and a minus 60 between those and

602
00:34:24,050 --> 00:34:30,470
so you'd expect it to change by 32 right

603
00:34:27,500 --> 00:34:34,700
and you see that here that this is 31

604
00:34:30,470 --> 00:34:37,540
here and minus 1 this is 22 and minus 10

605
00:34:34,700 --> 00:34:42,080
so they're differ from each other by

606
00:34:37,540 --> 00:34:45,890
plus or minus 30 to 2 to the fifth to to

607
00:34:42,080 --> 00:34:48,590
the word size and so we sort of a long

608
00:34:45,890 --> 00:34:52,670
derivation in the book and things here

609
00:34:48,590 --> 00:34:56,150
but that connection is actually fairly

610
00:34:52,670 --> 00:34:59,540
important because when you jump back and

611
00:34:56,150 --> 00:35:02,910
forth between unsigned numbers and two's

612
00:34:59,540 --> 00:35:06,630
complement numbers in sea

613
00:35:02,910 --> 00:35:12,510
that that's the jump that you get in

614
00:35:06,630 --> 00:35:15,900
other words when of in and so you'll

615
00:35:12,510 --> 00:35:18,359
often find cases where what used to be a

616
00:35:15,900 --> 00:35:20,039
very large number because it was

617
00:35:18,359 --> 00:35:21,630
unsigned all of a sudden becomes a

618
00:35:20,039 --> 00:35:24,630
negative number because it's considered

619
00:35:21,630 --> 00:35:32,460
two's complement so that's what this

620
00:35:24,630 --> 00:35:36,390
next part covers will say that if we

621
00:35:32,460 --> 00:35:38,339
take a cart of 4 bit numbers and we

622
00:35:36,390 --> 00:35:42,539
write out all the possible values as

623
00:35:38,339 --> 00:35:45,000
unsigned or as of two's complement

624
00:35:42,539 --> 00:35:47,849
numbers then the ones where the low the

625
00:35:45,000 --> 00:35:50,640
higher bit is 0 will be the same in both

626
00:35:47,849 --> 00:35:53,010
cases the ones where the higher order

627
00:35:50,640 --> 00:35:59,220
bit is a 1 in this case will differ by

628
00:35:53,010 --> 00:36:01,500
16 2 to the 4th and similarly you'll

629
00:35:59,220 --> 00:36:04,470
notice that these numbers there's a

630
00:36:01,500 --> 00:36:07,079
unique it goes unique in both directions

631
00:36:04,470 --> 00:36:10,589
there's a for any given bit pattern

632
00:36:07,079 --> 00:36:13,349
there's a unique number it represents

633
00:36:10,589 --> 00:36:16,010
and similarly for any number within the

634
00:36:13,349 --> 00:36:19,950
given range there's a unique bit pattern

635
00:36:16,010 --> 00:36:26,579
so we can sort of jump between those two

636
00:36:19,950 --> 00:36:28,799
and say I can make up a rule for

637
00:36:26,579 --> 00:36:32,059
converting between a two's complement

638
00:36:28,799 --> 00:36:34,980
number X and an unsigned number UX that

639
00:36:32,059 --> 00:36:36,270
basically says I'll use the same bit

640
00:36:34,980 --> 00:36:41,010
I'll just think of them as being

641
00:36:36,270 --> 00:36:43,950
different numbers and so and you can go

642
00:36:41,010 --> 00:36:49,940
either way so for example if we thought

643
00:36:43,950 --> 00:36:54,660
of this is a a two's complement

644
00:36:49,940 --> 00:36:59,180
representative representation it's minus

645
00:36:54,660 --> 00:37:02,789
1 this function I'm calling T to you

646
00:36:59,180 --> 00:37:08,819
goes from that number minus 1 to this

647
00:37:02,789 --> 00:37:10,799
number 31 as the where in between the

648
00:37:08,819 --> 00:37:13,609
two I'm saying they both have the same

649
00:37:10,799 --> 00:37:13,609
bit pattern

650
00:37:15,210 --> 00:37:21,190
and the reason why this rather function

651
00:37:19,690 --> 00:37:23,290
that would otherwise seem to have no

652
00:37:21,190 --> 00:37:26,200
particular use is important is because

653
00:37:23,290 --> 00:37:30,250
that's basically what happens in CR

654
00:37:26,200 --> 00:37:32,740
actually in the program in the program

655
00:37:30,250 --> 00:37:35,050
on the computer itself has no clue

656
00:37:32,740 --> 00:37:36,640
whether a given bit pattern if it's

657
00:37:35,050 --> 00:37:39,340
something you're thinking of as being a

658
00:37:36,640 --> 00:37:40,960
negative none signed number or tooth

659
00:37:39,340 --> 00:37:45,130
compliment number it's just a bunch of

660
00:37:40,960 --> 00:37:48,550
bits to it and similarly we can go back

661
00:37:45,130 --> 00:37:50,620
and forth between a two's complement and

662
00:37:48,550 --> 00:37:56,410
unsigned keeping the bit patterns the

663
00:37:50,620 --> 00:37:58,420
same and so I'll call that T to you when

664
00:37:56,410 --> 00:38:01,870
I go from signed to unsigned two's

665
00:37:58,420 --> 00:38:03,940
complement tons unsigned and said well

666
00:38:01,870 --> 00:38:09,160
I'll call it u 2t if I go from unsigned

667
00:38:03,940 --> 00:38:11,590
to signed and as I mentioned the

668
00:38:09,160 --> 00:38:14,290
difference for the the numbers where the

669
00:38:11,590 --> 00:38:17,140
high order bit is a 1 will be by a

670
00:38:14,290 --> 00:38:23,020
factor 2 to the W where W is the word

671
00:38:17,140 --> 00:38:29,430
size of the word and so this can be

672
00:38:23,020 --> 00:38:29,430
thought of as a function where

673
00:38:33,880 --> 00:38:56,890
let me just draw it out over here with

674
00:38:48,020 --> 00:38:59,660
my five bit numbers that is the number

675
00:38:56,890 --> 00:39:02,870
this is to complement again so that was

676
00:38:59,660 --> 00:39:04,550
the number of minus sixteen and then

677
00:39:02,870 --> 00:39:10,540
there'll be some other negative numbers

678
00:39:04,550 --> 00:39:17,330
up to all one this number negative one

679
00:39:10,540 --> 00:39:26,020
and then I'll have zero and so forth and

680
00:39:17,330 --> 00:39:26,020
then all up to I'm going to run a room

681
00:39:26,560 --> 00:39:34,150
plus fifteen I just draw I got myself in

682
00:39:31,970 --> 00:39:34,150
trouble

683
00:39:36,580 --> 00:39:48,200
blackboard management is they didn't

684
00:39:39,440 --> 00:39:51,610
teach me this cool so I'm going to use

685
00:39:48,200 --> 00:39:51,610
two boards at once here

686
00:39:56,550 --> 00:40:21,180
Oh what makes it okay we'll make it work

687
00:40:15,540 --> 00:40:24,000
so now when we go from the TTU function

688
00:40:21,180 --> 00:40:29,070
then these numbers are going to just

689
00:40:24,000 --> 00:40:35,010
carry over we'll get zero up through

690
00:40:29,070 --> 00:40:46,740
fifteen but now this number here will

691
00:40:35,010 --> 00:40:51,510
become positive sixteen and all one will

692
00:40:46,740 --> 00:40:53,910
become positive thirty-one right and so

693
00:40:51,510 --> 00:40:57,810
that's what this picture is showing is

694
00:40:53,910 --> 00:41:00,690
it for the pink numbers are the ones

695
00:40:57,810 --> 00:41:03,140
that flip between negative and actually

696
00:41:00,690 --> 00:41:05,460
the largest of the positive numbers and

697
00:41:03,140 --> 00:41:07,560
then the green numbers are the ones that

698
00:41:05,460 --> 00:41:10,460
stay the same because they're leading

699
00:41:07,560 --> 00:41:10,460
bit to zeros

700
00:41:13,859 --> 00:41:20,649
so why does this matter you never

701
00:41:18,009 --> 00:41:24,789
thought if you programmed in Python say

702
00:41:20,649 --> 00:41:28,329
or even Java you don't see that and the

703
00:41:24,789 --> 00:41:31,749
reason is because C is one of the few

704
00:41:28,329 --> 00:41:35,319
languages where unsigned is actually an

705
00:41:31,749 --> 00:41:38,529
explicit datatype and you so you can

706
00:41:35,319 --> 00:41:40,719
declare a value being unsigned in it you

707
00:41:38,529 --> 00:41:43,779
can if you just say unsigned what you're

708
00:41:40,719 --> 00:41:45,609
really saying is unsigned int or you can

709
00:41:43,779 --> 00:41:49,779
call something an unsigned care and

710
00:41:45,609 --> 00:41:52,239
unsigned short or an unsigned long so

711
00:41:49,779 --> 00:41:54,359
and you're declaring and see that it

712
00:41:52,239 --> 00:41:57,069
should think about using this

713
00:41:54,359 --> 00:42:02,409
representation we show on the right when

714
00:41:57,069 --> 00:42:05,859
it's working on those numbers so that's

715
00:42:02,409 --> 00:42:07,689
sort of one thing and this it's one

716
00:42:05,859 --> 00:42:10,479
thing if you declare a number and use it

717
00:42:07,689 --> 00:42:15,429
that way but what gets people and often

718
00:42:10,479 --> 00:42:18,099
got you is if you declare something if

719
00:42:15,429 --> 00:42:20,829
you have a in this case something that's

720
00:42:18,099 --> 00:42:24,069
declared as a to complement number X to

721
00:42:20,829 --> 00:42:27,130
X and you assign it a value you at Y X

722
00:42:24,069 --> 00:42:29,349
it will do an implicit casting which is

723
00:42:27,130 --> 00:42:31,839
exactly based on this conversion that

724
00:42:29,349 --> 00:42:39,789
we've been talking about and vice versa

725
00:42:31,839 --> 00:42:42,339
and so as this example goes through this

726
00:42:39,789 --> 00:42:46,659
goes through some examples that if I

727
00:42:42,339 --> 00:42:48,729
look at two numbers and I compare them

728
00:42:46,659 --> 00:42:51,989
or I actually I do any operation on them

729
00:42:48,729 --> 00:42:54,639
I add them divide them anything

730
00:42:51,989 --> 00:42:57,249
implicitly it will try to make these to

731
00:42:54,639 --> 00:42:59,589
be of the same type and the way it will

732
00:42:57,249 --> 00:43:03,130
do that is to say if both of them are

733
00:42:59,589 --> 00:43:06,669
signed then I'll do I'll treat them as a

734
00:43:03,130 --> 00:43:09,489
signed case if either of them is

735
00:43:06,669 --> 00:43:11,769
unsigned then I'll convert the other one

736
00:43:09,489 --> 00:43:15,069
to be an unsigned number and do the

737
00:43:11,769 --> 00:43:17,139
operation and so in particular this set

738
00:43:15,069 --> 00:43:18,729
of examples is imagine I'm comparing

739
00:43:17,139 --> 00:43:21,389
these I'm saying these numbers are

740
00:43:18,729 --> 00:43:24,759
either equal less or greater

741
00:43:21,389 --> 00:43:26,649
what will the outcomes be and the key to

742
00:43:24,759 --> 00:43:27,280
answering that question is to first of

743
00:43:26,649 --> 00:43:30,550
all figure

744
00:43:27,280 --> 00:43:34,720
out okay is it assigned or an unsigned

745
00:43:30,550 --> 00:43:37,720
comparison should I convert one of these

746
00:43:34,720 --> 00:43:40,510
numbers to either of these numbers to an

747
00:43:37,720 --> 00:43:43,000
unsigned form before I do it and the

748
00:43:40,510 --> 00:43:46,210
rule was if either argument is unsigned

749
00:43:43,000 --> 00:43:48,910
then you got to do it and as you see

750
00:43:46,210 --> 00:43:51,790
when you put a you at the end either a

751
00:43:48,910 --> 00:43:55,300
lowercase u or uppercase u at the end of

752
00:43:51,790 --> 00:43:58,870
a numeric constant you're saying this is

753
00:43:55,300 --> 00:44:06,990
an unsigned value so for example if we

754
00:43:58,870 --> 00:44:06,990
compare a 0 and 0 unsigned they're equal

755
00:44:07,140 --> 00:44:12,900
and if we combine negative 1 compare

756
00:44:11,410 --> 00:44:16,810
negative 1 to 0

757
00:44:12,900 --> 00:44:20,620
we'll get that the first one is less

758
00:44:16,810 --> 00:44:22,330
because negative 1 is less than 0 but

759
00:44:20,620 --> 00:44:26,070
what would happen with the next one when

760
00:44:22,330 --> 00:44:32,020
we compare negative 1 to an unsigned 0

761
00:44:26,070 --> 00:44:39,670
greater right so this is the surprise

762
00:44:32,020 --> 00:44:46,270
and it has to do with a number that I

763
00:44:39,670 --> 00:44:51,730
erased but we can still get it remember

764
00:44:46,270 --> 00:44:55,780
this is negative 1 but when I cast that

765
00:44:51,730 --> 00:44:59,020
to an unsigned number I'm flipping this

766
00:44:55,780 --> 00:45:00,820
from minus 16 to positive 16 and turning

767
00:44:59,020 --> 00:45:02,980
this into 31 I'm turning it into

768
00:45:00,820 --> 00:45:05,920
actually the largest number I can

769
00:45:02,980 --> 00:45:09,100
represent and so it will be greater than

770
00:45:05,920 --> 00:45:09,610
0 so it's a little bit weird to think

771
00:45:09,100 --> 00:45:11,860
about

772
00:45:09,610 --> 00:45:15,190
I took an unsigned 0 which after all is

773
00:45:11,860 --> 00:45:19,210
to 0 and compared it to negative 1 and

774
00:45:15,190 --> 00:45:21,310
it said oh you really meant 31 didn't

775
00:45:19,210 --> 00:45:26,020
you or whatever word size were using and

776
00:45:21,310 --> 00:45:27,700
so it said it's greater and basically

777
00:45:26,020 --> 00:45:35,160
the rest of these you can answer in a

778
00:45:27,700 --> 00:45:39,420
similar way that these two numbers are

779
00:45:35,160 --> 00:45:43,900
this is clearly one smaller than this

780
00:45:39,420 --> 00:45:44,740
no I'm sorry this is a positive this is

781
00:45:43,900 --> 00:45:49,570
a negative number

782
00:45:44,740 --> 00:45:52,359
and if I compare those and the positive

783
00:45:49,570 --> 00:45:54,640
will be greater than the negative I'll

784
00:45:52,359 --> 00:45:58,030
tell you in a minute why this number is

785
00:45:54,640 --> 00:46:01,930
written this way the next one it's the

786
00:45:58,030 --> 00:46:07,450
same pair of numbers but you see it

787
00:46:01,930 --> 00:46:20,140
flipped and the reason is that this

788
00:46:07,450 --> 00:46:24,510
number on the left is T max 4 so it's

789
00:46:20,140 --> 00:46:24,510
the bit pattern in a 32-bit number

790
00:46:48,319 --> 00:46:52,469
um

791
00:46:50,089 --> 00:46:55,409
to this day I've not memorized this

792
00:46:52,469 --> 00:46:59,029
number by the way but and then this

793
00:46:55,409 --> 00:46:59,029
number is actually T min

794
00:47:13,770 --> 00:47:23,140
and that when I subtract you can think

795
00:47:18,640 --> 00:47:25,720
of it as this is negative T max minus

796
00:47:23,140 --> 00:47:27,820
one so that's T min so if I do an

797
00:47:25,720 --> 00:47:31,540
unsigned comparison between those two

798
00:47:27,820 --> 00:47:33,580
now think of those this leading bit not

799
00:47:31,540 --> 00:47:35,230
being a negative weight but a positive

800
00:47:33,580 --> 00:47:43,420
weight you'll see that this is a bigger

801
00:47:35,230 --> 00:47:46,930
number than this one and so it so it

802
00:47:43,420 --> 00:47:50,940
goes that minus 1 is greater than minus

803
00:47:46,930 --> 00:47:53,920
2 if they're unsigned because minus 1 is

804
00:47:50,940 --> 00:47:55,780
you can think of it as converts into u

805
00:47:53,920 --> 00:48:01,150
max it will be the biggest number

806
00:47:55,780 --> 00:48:07,170
possible and minus 2 will be would be 1

807
00:48:01,150 --> 00:48:07,170
1 1 1 0

808
00:48:16,980 --> 00:48:26,410
so that can get fairly confusing one

809
00:48:23,890 --> 00:48:29,080
final quirk this way of writing this

810
00:48:26,410 --> 00:48:31,450
number is there's a little side in the

811
00:48:29,080 --> 00:48:32,560
book about it if you write a business

812
00:48:31,450 --> 00:48:36,250
number Oh

813
00:48:32,560 --> 00:48:42,849
as you'd expect - as - blah blah blah

814
00:48:36,250 --> 00:48:45,450
six four eight it will actually get the

815
00:48:42,849 --> 00:48:48,970
C compiler gets kind of confused by that

816
00:48:45,450 --> 00:48:50,770
for obscure reasons one other thing I

817
00:48:48,970 --> 00:48:53,500
should point out that it's a property

818
00:48:50,770 --> 00:48:58,859
that I don't think we cover well enough

819
00:48:53,500 --> 00:48:58,859
here let me see

820
00:49:01,830 --> 00:49:05,710
there's a few things that the slides

821
00:49:04,210 --> 00:49:14,350
don't really cover here and I don't know

822
00:49:05,710 --> 00:49:16,150
why not I like to point out so they're

823
00:49:14,350 --> 00:49:30,550
kind of useful properties to keep track

824
00:49:16,150 --> 00:49:35,440
of is that you notice that if you look

825
00:49:30,550 --> 00:49:37,330
at the absolute value of T Max and you

826
00:49:35,440 --> 00:49:48,250
compare it to the absolute value of T

827
00:49:37,330 --> 00:49:50,230
min that it's off by 1 right so that the

828
00:49:48,250 --> 00:49:52,600
negative number is more negative the

829
00:49:50,230 --> 00:49:54,100
smallest negative number is more

830
00:49:52,600 --> 00:49:56,920
negative than the largest positive

831
00:49:54,100 --> 00:49:58,540
number is positive and the reason for

832
00:49:56,920 --> 00:50:04,030
that actually is fairly simple if you

833
00:49:58,540 --> 00:50:10,860
think about it is that the cases where

834
00:50:04,030 --> 00:50:10,860
you have zeros includes the number 0

835
00:50:20,290 --> 00:50:31,520
you can see it better and there's two to

836
00:50:27,349 --> 00:50:36,079
the half year ranges occupied by those

837
00:50:31,520 --> 00:50:44,869
numbers and the negative numbers are all

838
00:50:36,079 --> 00:50:48,890
negative and there's so the other half

839
00:50:44,869 --> 00:50:51,050
of the range is in there and the point

840
00:50:48,890 --> 00:50:53,359
is that you had to use one of these for

841
00:50:51,050 --> 00:50:57,920
zero and so they're only there's one

842
00:50:53,359 --> 00:51:02,540
less one less value left over and that's

843
00:50:57,920 --> 00:51:04,849
why you end up with this asymmetry and

844
00:51:02,540 --> 00:51:10,790
this asymmetry is the cause of no end of

845
00:51:04,849 --> 00:51:13,970
pain in various ways that like a few the

846
00:51:10,790 --> 00:51:17,230
classic example is if you implement

847
00:51:13,970 --> 00:51:17,230
absolute value

848
00:51:32,480 --> 00:51:45,030
like so what do you what does this

849
00:51:37,470 --> 00:51:48,750
return for team in yeah

850
00:51:45,030 --> 00:51:53,040
the returns team in we'll talk a little

851
00:51:48,750 --> 00:51:59,550
bit basically when you try to negate

852
00:51:53,040 --> 00:52:02,570
this number that's here you'll end up

853
00:51:59,550 --> 00:52:02,570
with it back again

854
00:52:07,080 --> 00:52:13,330
so it's always a corner case and

855
00:52:10,840 --> 00:52:15,190
whenever we do program testing we always

856
00:52:13,330 --> 00:52:35,230
throw that case in there to break things

857
00:52:15,190 --> 00:52:39,040
question know that they do that if you

858
00:52:35,230 --> 00:52:40,990
ever look at the in the length and the C

859
00:52:39,040 --> 00:52:43,690
constants they use this as a way of

860
00:52:40,990 --> 00:52:47,830
representing team in and they do it for

861
00:52:43,690 --> 00:52:49,690
that reason because you see it's exactly

862
00:52:47,830 --> 00:52:52,720
the spot and they put parentheses around

863
00:52:49,690 --> 00:52:54,850
it so there's no president's problem but

864
00:52:52,720 --> 00:52:59,410
you see that number that in six for

865
00:52:54,850 --> 00:53:02,980
seven that team acts and so basically

866
00:52:59,410 --> 00:53:07,200
it's just saying that team n is minus t

867
00:53:02,980 --> 00:53:07,200
max minus one question

868
00:53:12,589 --> 00:53:21,450
well- wonderful would get you laughs

869
00:53:16,549 --> 00:53:23,220
yeah mm-hmm yes so comparison is just a

870
00:53:21,450 --> 00:53:27,599
special case of the more general one

871
00:53:23,220 --> 00:53:30,450
which is addition subtraction all of

872
00:53:27,599 --> 00:53:32,279
those if either argument is unsigned

873
00:53:30,450 --> 00:53:36,539
then it interprets remaining what is

874
00:53:32,279 --> 00:53:38,309
being unsigned it it turns out and we'll

875
00:53:36,539 --> 00:53:41,039
get into this more next time

876
00:53:38,309 --> 00:53:45,289
as far as bit patterns but it turns out

877
00:53:41,039 --> 00:53:49,289
that at the bit level addition

878
00:53:45,289 --> 00:53:50,819
subtraction even multiplication are the

879
00:53:49,289 --> 00:53:53,789
same whether it's an unsigned number

880
00:53:50,819 --> 00:53:59,819
two's complement number so what we'll

881
00:53:53,789 --> 00:54:05,539
talk about that more next time and the

882
00:53:59,819 --> 00:54:05,539
other thing to observe sort of property

883
00:54:16,390 --> 00:54:32,710
is uh you saw that you Maxis is sort of

884
00:54:20,890 --> 00:54:38,559
like twice Team X plus one right so

885
00:54:32,710 --> 00:54:41,859
before you max was 15 in our five bit

886
00:54:38,559 --> 00:54:45,579
numbers and that's again not too hard to

887
00:54:41,859 --> 00:54:49,390
figure out here's one way to think about

888
00:54:45,579 --> 00:54:54,460
it t max is a zero followed by a bunch

889
00:54:49,390 --> 00:54:54,910
of ones and if I want to double that

890
00:54:54,460 --> 00:54:58,779
number

891
00:54:54,910 --> 00:55:02,559
I basically shift it left by one

892
00:54:58,779 --> 00:55:08,950
position and that would end up with a

893
00:55:02,559 --> 00:55:14,200
zero here so this is UT Max and this is

894
00:55:08,950 --> 00:55:17,980
twice team X and now if I add a one to

895
00:55:14,200 --> 00:55:20,140
that I'll just set this bit to one and

896
00:55:17,980 --> 00:55:21,789
get this so there's various ways you can

897
00:55:20,140 --> 00:55:23,819
think about it but that's one way to do

898
00:55:21,789 --> 00:55:23,819
it

899
00:55:34,020 --> 00:55:37,020
um

900
00:55:39,369 --> 00:55:48,680
it's one other thing that I wanted to

901
00:55:44,539 --> 00:55:51,279
mention too this can get you into a lot

902
00:55:48,680 --> 00:55:51,279
of trouble

903
00:55:51,519 --> 00:56:13,910
programming why so let me just show you

904
00:55:55,599 --> 00:56:16,759
what I mean so imagine I wanted to go

905
00:56:13,910 --> 00:56:22,130
backwards through an array so I write a

906
00:56:16,759 --> 00:56:29,479
loop of the form for I equals n minus 1

907
00:56:22,130 --> 00:56:35,869
I is greater than or equal to 0

908
00:56:29,479 --> 00:56:41,420
I - - and then I do something with array

909
00:56:35,869 --> 00:56:44,779
element a of I i'll just call some

910
00:56:41,420 --> 00:56:46,160
function eyes whatever you want to do in

911
00:56:44,779 --> 00:56:50,150
that loop so that's a pretty standard

912
00:56:46,160 --> 00:56:53,499
pattern in a loop right except that you

913
00:56:50,150 --> 00:56:58,269
write this greater equal to10

914
00:56:53,499 --> 00:57:02,949
you can imagine various uses for that so

915
00:56:58,269 --> 00:57:07,449
here's an interesting question what if I

916
00:57:02,949 --> 00:57:07,449
were declared as being unsigned

917
00:57:08,339 --> 00:57:17,280
because it's array index after all what

918
00:57:11,320 --> 00:57:19,530
will happen with this loop hmm yeah

919
00:57:17,280 --> 00:57:22,480
what's that

920
00:57:19,530 --> 00:57:25,359
yes so the loop will go forever what

921
00:57:22,480 --> 00:57:29,290
would most likely happen is I would go

922
00:57:25,359 --> 00:57:33,240
from being 0 to being u Max and that's a

923
00:57:29,290 --> 00:57:37,270
really big number and the Ray you'd uh

924
00:57:33,240 --> 00:57:40,300
most likely cause a memory fault because

925
00:57:37,270 --> 00:57:41,650
it's so far out of bounds but the point

926
00:57:40,300 --> 00:57:44,310
is it wouldn't do what you want it

927
00:57:41,650 --> 00:57:46,630
wouldn't stop where you want it to and

928
00:57:44,310 --> 00:57:49,480
because of the simple reason that I is

929
00:57:46,630 --> 00:57:51,160
of course I is always going to be

930
00:57:49,480 --> 00:57:55,089
greater than or equal to zero because

931
00:57:51,160 --> 00:57:58,690
it's an unsigned number so that's uh one

932
00:57:55,089 --> 00:58:00,880
you'd say okay well you should have

933
00:57:58,690 --> 00:58:03,780
figured that one out it can be paired

934
00:58:00,880 --> 00:58:03,780
more subtle though

935
00:58:06,000 --> 00:58:19,260
if you have something like int I and

936
00:58:14,070 --> 00:58:21,690
then we say something like let me just

937
00:58:19,260 --> 00:58:43,710
change it here a little bit so this will

938
00:58:21,690 --> 00:58:45,869
be something like this where the I'm

939
00:58:43,710 --> 00:58:50,580
mixing metaphors here I have to confess

940
00:58:45,869 --> 00:58:53,310
but if you use the standard the term

941
00:58:50,580 --> 00:58:55,320
sizeof which is the way you get how many

942
00:58:53,310 --> 00:58:57,480
bytes it takes to represent some given

943
00:58:55,320 --> 00:59:00,660
data type so this will actually be the

944
00:58:57,480 --> 00:59:02,820
number one so it's not the same loop as

945
00:59:00,660 --> 00:59:06,690
before but imagine I'm sort of mixing in

946
00:59:02,820 --> 00:59:10,680
of my arithmetic and making use of some

947
00:59:06,690 --> 00:59:19,760
of these built-in forms what would

948
00:59:10,680 --> 00:59:19,760
happen with this loop yeah right

949
00:59:20,470 --> 00:59:27,310
yes exactly so sizeof returns an

950
00:59:25,330 --> 00:59:29,710
unsigned value it's not actually a

951
00:59:27,310 --> 00:59:31,630
function it's a built in but it's the

952
00:59:29,710 --> 00:59:36,880
result of sizeof is considered to be

953
00:59:31,630 --> 00:59:40,360
unsigned and so just like I was saying

954
00:59:36,880 --> 00:59:43,470
if you have a signed value in an

955
00:59:40,360 --> 00:59:46,660
unsigned in any kind of arithmetic it'll

956
00:59:43,470 --> 00:59:49,510
turn treat the combination of the two is

957
00:59:46,660 --> 00:59:52,390
unsigned and so it will actually do an

958
00:59:49,510 --> 00:59:55,900
unsigned comparison here which is almost

959
00:59:52,390 --> 01:00:00,160
surely not what you wanted and this will

960
00:59:55,900 --> 01:00:02,440
just you'll look at this program and you

961
01:00:00,160 --> 01:00:05,770
will have any idea why it's crashing

962
01:00:02,440 --> 01:00:07,150
you'll be so confused and that's the

963
01:00:05,770 --> 01:00:09,070
kind of thing you have to know it's one

964
01:00:07,150 --> 01:00:11,500
of the quirks of C that probably a fake

965
01:00:09,070 --> 01:00:13,180
could start over again and redesign it

966
01:00:11,500 --> 01:00:15,370
they'd come up with some different set

967
01:00:13,180 --> 01:00:17,080
of conventions than they did but

968
01:00:15,370 --> 01:00:18,700
unfortunately it's way too late for that

969
01:00:17,080 --> 01:00:23,140
so this is just one of those things you

970
01:00:18,700 --> 01:00:25,360
have to remember but yes my point is

971
01:00:23,140 --> 01:00:27,790
there's some subtleties to spencie

972
01:00:25,360 --> 01:00:30,870
about this business of sign versus

973
01:00:27,790 --> 01:00:30,870
unsigned arithmetic

974
01:00:35,410 --> 01:00:41,680
okay so now let's look at a sort of

975
01:00:39,320 --> 01:00:44,960
final class of operations which is

976
01:00:41,680 --> 01:00:47,720
suppose I have a number that so many

977
01:00:44,960 --> 01:00:51,740
bits say eight bits and I want to now

978
01:00:47,720 --> 01:00:54,620
expand it to be a 16-bit number but it's

979
01:00:51,740 --> 01:00:57,380
a fairly cute rule for doing this

980
01:00:54,620 --> 01:00:59,810
that's called sign extension I'm talking

981
01:00:57,380 --> 01:01:04,550
about two's complement numbers here of

982
01:00:59,810 --> 01:01:10,910
how you go take a and make it bigger

983
01:01:04,550 --> 01:01:13,760
without changing its value and the basic

984
01:01:10,910 --> 01:01:16,610
rule is you do it by copying the sign

985
01:01:13,760 --> 01:01:19,690
bit to the left so let me give you the

986
01:01:16,610 --> 01:01:19,690
intuition behind that

987
01:01:29,080 --> 01:01:44,360
so let's look at some 4-bit value well

988
01:01:42,200 --> 01:01:49,100
it's pretty straightforward the leading

989
01:01:44,360 --> 01:01:59,570
bit is a 0 I'm just going to do a left

990
01:01:49,100 --> 01:02:05,180
shift and then fill in so right wait

991
01:01:59,570 --> 01:02:06,290
what am I talking about I got ahead of

992
01:02:05,180 --> 01:02:07,040
myself I'm talking about something

993
01:02:06,290 --> 01:02:09,350
totally different

994
01:02:07,040 --> 01:02:11,030
no sorry the same number I'm not

995
01:02:09,350 --> 01:02:14,150
changing the number I'm keeping it the

996
01:02:11,030 --> 01:02:16,100
same so I just add a zero to the leading

997
01:02:14,150 --> 01:02:21,070
and this will be the number six still

998
01:02:16,100 --> 01:02:24,020
this is plus four plus two equals six

999
01:02:21,070 --> 01:02:30,190
but now let's think about it as a where

1000
01:02:24,020 --> 01:02:35,210
there's a leading sign bit so this is

1001
01:02:30,190 --> 01:02:39,260
minus 8 plus four plus two is equal to

1002
01:02:35,210 --> 01:02:44,270
minus two so now what look at what

1003
01:02:39,260 --> 01:02:46,720
happens if I copy that sign bit over one

1004
01:02:44,270 --> 01:02:46,720
position

1005
01:02:47,570 --> 01:03:01,310
so this becomes a 1 1 1 1 0 and what

1006
01:02:58,160 --> 01:03:04,400
happens is this is a now has value plus

1007
01:03:01,310 --> 01:03:10,250
8 here but the sign bit has value minus

1008
01:03:04,400 --> 01:03:14,270
16 and then this is still +2 and +4 and

1009
01:03:10,250 --> 01:03:18,980
so it will still equal minus 2 so here's

1010
01:03:14,270 --> 01:03:22,670
what happened before my sign bit had a

1011
01:03:18,980 --> 01:03:26,330
weight of minus 8 and my new sign bit

1012
01:03:22,670 --> 01:03:28,400
has a weight of minus 16 but I converted

1013
01:03:26,330 --> 01:03:31,670
that old sign bit into a positive number

1014
01:03:28,400 --> 01:03:35,330
which is plus 8 and those 2 cancelled

1015
01:03:31,670 --> 01:03:37,880
out sit right the duck that you combine

1016
01:03:35,330 --> 01:03:41,530
those two and you get minus 8 which is

1017
01:03:37,880 --> 01:03:45,200
exactly this so you see by sort of

1018
01:03:41,530 --> 01:03:48,260
copying that sign bit over giving it

1019
01:03:45,200 --> 01:03:50,840
twice the weight turning it what was the

1020
01:03:48,260 --> 01:03:53,600
sign bit into a positive number you

1021
01:03:50,840 --> 01:03:55,940
don't change the net effect of the sum

1022
01:03:53,600 --> 01:03:58,310
and that's exactly the idea of sign

1023
01:03:55,940 --> 01:04:00,380
extension just keep going with that as

1024
01:03:58,310 --> 01:04:02,750
far as you need to carry it over and

1025
01:04:00,380 --> 01:04:05,890
each time you doing it you're

1026
01:04:02,750 --> 01:04:09,170
effectively doing this business of

1027
01:04:05,890 --> 01:04:11,180
coming up with a pair of bits that end

1028
01:04:09,170 --> 01:04:15,470
up with the same value is this original

1029
01:04:11,180 --> 01:04:20,030
bit so that's the idea of sign extension

1030
01:04:15,470 --> 01:04:24,680
and you'll see that a lot in bit

1031
01:04:20,030 --> 01:04:28,990
patterns especially if you see a bit

1032
01:04:24,680 --> 01:04:28,990
pattern with it starts with a bunch of F

1033
01:04:35,100 --> 01:04:47,800
what that tells you remember f is just

1034
01:04:39,160 --> 01:04:50,280
for one is a whole bunch of leading one

1035
01:04:47,800 --> 01:04:53,170
that tells you the number is negative

1036
01:04:50,280 --> 01:04:56,050
negative but not too far away from zero

1037
01:04:53,170 --> 01:04:57,640
right and and you'll see that over and

1038
01:04:56,050 --> 01:04:59,290
over again you'll see bit patterns and

1039
01:04:57,640 --> 01:05:01,150
you just sort of want it when you see

1040
01:04:59,290 --> 01:05:07,230
leading F's you say oh that's a negative

1041
01:05:01,150 --> 01:05:10,930
number I know what's going on there and

1042
01:05:07,230 --> 01:05:12,670
so here's some examples but like you can

1043
01:05:10,930 --> 01:05:16,660
see the main idea is you carry that

1044
01:05:12,670 --> 01:05:18,880
leading bit from the 16-bit case over

1045
01:05:16,660 --> 01:05:26,140
and make as many copies you need to

1046
01:05:18,880 --> 01:05:28,600
expand the word size and I should

1047
01:05:26,140 --> 01:05:33,030
mention with the unsigned case obviously

1048
01:05:28,600 --> 01:05:33,030
you just want to fill in with zeros

1049
01:05:36,250 --> 01:05:50,710
to talk about location and send missing

1050
01:05:40,300 --> 01:05:53,470
slides in this but a final case to look

1051
01:05:50,710 --> 01:05:58,930
at is what happens if I make something

1052
01:05:53,470 --> 01:06:08,530
shorter so if I had my unsigned number

1053
01:05:58,930 --> 01:06:18,400
from before if this were an unsigned

1054
01:06:08,530 --> 01:06:23,470
number this would be 1 2 8 16 14 17

1055
01:06:18,400 --> 01:06:29,890
right what if I decided oh I can't

1056
01:06:23,470 --> 01:06:31,480
afford for bit I don't have enough money

1057
01:06:29,890 --> 01:06:34,930
for five bits I'm only going to give you

1058
01:06:31,480 --> 01:06:40,450
four well you basically just drop the

1059
01:06:34,930 --> 01:06:44,080
most significant bit and you get eight

1060
01:06:40,450 --> 01:06:47,310
plus two plus one which is a low which

1061
01:06:44,080 --> 01:06:47,310
is nine

1062
01:06:47,670 --> 01:06:54,380
and the relation there is that this is

1063
01:06:50,600 --> 01:06:54,380
it's like modular arithmetic

1064
01:06:58,390 --> 01:07:09,610
right mod 16 you're taking

1065
01:07:01,250 --> 01:07:09,610
no thank you

1066
01:07:11,710 --> 01:07:24,820
the risk of improvising so 27 and 11

1067
01:07:25,840 --> 01:07:38,000
yeah make cent difference a 16 I knew

1068
01:07:32,720 --> 01:07:40,760
that okay excuse me for my stumbling but

1069
01:07:38,000 --> 01:07:42,800
the point being that when you drop this

1070
01:07:40,760 --> 01:07:47,120
thing effectively you're just taking the

1071
01:07:42,800 --> 01:07:48,350
mod some power of two of it like I

1072
01:07:47,120 --> 01:07:51,110
mentioned the case where you're taking

1073
01:07:48,350 --> 01:07:52,670
module eight if you just keep the only

1074
01:07:51,110 --> 01:07:55,370
the lowest sort of three bits you're

1075
01:07:52,670 --> 01:07:57,950
having module eight now one really this

1076
01:07:55,370 --> 01:08:00,320
is a sort of logical in the unsigned

1077
01:07:57,950 --> 01:08:03,470
world your modular arithmetic is

1078
01:08:00,320 --> 01:08:09,610
something that was understood by the

1079
01:08:03,470 --> 01:08:14,060
ancient Greek so not too far away from

1080
01:08:09,610 --> 01:08:21,920
human experience but it gets a little

1081
01:08:14,060 --> 01:08:27,190
bit funky if you're dealing with two's

1082
01:08:21,920 --> 01:08:27,190
complement numbers because this is now

1083
01:08:29,050 --> 01:08:40,100
ten eleven minus five right but this

1084
01:08:35,990 --> 01:08:42,200
number if I just drop this bit and call

1085
01:08:40,100 --> 01:08:46,180
it a 4-bit number this now becomes minus

1086
01:08:42,200 --> 01:08:46,180
eight two and one

1087
01:08:49,270 --> 01:09:00,320
which might have five you say how'd that

1088
01:08:58,220 --> 01:09:01,910
happen well actually if you look at it

1089
01:09:00,320 --> 01:09:05,900
this is just what you'd get by sign

1090
01:09:01,910 --> 01:09:08,740
extension right so this wasn't a very

1091
01:09:05,900 --> 01:09:08,740
interesting example

1092
01:09:11,370 --> 01:09:29,259
but if we changed it to this then this

1093
01:09:23,109 --> 01:09:39,489
would be minus 13 and this would be plus

1094
01:09:29,259 --> 01:09:41,799
3 and it's a little harder to think

1095
01:09:39,489 --> 01:09:43,779
about in terms of modular arithmetic the

1096
01:09:41,799 --> 01:09:48,040
way you basically have to think about it

1097
01:09:43,779 --> 01:09:52,839
is well you know this is minus 13 but

1098
01:09:48,040 --> 01:09:56,500
it's really kind of like 27 and 27 mod

1099
01:09:52,839 --> 01:09:59,500
16 is sort of like or no this isn't 20

1100
01:09:56,500 --> 01:10:03,400
we changed our number right so this is

1101
01:09:59,500 --> 01:10:07,389
really kind of like 19 and 19 mod 16 is

1102
01:10:03,400 --> 01:10:11,110
3 and this is 3 so you can sort of do it

1103
01:10:07,389 --> 01:10:14,739
by coming back around to it but it's not

1104
01:10:11,110 --> 01:10:16,560
some arithmetic property that would jump

1105
01:10:14,739 --> 01:10:19,330
out at you as being something logical

1106
01:10:16,560 --> 01:10:22,870
but that happens all the time that and

1107
01:10:19,330 --> 01:10:25,120
it's very common for numbers to get

1108
01:10:22,870 --> 01:10:27,310
truncated for one reason or another and

1109
01:10:25,120 --> 01:10:30,100
you can see that you can have a negative

1110
01:10:27,310 --> 01:10:31,719
number become a positive number you can

1111
01:10:30,100 --> 01:10:33,850
have a positive number become a negative

1112
01:10:31,719 --> 01:10:37,570
number and all kinds of goofy stuff can

1113
01:10:33,850 --> 01:10:41,260
happen and we'll see funny examples of

1114
01:10:37,570 --> 01:10:46,989
that when we look at arithmetic so

1115
01:10:41,260 --> 01:10:49,239
that's that is what I want to cover

1116
01:10:46,989 --> 01:10:53,260
today and we'll cover the other

1117
01:10:49,239 --> 01:10:55,710
arithmetic operation on Tuesday so thank

1118
01:10:53,260 --> 01:10:55,710
you very much

