1
00:00:00,030 --> 00:00:08,250
okay so continuing on with the saga of

2
00:00:05,430 --> 00:00:12,389
machine level programming when number

3
00:00:08,250 --> 00:00:14,519
four of our series of this and I think

4
00:00:12,389 --> 00:00:18,150
that the total will be five so we're

5
00:00:14,519 --> 00:00:19,859
almost through and as always this is a

6
00:00:18,150 --> 00:00:21,570
lot of material for the course that's

7
00:00:19,859 --> 00:00:24,539
essentially a third of the course if you

8
00:00:21,570 --> 00:00:27,869
think about well no not that much but

9
00:00:24,539 --> 00:00:30,840
it's a lot of the course and part that

10
00:00:27,869 --> 00:00:33,450
we consider very central to it so a lot

11
00:00:30,840 --> 00:00:36,380
of this involves since we're talking

12
00:00:33,450 --> 00:00:39,840
about a particular machine the Intel x86

13
00:00:36,380 --> 00:00:42,660
64 machines a lot of its kind of

14
00:00:39,840 --> 00:00:45,570
low-level nitty gritty stuff but part of

15
00:00:42,660 --> 00:00:47,460
what we hope you also are understanding

16
00:00:45,570 --> 00:00:49,649
some of the general principles involved

17
00:00:47,460 --> 00:00:53,940
too and you'll find if you move from

18
00:00:49,649 --> 00:00:55,559
this machine to another machine sort of

19
00:00:53,940 --> 00:00:57,629
learning your first assembly languages

20
00:00:55,559 --> 00:01:02,250
your hardest one learning successive

21
00:00:57,629 --> 00:01:04,589
ones a lot easier so today we're going

22
00:01:02,250 --> 00:01:06,869
to talk about data representations we've

23
00:01:04,589 --> 00:01:11,670
so far all the programs we've looked at

24
00:01:06,869 --> 00:01:14,250
have been either just manipulating

25
00:01:11,670 --> 00:01:16,350
integers or long integers and pointers

26
00:01:14,250 --> 00:01:19,229
so that's all what we'd call scalar data

27
00:01:16,350 --> 00:01:22,920
data that's not in any aggregated form

28
00:01:19,229 --> 00:01:25,320
today we'll look at places where data

29
00:01:22,920 --> 00:01:27,570
gets collected into you put together

30
00:01:25,320 --> 00:01:29,790
multiple data elements and then see

31
00:01:27,570 --> 00:01:34,110
there's really two ways to do that one

32
00:01:29,790 --> 00:01:37,049
is with arrays where you can create many

33
00:01:34,110 --> 00:01:38,970
copies or many copies of an identical

34
00:01:37,049 --> 00:01:43,259
data types you can have an array of int

35
00:01:38,970 --> 00:01:47,149
and array of pointers a second is where

36
00:01:43,259 --> 00:01:49,860
you have struck so you create a small

37
00:01:47,149 --> 00:01:52,170
collection of values that can be of

38
00:01:49,860 --> 00:01:57,210
different data types and each one you

39
00:01:52,170 --> 00:01:59,790
access by its name or a tag and it turns

40
00:01:57,210 --> 00:02:01,680
out those definitions can be recursive

41
00:01:59,790 --> 00:02:04,950
so you can have arrays of structs and

42
00:02:01,680 --> 00:02:07,170
structs with arrays and nested it to an

43
00:02:04,950 --> 00:02:09,720
arbitrary degree

44
00:02:07,170 --> 00:02:11,640
and what we'll see is both how its

45
00:02:09,720 --> 00:02:13,710
represented in the machine memory and

46
00:02:11,640 --> 00:02:16,140
also then what the code looks like that

47
00:02:13,710 --> 00:02:18,660
will manipulate these different data

48
00:02:16,140 --> 00:02:24,210
structures and the main thing to see is

49
00:02:18,660 --> 00:02:26,930
that there's no the at the machine code

50
00:02:24,210 --> 00:02:29,850
level there is no notion of an array

51
00:02:26,930 --> 00:02:33,090
that you'd have at a high level except

52
00:02:29,850 --> 00:02:36,480
to think of it as a collection of bytes

53
00:02:33,090 --> 00:02:39,410
that you can are in contiguous part of

54
00:02:36,480 --> 00:02:41,790
storage and same with a struct is just

55
00:02:39,410 --> 00:02:44,250
allocated as a collection of bytes and

56
00:02:41,790 --> 00:02:45,900
it's the job of the C compiler then to

57
00:02:44,250 --> 00:02:51,150
generate the appropriate code to

58
00:02:45,900 --> 00:02:53,310
allocate that memory to get the right

59
00:02:51,150 --> 00:02:57,090
value when you refer to some element of

60
00:02:53,310 --> 00:03:01,550
a struct or in a read but the good news

61
00:02:57,090 --> 00:03:01,550
is this is such a commonplace type of

62
00:03:01,940 --> 00:03:06,900
requirement for a programming language

63
00:03:03,810 --> 00:03:09,420
that the Machine gives you sort of

64
00:03:06,900 --> 00:03:11,130
instructions that you'll see now they

65
00:03:09,420 --> 00:03:13,050
make perfect sense they're exactly

66
00:03:11,130 --> 00:03:17,540
designed for this particular class of

67
00:03:13,050 --> 00:03:20,489
applications so we'll talk about

68
00:03:17,540 --> 00:03:23,010
structure A's first and then structures

69
00:03:20,489 --> 00:03:24,810
who struck and I'll also mention we'll

70
00:03:23,010 --> 00:03:26,870
do a little bit I'll give you a glimpse

71
00:03:24,810 --> 00:03:29,340
of floating point today too because it's

72
00:03:26,870 --> 00:03:31,019
it's worth knowing how floating point

73
00:03:29,340 --> 00:03:34,080
arithmetic is implemented as well on a

74
00:03:31,019 --> 00:03:36,900
machine so the basic idea of array

75
00:03:34,080 --> 00:03:40,140
allocation is fairly straightforward if

76
00:03:36,900 --> 00:03:45,000
you have n an array with n elements then

77
00:03:40,140 --> 00:03:49,620
that's represented by enough bytes in

78
00:03:45,000 --> 00:03:52,560
memory all in one span to hold that much

79
00:03:49,620 --> 00:03:56,340
data so if the underlying data type say

80
00:03:52,560 --> 00:04:00,420
it's an int or a care is a single byte

81
00:03:56,340 --> 00:04:03,900
of data type so to have a array of 12

82
00:04:00,420 --> 00:04:06,870
cares takes 12 bytes and int takes four

83
00:04:03,900 --> 00:04:09,930
bytes so to have an array of five int

84
00:04:06,870 --> 00:04:12,060
take 20 bytes you get the idea you just

85
00:04:09,930 --> 00:04:14,040
multiply the size the underlying data

86
00:04:12,060 --> 00:04:16,049
type by the number of elements and

87
00:04:14,040 --> 00:04:17,400
that's how big the array has to be in

88
00:04:16,049 --> 00:04:21,060
terms of bytes

89
00:04:17,400 --> 00:04:24,449
and we've already seen that in the care

90
00:04:21,060 --> 00:04:26,940
is one bite and it is for a double or a

91
00:04:24,449 --> 00:04:30,750
long would be eight bytes and so would

92
00:04:26,940 --> 00:04:33,389
be a pointer so those are all different

93
00:04:30,750 --> 00:04:38,220
amounts of storage and you see in this

94
00:04:33,389 --> 00:04:40,139
diagram we use the X denote the starting

95
00:04:38,220 --> 00:04:45,120
address of the beginning of this region

96
00:04:40,139 --> 00:04:51,300
of memory and so we can use address

97
00:04:45,120 --> 00:04:53,310
computation to compute offset by adding

98
00:04:51,300 --> 00:04:55,500
numbers to X to get the address in

99
00:04:53,310 --> 00:05:00,300
particulars of this array and that's

100
00:04:55,500 --> 00:05:04,050
exactly what the code does so in general

101
00:05:00,300 --> 00:05:06,630
then if you imagine array a has some

102
00:05:04,050 --> 00:05:08,699
underlying type T what the elements of

103
00:05:06,630 --> 00:05:10,229
the array are and some number of

104
00:05:08,699 --> 00:05:17,580
elements in that array in the

105
00:05:10,229 --> 00:05:20,210
declaration L then we will that

106
00:05:17,580 --> 00:05:23,039
declaration actually does two things

107
00:05:20,210 --> 00:05:26,610
one is it allocates enough bytes of

108
00:05:23,039 --> 00:05:27,870
storage to hold the entire array and the

109
00:05:26,610 --> 00:05:31,289
second from a programming language

110
00:05:27,870 --> 00:05:33,990
perspective it is the identifier of the

111
00:05:31,289 --> 00:05:35,970
array a can in some ways be treated like

112
00:05:33,990 --> 00:05:37,889
a pointer that you can do pointer

113
00:05:35,970 --> 00:05:41,820
arithmetic off of it and that's one of

114
00:05:37,889 --> 00:05:44,699
the features of C that is was a fairly

115
00:05:41,820 --> 00:05:47,280
unique to see when it was created and is

116
00:05:44,699 --> 00:05:48,780
still unique to this day this idea of

117
00:05:47,280 --> 00:05:54,389
the sort of interchangeability of

118
00:05:48,780 --> 00:05:57,000
pointers and arrays array identifiers so

119
00:05:54,389 --> 00:06:00,690
for example I can use an array notation

120
00:05:57,000 --> 00:06:02,940
to say Val of four is element four of

121
00:06:00,690 --> 00:06:06,680
this array and it's a five element array

122
00:06:02,940 --> 00:06:11,520
so that would just be this final element

123
00:06:06,680 --> 00:06:14,849
but I can also just refer to Val and its

124
00:06:11,520 --> 00:06:18,270
underlying data type is as an int star

125
00:06:14,849 --> 00:06:21,270
so pointer to imp and its value would be

126
00:06:18,270 --> 00:06:23,550
X it's just a pointer a pointer is

127
00:06:21,270 --> 00:06:24,930
remember an address and it's just the

128
00:06:23,550 --> 00:06:29,099
address at the beginning of the array

129
00:06:24,930 --> 00:06:31,480
and I can do pointer arithmetic on Val

130
00:06:29,099 --> 00:06:34,690
which as you know in

131
00:06:31,480 --> 00:06:36,370
II and this is a little confusing we'll

132
00:06:34,690 --> 00:06:40,270
have to we'll go back and forth because

133
00:06:36,370 --> 00:06:43,420
in C when you do pointer arithmetic like

134
00:06:40,270 --> 00:06:49,180
you say you know P plus pause for a

135
00:06:43,420 --> 00:06:51,610
pointer we just give you an example so

136
00:06:49,180 --> 00:06:55,270
if you had something like care star P as

137
00:06:51,610 --> 00:06:59,890
a declaration and you said P is equal to

138
00:06:55,270 --> 00:07:04,770
some string s and then you say P plus

139
00:06:59,890 --> 00:07:04,770
plus so you're incrementing that pointer

140
00:07:05,820 --> 00:07:10,240
one in this case you're incrementing it

141
00:07:08,290 --> 00:07:17,800
by one because the underlying data type

142
00:07:10,240 --> 00:07:24,660
is a is a care but if you said something

143
00:07:17,800 --> 00:07:27,900
like in star or caught IP and I

144
00:07:24,660 --> 00:07:27,900
different pen

145
00:07:35,940 --> 00:07:48,440
and I said you know IP plus plus then IP

146
00:07:43,830 --> 00:07:56,250
would get IP plus what does anyone know

147
00:07:48,440 --> 00:07:58,590
for yes so it's a confusion and see this

148
00:07:56,250 --> 00:08:02,490
remember is the same as saying IP plus

149
00:07:58,590 --> 00:08:05,520
equals 1 but what you're actually doing

150
00:08:02,490 --> 00:08:10,230
is incrementing that the number of the

151
00:08:05,520 --> 00:08:13,020
value of P by 4 because you want a

152
00:08:10,230 --> 00:08:16,170
pointer when you jump from one place to

153
00:08:13,020 --> 00:08:18,180
another you want it to increment by

154
00:08:16,170 --> 00:08:26,400
enough bytes to point to the next

155
00:08:18,180 --> 00:08:31,860
integer in this case for IP and so

156
00:08:26,400 --> 00:08:36,810
similarly valve s 1 denotes this value X

157
00:08:31,860 --> 00:08:41,340
plus 4 because it's a the address of the

158
00:08:36,810 --> 00:08:43,800
next integer in the array by the way the

159
00:08:41,340 --> 00:08:46,920
one thing different between an array and

160
00:08:43,800 --> 00:08:49,590
a pointer is I can't say Val plus plus

161
00:08:46,920 --> 00:08:52,650
right I can't change the value of valid

162
00:08:49,590 --> 00:08:55,920
fixed by the declaration whereas a

163
00:08:52,650 --> 00:08:58,380
pointer I can increment it I can change

164
00:08:55,920 --> 00:09:03,920
it in various ways and similarly

165
00:08:58,380 --> 00:09:06,720
ampersand L of 2 says give me the

166
00:09:03,920 --> 00:09:10,880
address of the second element of the

167
00:09:06,720 --> 00:09:13,590
array so that would be at X plus 8 and

168
00:09:10,880 --> 00:09:18,260
this is again one of the fundamental

169
00:09:13,590 --> 00:09:18,260
properties of see that

170
00:09:22,970 --> 00:09:29,480
basically in NC if you take a pointer

171
00:09:37,750 --> 00:09:40,930
that's rude

172
00:09:43,240 --> 00:09:51,680
this is an eye not very well written

173
00:09:45,680 --> 00:09:53,690
these are equivalent statement right

174
00:09:51,680 --> 00:09:54,170
there just two notations for the same

175
00:09:53,690 --> 00:09:57,500
thing

176
00:09:54,170 --> 00:10:03,460
so on the upper part it says IP plus two

177
00:09:57,500 --> 00:10:06,050
meaning actually add 8 to I pee and then

178
00:10:03,460 --> 00:10:08,720
dereference that it's the same as

179
00:10:06,050 --> 00:10:13,430
finding the second element of array an

180
00:10:08,720 --> 00:10:15,620
imaginary array of where IP is indicates

181
00:10:13,430 --> 00:10:18,050
the beginning of the array so that's a

182
00:10:15,620 --> 00:10:20,030
very fundamental principle of see that

183
00:10:18,050 --> 00:10:22,220
again this whole idea of pointer

184
00:10:20,030 --> 00:10:27,110
arithmetic is fairly unique to see

185
00:10:22,220 --> 00:10:32,390
question yes

186
00:10:27,110 --> 00:10:36,860
the compiler will happily let you use

187
00:10:32,390 --> 00:10:39,590
negative values for array indices and it

188
00:10:36,860 --> 00:10:43,130
will give you a potentially undefined

189
00:10:39,590 --> 00:10:45,170
value but there's nothing in C that

190
00:10:43,130 --> 00:10:47,390
prevents you from giving out of bounds

191
00:10:45,170 --> 00:10:49,310
either numbers that are too big for an

192
00:10:47,390 --> 00:10:54,350
array or too small for an array there's

193
00:10:49,310 --> 00:10:57,670
no bounds checking it yes if we have

194
00:10:54,350 --> 00:11:00,640
some fun Megan and disaster

195
00:10:57,670 --> 00:11:03,940
yes the question that's becoming what

196
00:11:00,640 --> 00:11:07,990
about negative indices and the answer is

197
00:11:03,940 --> 00:11:16,600
very simple because in other words in

198
00:11:07,990 --> 00:11:18,190
general something like IP plus X maybe

199
00:11:16,600 --> 00:11:25,300
there can you see it

200
00:11:18,190 --> 00:11:33,090
should I try to kind of break is really

201
00:11:25,300 --> 00:11:33,090
equivalent to I T plus 4x

202
00:11:34,589 --> 00:11:46,690
so this is the notation and until in our

203
00:11:44,620 --> 00:11:50,320
derivative you and the right-hand side

204
00:11:46,690 --> 00:11:53,380
is the computation so you and see you

205
00:11:50,320 --> 00:11:55,209
write it using you don't have to give

206
00:11:53,380 --> 00:11:56,529
scaling factors to your data types

207
00:11:55,209 --> 00:11:58,380
otherwise it would drive you out of your

208
00:11:56,529 --> 00:12:02,290
mind

209
00:11:58,380 --> 00:12:04,149
but you secretly underneath when the

210
00:12:02,290 --> 00:12:06,850
compiler generates the code we'll see

211
00:12:04,149 --> 00:12:09,670
examples of this it's scaling everything

212
00:12:06,850 --> 00:12:11,410
so now the question that is being asked

213
00:12:09,670 --> 00:12:14,080
is what if X is a negative number

214
00:12:11,410 --> 00:12:16,330
well the rule still applies it's just

215
00:12:14,080 --> 00:12:19,600
that the final result will be less than

216
00:12:16,330 --> 00:12:22,209
IP instead of greater than IP but it's

217
00:12:19,600 --> 00:12:24,370
totally valid C and there's actually

218
00:12:22,209 --> 00:12:32,350
times you will use it in this term I can

219
00:12:24,370 --> 00:12:36,580
promise you yes question how do you know

220
00:12:32,350 --> 00:12:38,880
you can't write to plus IP try it

221
00:12:36,580 --> 00:12:42,910
I'm pretty sure you can't do that in

222
00:12:38,880 --> 00:12:44,529
with pointer arithmetic try if somebody

223
00:12:42,910 --> 00:12:46,900
wants to type in some code and do it I

224
00:12:44,529 --> 00:12:48,700
don't think you can do that but if you

225
00:12:46,900 --> 00:12:51,040
did it would have to figure it out that

226
00:12:48,700 --> 00:12:54,040
you know the parser knows the datatypes

227
00:12:51,040 --> 00:12:56,080
of its two arguments so yeah you could

228
00:12:54,040 --> 00:12:57,550
probably do it I've never seen this you

229
00:12:56,080 --> 00:12:59,470
could do it but the compiler would know

230
00:12:57,550 --> 00:13:01,810
that one of the arguments is a pointer

231
00:12:59,470 --> 00:13:05,230
and therefore scale the other what you

232
00:13:01,810 --> 00:13:08,230
can't do is add two pointers you can

233
00:13:05,230 --> 00:13:09,700
take the difference to two pointers this

234
00:13:08,230 --> 00:13:13,390
is obscure I'm not even going to tell

235
00:13:09,700 --> 00:13:15,790
you about this hook it up in knr but you

236
00:13:13,390 --> 00:13:17,680
can do arithmetic but you can only for

237
00:13:15,790 --> 00:13:19,779
addition it can only be one pointer and

238
00:13:17,680 --> 00:13:22,360
one and then the other has to be a

239
00:13:19,779 --> 00:13:24,790
regular integer value and it will scale

240
00:13:22,360 --> 00:13:27,880
it appropriately so I believe you can do

241
00:13:24,790 --> 00:13:29,380
it it's just somebody will smack you on

242
00:13:27,880 --> 00:13:33,450
the back of the hand if you actually

243
00:13:29,380 --> 00:13:38,529
write code enough but not the compiler

244
00:13:33,450 --> 00:13:41,980
so in particular you know you can if you

245
00:13:38,529 --> 00:13:44,500
go beyond the bounds of an array of this

246
00:13:41,980 --> 00:13:45,900
you'll get whatever is beyond the bounds

247
00:13:44,500 --> 00:13:48,029
of that array

248
00:13:45,900 --> 00:13:50,310
and it might be an invalid or it might

249
00:13:48,029 --> 00:13:52,320
not even be a valid address and you get

250
00:13:50,310 --> 00:13:56,580
a segmentation fault but more typically

251
00:13:52,320 --> 00:13:59,550
you'll get some whatever it happens to

252
00:13:56,580 --> 00:14:00,900
be there and that's not so bad when you

253
00:13:59,550 --> 00:14:03,750
read it but you can also potentially

254
00:14:00,900 --> 00:14:07,260
write it as we saw before and corrupt

255
00:14:03,750 --> 00:14:09,180
data that's already in memory so here's

256
00:14:07,260 --> 00:14:13,950
again the same statement I was making

257
00:14:09,180 --> 00:14:16,170
before that IP valve plus I just get

258
00:14:13,950 --> 00:14:18,029
scaled the value computed would be the

259
00:14:16,170 --> 00:14:20,779
starting address plus four times

260
00:14:18,029 --> 00:14:20,779
whatever eyes

261
00:14:23,910 --> 00:14:29,860
so let's look at so that's sort of

262
00:14:27,520 --> 00:14:33,580
that's all see everything I said before

263
00:14:29,860 --> 00:14:35,380
is just basic see stuff now let's start

264
00:14:33,580 --> 00:14:38,650
looking at the actual machine code

265
00:14:35,380 --> 00:14:44,320
involved and so I made up this example

266
00:14:38,650 --> 00:14:47,890
here where I declare three arrays each

267
00:14:44,320 --> 00:14:50,400
with five in and I go through what is

268
00:14:47,890 --> 00:14:54,070
considered sort of good form when you're

269
00:14:50,400 --> 00:14:56,080
building up data that instead of having

270
00:14:54,070 --> 00:14:58,930
arbitrary constants sprinkled through

271
00:14:56,080 --> 00:15:02,080
your program often called magic numbers

272
00:14:58,930 --> 00:15:03,880
that you instead use a pound define and

273
00:15:02,080 --> 00:15:07,030
you give it some meaningful name and

274
00:15:03,880 --> 00:15:10,360
some documentation usually at the top of

275
00:15:07,030 --> 00:15:12,550
a file or in a dot H file and then the

276
00:15:10,360 --> 00:15:14,860
type def is a very handy way if you're

277
00:15:12,550 --> 00:15:17,410
going to create complex data structures

278
00:15:14,860 --> 00:15:20,580
I highly recommend you sort of break

279
00:15:17,410 --> 00:15:23,260
that into type deaths because the

280
00:15:20,580 --> 00:15:25,690
declaration notation in C gets fairly

281
00:15:23,260 --> 00:15:29,500
obscure fairly quickly but all this is

282
00:15:25,690 --> 00:15:33,670
saying is the the data type I'm going to

283
00:15:29,500 --> 00:15:36,910
call a zip didge is defined to be five

284
00:15:33,670 --> 00:15:40,240
an array of five int and now whenever I

285
00:15:36,910 --> 00:15:42,370
say zip did something I'm just popping

286
00:15:40,240 --> 00:15:47,050
down I'm saying this is an array of five

287
00:15:42,370 --> 00:15:48,790
int and so I created three of them with

288
00:15:47,050 --> 00:15:53,230
the appropriate depth codes for the

289
00:15:48,790 --> 00:15:56,940
schools represented here and now I'm

290
00:15:53,230 --> 00:16:00,280
just making up for sake of presentation

291
00:15:56,940 --> 00:16:02,320
actual addresses for these in general

292
00:16:00,280 --> 00:16:05,320
you don't have any control over that and

293
00:16:02,320 --> 00:16:07,240
I made it up so that they all happen to

294
00:16:05,320 --> 00:16:09,790
be in contiguous part of memory and

295
00:16:07,240 --> 00:16:11,680
again there's no fundamental reason that

296
00:16:09,790 --> 00:16:14,230
should be true so you can never trust

297
00:16:11,680 --> 00:16:16,480
what particular address anything is ever

298
00:16:14,230 --> 00:16:18,580
going to be allocated at but you are

299
00:16:16,480 --> 00:16:22,860
certain that each of these blocks will

300
00:16:18,580 --> 00:16:22,860
be a contiguous collection of 20 bytes

301
00:16:23,350 --> 00:16:30,670
so here's some example code then to say

302
00:16:27,700 --> 00:16:34,890
I want to retrieve for one of these

303
00:16:30,670 --> 00:16:38,890
arrays I want to retrieve a element

304
00:16:34,890 --> 00:16:40,920
whose index is digit and this gets

305
00:16:38,890 --> 00:16:43,270
turned into the following code so

306
00:16:40,920 --> 00:16:46,180
remember the first argument which will

307
00:16:43,270 --> 00:16:49,540
be a pointer now will be passed in

308
00:16:46,180 --> 00:16:51,820
register RDI and the second will it will

309
00:16:49,540 --> 00:16:55,330
be an INT will be passed and register

310
00:16:51,820 --> 00:16:59,020
RSI and what I want to get out of this

311
00:16:55,330 --> 00:17:01,870
is an int and so you see that it here's

312
00:16:59,020 --> 00:17:04,170
where that scaled addressing this is

313
00:17:01,870 --> 00:17:06,820
exactly what it was designed for and why

314
00:17:04,170 --> 00:17:10,660
why they went to the trouble of adding

315
00:17:06,820 --> 00:17:13,320
the sort of fancy address modes to x86

316
00:17:10,660 --> 00:17:16,060
because this is such a common thing so

317
00:17:13,320 --> 00:17:18,579
remember what this says is take RDI

318
00:17:16,060 --> 00:17:22,000
and add to it what you get by

319
00:17:18,579 --> 00:17:24,670
multiplying RSI by four so you scale

320
00:17:22,000 --> 00:17:26,800
that and of course that's exactly the

321
00:17:24,670 --> 00:17:30,250
computation we want to do if we compare

322
00:17:26,800 --> 00:17:37,330
it to you know what this is what we're

323
00:17:30,250 --> 00:17:44,470
trying to get computed it's exactly it's

324
00:17:37,330 --> 00:17:46,000
exactly this computation here and that

325
00:17:44,470 --> 00:17:49,000
gives us an address and then we're

326
00:17:46,000 --> 00:17:51,670
reading from that address and we're

327
00:17:49,000 --> 00:17:53,830
going to copy it in EAX remember this is

328
00:17:51,670 --> 00:17:58,180
an in total be in the e-version the

329
00:17:53,830 --> 00:17:59,890
lower 4 bytes of register raf and that's

330
00:17:58,180 --> 00:18:03,070
all the code it takes to implement this

331
00:17:59,890 --> 00:18:08,740
particular operation yes RDI is the base

332
00:18:03,070 --> 00:18:10,040
address all right yeah and I on the

333
00:18:08,740 --> 00:18:13,850
right side

334
00:18:10,040 --> 00:18:17,260
yeah this is a typo thank you thanks for

335
00:18:13,850 --> 00:18:21,200
pointing it out I'll make a note of that

336
00:18:17,260 --> 00:18:24,170
right so this slide is incorrect and

337
00:18:21,200 --> 00:18:29,810
I'll fix it so this should be our di

338
00:18:24,170 --> 00:18:32,740
plus for RSI right thanks for noting

339
00:18:29,810 --> 00:18:32,740
that let me make it

340
00:18:36,470 --> 00:18:51,620
okay and so now let's just look at a

341
00:18:43,970 --> 00:18:53,540
another distant code in particular what

342
00:18:51,620 --> 00:18:56,480
if I wanted to go through one of these

343
00:18:53,540 --> 00:18:58,700
arrays and for every element of the

344
00:18:56,480 --> 00:19:01,640
array add one to it so increment every

345
00:18:58,700 --> 00:19:03,380
single element by one well first of all

346
00:19:01,640 --> 00:19:06,370
you can see that we're setting up a loop

347
00:19:03,380 --> 00:19:10,730
and it uses the jump to middle of

348
00:19:06,370 --> 00:19:13,370
business where the initial part is to

349
00:19:10,730 --> 00:19:18,290
jump to the test and all the testing

350
00:19:13,370 --> 00:19:20,630
involves were increasing our a X's for I

351
00:19:18,290 --> 00:19:28,570
here and we're incrementing it and

352
00:19:20,630 --> 00:19:32,720
comparing it at various places but um

353
00:19:28,570 --> 00:19:37,640
here's the the line of code that does

354
00:19:32,720 --> 00:19:41,870
all the real work again it's taking the

355
00:19:37,640 --> 00:19:45,590
ice element which is in our ax scaling

356
00:19:41,870 --> 00:19:48,410
by four adding it to the base of the

357
00:19:45,590 --> 00:19:51,200
array and that gives us an address and

358
00:19:48,410 --> 00:19:53,240
now remember you can have an an

359
00:19:51,200 --> 00:19:56,240
arithmetic instruction where the second

360
00:19:53,240 --> 00:19:58,190
operand the destination is a memory

361
00:19:56,240 --> 00:20:01,940
reference and what this actually

362
00:19:58,190 --> 00:20:06,050
requires is to first read the original

363
00:20:01,940 --> 00:20:08,150
value from the memory do the addition

364
00:20:06,050 --> 00:20:11,690
and then store the result back in memory

365
00:20:08,150 --> 00:20:14,480
so this one instruction is exactly

366
00:20:11,690 --> 00:20:18,760
encrypt doing this plus plus operation

367
00:20:14,480 --> 00:20:18,760
on this stored data in the array

368
00:20:21,360 --> 00:20:29,880
oh by the way I should mention the whole

369
00:20:25,980 --> 00:20:33,660
idea of pointer arithmetic and and si

370
00:20:29,880 --> 00:20:36,000
was a si was really people who'd

371
00:20:33,660 --> 00:20:38,760
programmed an assembly code for most of

372
00:20:36,000 --> 00:20:40,080
their lives thinking about how could I

373
00:20:38,760 --> 00:20:42,840
make this look like a high-level

374
00:20:40,080 --> 00:20:44,640
language but keep all the flexibility

375
00:20:42,840 --> 00:20:47,330
all the tricks I learned to play at

376
00:20:44,640 --> 00:20:49,110
assembly code in a programming language

377
00:20:47,330 --> 00:20:50,730
because it was designed it was

378
00:20:49,110 --> 00:20:52,230
originally designed to implement an

379
00:20:50,730 --> 00:20:55,620
operating system the UNIX operating

380
00:20:52,230 --> 00:20:56,970
system and historically operating

381
00:20:55,620 --> 00:21:00,210
systems were written directly in

382
00:20:56,970 --> 00:21:04,980
assembly code and these people Kernighan

383
00:21:00,210 --> 00:21:08,730
Ritchie Dennis Ritchie and realized that

384
00:21:04,980 --> 00:21:11,820
the way to do this is to sort of build

385
00:21:08,730 --> 00:21:15,300
point arithmetic into a programming

386
00:21:11,820 --> 00:21:18,350
language so anyways the reason I'm

387
00:21:15,300 --> 00:21:21,390
saying this is you see a pretty close

388
00:21:18,350 --> 00:21:24,870
correspondence here between instructions

389
00:21:21,390 --> 00:21:26,670
and machine code and constructs in a

390
00:21:24,870 --> 00:21:29,310
program in the C programming language

391
00:21:26,670 --> 00:21:31,710
and that whole plus plus operator and

392
00:21:29,310 --> 00:21:35,910
plus equals is sort of something you see

393
00:21:31,710 --> 00:21:38,100
variations of institutes and we code ok

394
00:21:35,910 --> 00:21:44,040
so that's a sort of single dimension

395
00:21:38,100 --> 00:21:51,240
array and I'd like to just change things

396
00:21:44,040 --> 00:21:55,140
up a little bit by having a look at what

397
00:21:51,240 --> 00:21:57,840
the real difference is between of arrays

398
00:21:55,140 --> 00:22:02,370
and pointers in a programming language

399
00:21:57,840 --> 00:22:06,140
in C and so I have a couple of these

400
00:22:02,370 --> 00:22:09,750
examples that I'll bring out one by one

401
00:22:06,140 --> 00:22:12,380
but the idea of this is you see the

402
00:22:09,750 --> 00:22:14,850
declaration on the Left there's

403
00:22:12,380 --> 00:22:19,800
something called a1 and something called

404
00:22:14,850 --> 00:22:24,450
a 2 so call those a sub m and now what I

405
00:22:19,800 --> 00:22:26,970
want to know for each of these is does

406
00:22:24,450 --> 00:22:30,390
it compile is this a valid statement in

407
00:22:26,970 --> 00:22:32,280
c ii with this potentially give me a

408
00:22:30,390 --> 00:22:34,560
null pointer reference because i'm

409
00:22:32,280 --> 00:22:38,150
referencing a pointer

410
00:22:34,560 --> 00:22:41,910
for which the I haven't actually

411
00:22:38,150 --> 00:22:44,220
allocated space for the that that

412
00:22:41,910 --> 00:22:46,500
pointer is indicated I haven't I haven't

413
00:22:44,220 --> 00:22:49,530
initialized the pointer to a valid

414
00:22:46,500 --> 00:22:52,470
memory reference and then finally if I

415
00:22:49,530 --> 00:23:00,450
were to use the sizeof operator on that

416
00:22:52,470 --> 00:23:02,220
particular value with that and including

417
00:23:00,450 --> 00:23:12,900
for the case where there's a star in

418
00:23:02,220 --> 00:23:14,250
front of it and a part of this is to

419
00:23:12,900 --> 00:23:17,100
understand the difference then between

420
00:23:14,250 --> 00:23:20,270
an array and a pointer and the main

421
00:23:17,100 --> 00:23:23,100
reason this the main factor is an array

422
00:23:20,270 --> 00:23:27,110
when you declare an array and see you're

423
00:23:23,100 --> 00:23:29,790
both you're actually allocating space

424
00:23:27,110 --> 00:23:33,300
the space is being allocated somewhere

425
00:23:29,790 --> 00:23:37,050
for it and you're creating a using

426
00:23:33,300 --> 00:23:40,080
allowed to now use the Ray name of in

427
00:23:37,050 --> 00:23:42,660
pointer arithmetic whereas when you just

428
00:23:40,080 --> 00:23:44,580
declare in a ret a pointer all you're

429
00:23:42,660 --> 00:23:46,950
allocating is the space for the pointer

430
00:23:44,580 --> 00:23:55,680
itself and not for anything that it's

431
00:23:46,950 --> 00:23:57,240
you're pointing to so just - you've

432
00:23:55,680 --> 00:23:59,870
probably figured out that these both

433
00:23:57,240 --> 00:23:59,870
compile

434
00:24:00,940 --> 00:24:12,609
let me get my chief chief Andy well but

435
00:24:04,539 --> 00:24:16,349
what would be the size of a one here if

436
00:24:12,609 --> 00:24:16,349
I ran the size of operator on

437
00:24:23,780 --> 00:24:35,330
let's do the easier one what's the size

438
00:24:26,280 --> 00:24:38,820
of a two eight because the pointer

439
00:24:35,330 --> 00:24:44,900
what's the size of a one a one is an

440
00:24:38,820 --> 00:24:44,900
array of three in 12 right

441
00:24:47,179 --> 00:24:53,440
oh and those those aren't no oops

442
00:24:55,330 --> 00:25:13,429
and now if I said star a one or start a

443
00:25:02,210 --> 00:25:15,429
- those would both compile could either

444
00:25:13,429 --> 00:25:26,989
of them possibly give you a null

445
00:25:15,429 --> 00:25:32,359
dereference oh yes the pointer itself is

446
00:25:26,989 --> 00:25:34,820
no but that the I haven't dereferenced

447
00:25:32,359 --> 00:25:37,869
it yet it's a null pointer but I haven't

448
00:25:34,820 --> 00:25:41,330
it's not a bad potentially bad reference

449
00:25:37,869 --> 00:25:43,969
right it's not a runtime I will create a

450
00:25:41,330 --> 00:25:46,729
runtime error if I just say a - in my

451
00:25:43,969 --> 00:25:49,609
code okay so your step ahead of me

452
00:25:46,729 --> 00:25:51,950
basically so in it you kind of answered

453
00:25:49,609 --> 00:25:54,589
the second question though this one

454
00:25:51,950 --> 00:25:56,089
could give you a null pointer error if

455
00:25:54,589 --> 00:25:58,519
you try to dereference a pointer that

456
00:25:56,089 --> 00:26:03,019
hasn't been initialized it doesn't point

457
00:25:58,519 --> 00:26:07,929
to anything whereas this one is fine and

458
00:26:03,019 --> 00:26:15,070
now what's the size of a one of star a

459
00:26:07,929 --> 00:26:18,259
1/4 and what about star a 2/4 yeah

460
00:26:15,070 --> 00:26:20,539
because they're both pointers to ends so

461
00:26:18,259 --> 00:26:24,759
one way to think about that is as a

462
00:26:20,539 --> 00:26:24,759
picture a one

463
00:26:26,940 --> 00:26:35,529
is like we've been showing here it's an

464
00:26:30,970 --> 00:26:39,609
array of of for intz and when I declare

465
00:26:35,529 --> 00:26:42,669
a one I'm allocating all so the program

466
00:26:39,609 --> 00:26:46,090
is allocating 12 bytes of storage that's

467
00:26:42,669 --> 00:26:54,720
able to hold that a 2 on the other hand

468
00:26:46,090 --> 00:26:57,789
is just a pointer which I'll show there

469
00:26:54,720 --> 00:27:00,489
until it's 8 bytes long but it doesn't

470
00:26:57,789 --> 00:27:04,359
point to anything so that's what I meant

471
00:27:00,489 --> 00:27:05,649
that if you tried to say star a 2 you

472
00:27:04,359 --> 00:27:09,609
potentially have a null pointer

473
00:27:05,649 --> 00:27:13,179
reference dereference out there and so

474
00:27:09,609 --> 00:27:15,100
that's why this is 8 and this is 12 so

475
00:27:13,179 --> 00:27:17,639
those are the warm-up 1 let's make it a

476
00:27:15,100 --> 00:27:17,639
little more interesting

477
00:27:27,340 --> 00:27:31,880
these aren't in the slides you'll notice

478
00:27:29,960 --> 00:27:37,850
but I'm going to I'll update the slides

479
00:27:31,880 --> 00:27:40,610
to include these later I'll but I think

480
00:27:37,850 --> 00:27:43,790
the point that if you find this

481
00:27:40,610 --> 00:27:46,580
confusing it's a sign that you really

482
00:27:43,790 --> 00:27:50,480
really really need to understand what a

483
00:27:46,580 --> 00:27:51,830
pointer is and what an array is and how

484
00:27:50,480 --> 00:27:56,210
they're the same and how they're

485
00:27:51,830 --> 00:27:58,700
different because it's it's a it's a

486
00:27:56,210 --> 00:28:01,429
core part of programming and see that

487
00:27:58,700 --> 00:28:03,140
will lead to endless hours of confusion

488
00:28:01,429 --> 00:28:09,380
if you don't really have this wired down

489
00:28:03,140 --> 00:28:11,809
pretty strongly so let me just give you

490
00:28:09,380 --> 00:28:13,520
a preview of what's so interesting about

491
00:28:11,809 --> 00:28:16,070
this is I'm going to give you some

492
00:28:13,520 --> 00:28:20,020
numbers and then we're going to have to

493
00:28:16,070 --> 00:28:20,020
explain how those numbers come around

494
00:28:31,270 --> 00:28:40,700
okay so let's try and understand what's

495
00:28:38,510 --> 00:28:42,559
happening here and you see that all of

496
00:28:40,700 --> 00:28:45,800
these declarations involve some

497
00:28:42,559 --> 00:28:48,260
combination of pointer and array and the

498
00:28:45,800 --> 00:28:54,170
question is is it a pointer to an array

499
00:28:48,260 --> 00:28:56,450
is it an array of pointers and the

500
00:28:54,170 --> 00:28:59,150
answer to those will depend on the

501
00:28:56,450 --> 00:29:01,160
particular syntax so of course the first

502
00:28:59,150 --> 00:29:05,450
one is one you've already seen before

503
00:29:01,160 --> 00:29:07,850
and so you know that compiles and it's

504
00:29:05,450 --> 00:29:11,120
not know and you can dereference it and

505
00:29:07,850 --> 00:29:16,070
it's not null but if you try to say star

506
00:29:11,120 --> 00:29:18,290
star a one that's not valid it won't

507
00:29:16,070 --> 00:29:23,150
even compile because you're trying to

508
00:29:18,290 --> 00:29:25,130
here take the data type of star a and is

509
00:29:23,150 --> 00:29:28,850
int and then you're trying to take a

510
00:29:25,130 --> 00:29:32,830
dereference an int so that will compile

511
00:29:28,850 --> 00:29:36,050
and therefore you can't even test it

512
00:29:32,830 --> 00:29:41,330
okay the question is for these other

513
00:29:36,050 --> 00:29:45,370
three you can see that somehow one is a

514
00:29:41,330 --> 00:29:50,690
well let's look at the bottom two first

515
00:29:45,370 --> 00:29:52,550
so the one on the bottom says that and

516
00:29:50,690 --> 00:29:54,320
this is part of and there's actually a

517
00:29:52,550 --> 00:29:56,240
really great section in Kernighan

518
00:29:54,320 --> 00:29:58,940
Ritchie that I highly encourage you

519
00:29:56,240 --> 00:30:01,490
which is how to read pointers how to

520
00:29:58,940 --> 00:30:03,650
read declarations and see and the basic

521
00:30:01,490 --> 00:30:06,950
rule is you start from the inside and

522
00:30:03,650 --> 00:30:13,510
you work your way outward so that

523
00:30:06,950 --> 00:30:13,510
declaration of of a3 says that

524
00:30:15,480 --> 00:30:22,130
with that parentheses says a three is a

525
00:30:24,289 --> 00:30:27,860
what is victory

526
00:30:30,140 --> 00:30:32,200
you

527
00:30:32,450 --> 00:30:38,480
a three is a pointer that to parentheses

528
00:30:37,010 --> 00:30:41,690
around it

529
00:30:38,480 --> 00:30:43,690
what does it point to it points to an

530
00:30:41,690 --> 00:30:55,490
array of three inch

531
00:30:43,690 --> 00:31:03,520
okay so we can diagram a three then to

532
00:30:55,490 --> 00:31:03,520
be something like this

533
00:31:11,540 --> 00:31:16,950
a three is a pointer like I said read it

534
00:31:16,110 --> 00:31:21,900
from the inside out

535
00:31:16,950 --> 00:31:24,330
a three as a pointer and what does it

536
00:31:21,900 --> 00:31:26,790
point to it points to an array of three

537
00:31:24,330 --> 00:31:31,470
elements and what type of elements are

538
00:31:26,790 --> 00:31:34,200
they there in so you're sort of reading

539
00:31:31,470 --> 00:31:35,850
outward and picking up pizzas from the

540
00:31:34,200 --> 00:31:39,570
right and from the left as you do this

541
00:31:35,850 --> 00:31:43,440
and so when you know that this all makes

542
00:31:39,570 --> 00:31:47,190
sense that these numbers the size of a3

543
00:31:43,440 --> 00:31:51,120
itself is eight but since it points to

544
00:31:47,190 --> 00:31:57,060
an array of three in the size of star a

545
00:31:51,120 --> 00:31:59,700
three is twelve and then star star a

546
00:31:57,060 --> 00:32:02,310
three would indicate this particular

547
00:31:59,700 --> 00:32:06,750
element of the array and so it sizes

548
00:32:02,310 --> 00:32:08,580
four so these all compile but which of

549
00:32:06,750 --> 00:32:13,370
them could cause a null pointer

550
00:32:08,580 --> 00:32:13,370
dereferences which of the left two

551
00:32:16,870 --> 00:32:29,049
yes you can flip coin yes well I'm only

552
00:32:27,700 --> 00:32:33,220
looking at it I'm trying to fill in a

553
00:32:29,049 --> 00:32:35,320
three right now so a three is fine but

554
00:32:33,220 --> 00:32:43,169
if I said star a three could that have a

555
00:32:35,320 --> 00:32:46,330
null pointer of problem yes why because

556
00:32:43,169 --> 00:32:48,820
when I declare a three here all I'm

557
00:32:46,330 --> 00:32:50,500
declaring is this particular I'm only

558
00:32:48,820 --> 00:32:53,409
allocating enough storage for that

559
00:32:50,500 --> 00:32:55,240
pointer I have an initial lot I haven't

560
00:32:53,409 --> 00:32:57,250
allocated the space for an array I

561
00:32:55,240 --> 00:32:59,620
haven't initialized a three to actually

562
00:32:57,250 --> 00:33:01,690
point to an array so it could be a null

563
00:32:59,620 --> 00:33:03,850
pointer it could be arbitrary junk but

564
00:33:01,690 --> 00:33:05,350
it the chances of it actually pointing

565
00:33:03,850 --> 00:33:09,100
to an array of three inches is highly

566
00:33:05,350 --> 00:33:11,830
unlikely so this would be a potentially

567
00:33:09,100 --> 00:33:16,539
bad and therefore double stars doubly

568
00:33:11,830 --> 00:33:24,130
dead right okay so now let's look at a

569
00:33:16,539 --> 00:33:29,980
four so a four to understand that you

570
00:33:24,130 --> 00:33:33,940
actually have to look at the charts and

571
00:33:29,980 --> 00:33:35,980
see the precedent chart which if you're

572
00:33:33,940 --> 00:33:38,770
like me your book falls open to that

573
00:33:35,980 --> 00:33:41,770
precedence chart the different operators

574
00:33:38,770 --> 00:33:45,130
and what levels they are and one thing

575
00:33:41,770 --> 00:33:46,480
you'll see is that a level one of

576
00:33:45,130 --> 00:33:51,330
precedence the highest precedence

577
00:33:46,480 --> 00:33:56,169
include square brackets and level to

578
00:33:51,330 --> 00:34:00,039
include star in other words bracket is

579
00:33:56,169 --> 00:34:03,419
higher precedence and star so this

580
00:34:00,039 --> 00:34:08,640
particular statement here

581
00:34:03,419 --> 00:34:08,640
the binding is is actually like this

582
00:34:11,339 --> 00:34:22,599
it says that a four is an array of three

583
00:34:17,379 --> 00:34:35,399
elements and those elements are pointers

584
00:34:22,599 --> 00:34:41,740
and they point to in high so a four is

585
00:34:35,399 --> 00:34:48,790
an array can you see this but each of

586
00:34:41,740 --> 00:34:52,349
those elements is pointing to an INT

587
00:34:48,790 --> 00:34:52,349
somewhere hopefully

588
00:34:54,460 --> 00:35:00,190
and so what the fat matches the numbers

589
00:34:57,069 --> 00:35:02,250
we got so the size of a four is twenty

590
00:35:00,190 --> 00:35:07,690
four because it's eight times three

591
00:35:02,250 --> 00:35:13,210
if I were to dereference a four it would

592
00:35:07,690 --> 00:35:16,660
just indicate this particular pointer

593
00:35:13,210 --> 00:35:20,260
right a four is an array of pointers so

594
00:35:16,660 --> 00:35:25,569
when I get an element out of that array

595
00:35:20,260 --> 00:35:28,859
what I'll get is a pointer and so of a

596
00:35:25,569 --> 00:35:31,950
four is a pointer and so it's also eight

597
00:35:28,859 --> 00:35:35,800
but if I now do a second dereference

598
00:35:31,950 --> 00:35:40,380
then I'll get an int and it's size is

599
00:35:35,800 --> 00:35:40,380
four okay

600
00:35:42,740 --> 00:35:56,670
these all compile so could I have a it

601
00:35:51,920 --> 00:36:01,280
could start a for them of cause problems

602
00:35:56,670 --> 00:36:01,280
as far as a null pointer or bed pointer

603
00:36:01,850 --> 00:36:12,600
no that's right no is the correct answer

604
00:36:07,290 --> 00:36:16,320
no is yes because you've a for this your

605
00:36:12,600 --> 00:36:20,520
a for is an array you've you've defined

606
00:36:16,320 --> 00:36:23,010
an array and it arrays get allocated by

607
00:36:20,520 --> 00:36:25,350
their declaration as a for LM a three

608
00:36:23,010 --> 00:36:28,590
element array on the other hand this

609
00:36:25,350 --> 00:36:30,270
could give you a null pointer because I

610
00:36:28,590 --> 00:36:34,590
haven't initialized the array to

611
00:36:30,270 --> 00:36:36,270
anything so for example if it were

612
00:36:34,590 --> 00:36:40,130
initialized to all zeros it would just

613
00:36:36,270 --> 00:36:44,580
be three no null pointers in that array

614
00:36:40,130 --> 00:36:50,370
so this is sort of that stuff the

615
00:36:44,580 --> 00:36:52,740
nitty-gritties of c question yes how

616
00:36:50,370 --> 00:36:54,990
does it know that the size twelve other

617
00:36:52,740 --> 00:36:57,540
side c didn't really know how many

618
00:36:54,990 --> 00:37:02,340
things are in an array the composite the

619
00:36:57,540 --> 00:37:05,220
question of how the compiler that what

620
00:37:02,340 --> 00:37:09,090
i'm i'll into your question by saying

621
00:37:05,220 --> 00:37:10,830
remember the compiler knows a lot so the

622
00:37:09,090 --> 00:37:13,620
in particular I've declared this to be

623
00:37:10,830 --> 00:37:15,360
an array of three pointers I'm compiling

624
00:37:13,620 --> 00:37:17,910
for a machine where pointers are eight

625
00:37:15,360 --> 00:37:22,380
bytes and so the compiler knows that SP

626
00:37:17,910 --> 00:37:24,960
24 bytes in general when you're when

627
00:37:22,380 --> 00:37:27,360
you're referencing and see there's no

628
00:37:24,960 --> 00:37:29,760
you know the machine doesn't have built

629
00:37:27,360 --> 00:37:32,060
into it any bounds and doesn't do bounds

630
00:37:29,760 --> 00:37:39,090
checking for you but that's in the

631
00:37:32,060 --> 00:37:41,490
runtime execution if but in C if I when

632
00:37:39,090 --> 00:37:43,530
I declare something it's known it has to

633
00:37:41,490 --> 00:37:45,839
be known at that point when the

634
00:37:43,530 --> 00:37:49,989
declaration occurs

635
00:37:45,839 --> 00:37:55,630
question go back there so instead of

636
00:37:49,989 --> 00:37:58,440
doing three I just wanted empty bracket

637
00:37:55,630 --> 00:38:04,239
yeah I think empty bracket is is it just

638
00:37:58,440 --> 00:38:06,279
another name for a pointer it's usually

639
00:38:04,239 --> 00:38:07,779
it's just given as arguments some

640
00:38:06,279 --> 00:38:10,359
restrictions on it but when you use the

641
00:38:07,779 --> 00:38:12,099
empty bracket notation and see it's

642
00:38:10,359 --> 00:38:13,690
equivalent to doing a pointer

643
00:38:12,099 --> 00:38:21,249
declaration you're not allocating any

644
00:38:13,690 --> 00:38:24,579
space for it one reality very different

645
00:38:21,249 --> 00:38:26,880
area yes right here it really means when

646
00:38:24,579 --> 00:38:29,529
you declare an array and you give a

647
00:38:26,880 --> 00:38:35,829
number the size of that array it really

648
00:38:29,529 --> 00:38:37,599
allocates that memories if question yes

649
00:38:35,829 --> 00:38:40,450
oh yes and that's the final one you'll

650
00:38:37,599 --> 00:38:42,670
notice that the numbers for a 2 and a 4

651
00:38:40,450 --> 00:38:45,279
the same and the reason is it's the same

652
00:38:42,670 --> 00:38:50,619
thing and that again goes by the

653
00:38:45,279 --> 00:38:55,539
precedence rules of see that a 2 first

654
00:38:50,619 --> 00:38:58,630
binds this way and then this way and so

655
00:38:55,539 --> 00:39:01,709
a 2 and a 4 are synonymous just with

656
00:38:58,630 --> 00:39:01,709
less parentheses

657
00:39:02,900 --> 00:39:09,410
okay so that was a bit of an aside but

658
00:39:06,140 --> 00:39:10,970
as you can see I think this is the kind

659
00:39:09,410 --> 00:39:14,390
of thing that will really probe your

660
00:39:10,970 --> 00:39:15,800
your understanding and now though it's a

661
00:39:14,390 --> 00:39:17,450
beginning seed programmer where you

662
00:39:15,800 --> 00:39:19,550
don't have a very good sense of the

663
00:39:17,450 --> 00:39:21,320
underlying representation of a program

664
00:39:19,550 --> 00:39:24,560
it's really hard to figure these things

665
00:39:21,320 --> 00:39:26,330
out but now that you know what it means

666
00:39:24,560 --> 00:39:28,670
to compile code and you can actually

667
00:39:26,330 --> 00:39:33,110
look at compiled code that'll sort of

668
00:39:28,670 --> 00:39:41,300
clear up a lot of the what's really

669
00:39:33,110 --> 00:39:43,250
going on in a program so let's now

670
00:39:41,300 --> 00:39:44,600
generalize from one dimension to two

671
00:39:43,250 --> 00:39:47,720
just to make life a little more

672
00:39:44,600 --> 00:39:50,810
interesting and again it's an important

673
00:39:47,720 --> 00:39:52,190
principle to understand that in a one

674
00:39:50,810 --> 00:39:56,030
you want to declare a multi-dimensional

675
00:39:52,190 --> 00:39:58,150
array and see you do it by a sequence of

676
00:39:56,030 --> 00:40:00,980
brackets with the balance for each one

677
00:39:58,150 --> 00:40:03,280
and the reason for that is actually

678
00:40:00,980 --> 00:40:03,280
there

679
00:40:06,280 --> 00:40:13,880
it will see that it has to do with this

680
00:40:11,630 --> 00:40:16,420
notation that we just went through so if

681
00:40:13,880 --> 00:40:16,420
I segment

682
00:40:30,940 --> 00:40:41,480
it turns out that I can read it like

683
00:40:35,330 --> 00:40:46,400
this that a is an array of three

684
00:40:41,480 --> 00:40:48,950
elements and each of those elements is

685
00:40:46,400 --> 00:40:54,470
in itself an array of five elements of

686
00:40:48,950 --> 00:40:57,440
type int and we'll get back to that but

687
00:40:54,470 --> 00:41:00,740
that kind of explains everything I'm

688
00:40:57,440 --> 00:41:04,730
about to tell you in this picture so in

689
00:41:00,740 --> 00:41:08,510
particular if I declare an array with

690
00:41:04,730 --> 00:41:11,620
our rows and C columns and you think of

691
00:41:08,510 --> 00:41:15,770
it mathematically as sort of a matrix

692
00:41:11,620 --> 00:41:25,220
two-dimensional matrix what it really

693
00:41:15,770 --> 00:41:29,330
does is it says look he is on the yep

694
00:41:25,220 --> 00:41:31,430
sometimes see actually ends up being the

695
00:41:29,330 --> 00:41:38,410
inner element it says first of all I

696
00:41:31,430 --> 00:41:40,400
want row 0 will be an array of C in

697
00:41:38,410 --> 00:41:42,650
being the number of columns

698
00:41:40,400 --> 00:41:45,350
I'll put so all the elements of row 0

699
00:41:42,650 --> 00:41:48,230
will come first all the elements of Row

700
00:41:45,350 --> 00:41:51,200
1 come next and so forth up to the end

701
00:41:48,230 --> 00:41:55,130
of it all and so the total allocation

702
00:41:51,200 --> 00:41:56,660
will be 4 times the data size times the

703
00:41:55,130 --> 00:41:59,900
number of rows times the number of

704
00:41:56,660 --> 00:42:02,600
columns bytes but the reason why they're

705
00:41:59,900 --> 00:42:04,430
in that order which is called row major

706
00:42:02,600 --> 00:42:06,530
order because if we thought of it these

707
00:42:04,430 --> 00:42:09,280
terms we go through the first row and

708
00:42:06,530 --> 00:42:17,050
then the second row in the third row is

709
00:42:09,280 --> 00:42:17,050
precisely because of this

710
00:42:18,400 --> 00:42:29,750
notation let me write it down like this

711
00:42:22,040 --> 00:42:32,690
int of a of well let me just use that

712
00:42:29,750 --> 00:42:39,700
the one I said you can write this out as

713
00:42:32,690 --> 00:42:39,700
a is a array a free all may be right

714
00:42:49,660 --> 00:42:54,010
over half and select 2/3

715
00:42:56,829 --> 00:43:04,849
I'll just put it over here okay so a is

716
00:43:01,670 --> 00:43:08,150
the 3 element array and or generalizing

717
00:43:04,849 --> 00:43:11,720
to this picture a is an array of our

718
00:43:08,150 --> 00:43:14,240
element this is the first element this

719
00:43:11,720 --> 00:43:17,869
is the second element and this is the

720
00:43:14,240 --> 00:43:26,920
arts element but what kind of elements

721
00:43:17,869 --> 00:43:26,920
are those each is an array

722
00:43:28,500 --> 00:43:32,070
of five minutes

723
00:43:35,880 --> 00:43:48,210
so within array a here each subpart of a

724
00:43:42,240 --> 00:43:50,160
then is an array of C in and so that's

725
00:43:48,210 --> 00:43:53,390
why logically the way these are

726
00:43:50,160 --> 00:43:58,740
organized actually comes from this

727
00:43:53,390 --> 00:44:04,370
declaration notation directly and what's

728
00:43:58,740 --> 00:44:09,090
the examples of that so for example if I

729
00:44:04,370 --> 00:44:12,540
wanted to extend my zip tidge idea and

730
00:44:09,090 --> 00:44:18,320
introduce an array of four of these I

731
00:44:12,540 --> 00:44:21,030
could declare it this way and again with

732
00:44:18,320 --> 00:44:23,820
remember I used a type def to declare

733
00:44:21,030 --> 00:44:26,730
zip tidge but if i were to expand this

734
00:44:23,820 --> 00:44:30,510
out it was would be as if i was

735
00:44:26,730 --> 00:44:32,730
declaring this array PGH to be a four

736
00:44:30,510 --> 00:44:35,880
rows and five columns but what it really

737
00:44:32,730 --> 00:44:39,240
is is the array of four elements one two

738
00:44:35,880 --> 00:44:43,260
three four each of which is an array of

739
00:44:39,240 --> 00:44:46,740
five minutes okay so think of that

740
00:44:43,260 --> 00:44:49,250
nesting when you read declarations you

741
00:44:46,740 --> 00:44:52,500
start from the name of the element and

742
00:44:49,250 --> 00:44:56,450
you work your way outward through these

743
00:44:52,500 --> 00:44:56,450
brackets and stars in some order

744
00:44:57,509 --> 00:45:05,729
oh and so in particular if I want to

745
00:45:03,239 --> 00:45:07,609
reference a particular element of an

746
00:45:05,729 --> 00:45:17,099
array

747
00:45:07,609 --> 00:45:19,469
the general rule is wrong here oh the

748
00:45:17,099 --> 00:45:24,829
general rule is this one if I want to

749
00:45:19,469 --> 00:45:24,829
reference literally

750
00:45:25,560 --> 00:45:39,390
so I'm building up to it so yes this

751
00:45:34,740 --> 00:45:41,400
shows that a of I I can actually just do

752
00:45:39,390 --> 00:45:45,000
the reference a of I I don't have to

753
00:45:41,400 --> 00:45:49,080
give a of I of J in C and what that

754
00:45:45,000 --> 00:45:51,720
denotes is one of these our rows of the

755
00:45:49,080 --> 00:45:56,400
array and each of which is an array of

756
00:45:51,720 --> 00:45:59,850
see elements of type int and so imagine

757
00:45:56,400 --> 00:46:02,010
that in general we have K bytes for data

758
00:45:59,850 --> 00:46:05,340
type T the underlying data type in this

759
00:46:02,010 --> 00:46:07,980
case of T is an int and K equals four

760
00:46:05,340 --> 00:46:12,630
but in general the starting address then

761
00:46:07,980 --> 00:46:16,610
of row I would be gotten by multiplying

762
00:46:12,630 --> 00:46:21,410
the number of columns by K and then

763
00:46:16,610 --> 00:46:21,410
multiplying that by the row number

764
00:46:23,260 --> 00:46:30,790
and now if within the array I want to

765
00:46:25,750 --> 00:46:33,340
reference a ray element a sub IJ then it

766
00:46:30,790 --> 00:46:36,310
comes up to this computation you take

767
00:46:33,340 --> 00:46:39,250
the starting address you scale the row

768
00:46:36,310 --> 00:46:41,380
number by the number of columns add to

769
00:46:39,250 --> 00:46:44,980
it which column you want and then

770
00:46:41,380 --> 00:46:49,150
multiply that all by okay so the way to

771
00:46:44,980 --> 00:46:54,700
see that is here I can get to row number

772
00:46:49,150 --> 00:46:57,010
I by just scaling I by the number of

773
00:46:54,700 --> 00:47:01,390
columns times the size of the elements

774
00:46:57,010 --> 00:47:05,050
are four and now I want to get to the JC

775
00:47:01,390 --> 00:47:08,350
element of this sub array here and I can

776
00:47:05,050 --> 00:47:10,930
do that by scaling J by four and adding

777
00:47:08,350 --> 00:47:14,260
it to the beginning of this sub array

778
00:47:10,930 --> 00:47:16,600
and now I can just collect the force

779
00:47:14,260 --> 00:47:18,490
together and that's what and pull it

780
00:47:16,600 --> 00:47:24,130
outside here that's what gives you this

781
00:47:18,490 --> 00:47:26,680
formula so again the the point of this

782
00:47:24,130 --> 00:47:30,760
is that this all kind of is a natural

783
00:47:26,680 --> 00:47:33,310
outcome of the Declaration and it's easy

784
00:47:30,760 --> 00:47:36,869
to think of it in terms of this storage

785
00:47:33,310 --> 00:47:39,869
model here of how the actual array is

786
00:47:36,869 --> 00:47:39,869
allocated

787
00:47:41,660 --> 00:47:50,400
okay now a different style of

788
00:47:45,000 --> 00:47:54,330
declaration is imagine I create three of

789
00:47:50,400 --> 00:48:02,040
these arrays and now I want to create an

790
00:47:54,330 --> 00:48:05,580
array that contains that appoints to

791
00:48:02,040 --> 00:48:07,440
these so this is a different data

792
00:48:05,580 --> 00:48:10,170
structure you'll observe from before

793
00:48:07,440 --> 00:48:13,070
what Univ now is an array of three

794
00:48:10,170 --> 00:48:17,460
pointers in each of those pointers

795
00:48:13,070 --> 00:48:19,790
points to a one of these arrays of five

796
00:48:17,460 --> 00:48:19,790
ends

797
00:48:21,800 --> 00:48:23,860
you

798
00:48:24,219 --> 00:48:31,619
and their underlying data type by the

799
00:48:26,410 --> 00:48:35,170
way of these elements are in stars right

800
00:48:31,619 --> 00:48:36,700
and C does not differentiate when you

801
00:48:35,170 --> 00:48:38,469
want to declare a ring like this you

802
00:48:36,700 --> 00:48:42,549
just say it's an int star you don't say

803
00:48:38,469 --> 00:48:46,089
how many elements are the underlying

804
00:48:42,549 --> 00:48:48,210
array is so you'll see by these picture

805
00:48:46,089 --> 00:48:52,269
that these are different data structures

806
00:48:48,210 --> 00:48:54,069
so now let's go through the what the

807
00:48:52,269 --> 00:49:01,749
assembly code looks like to reference

808
00:48:54,069 --> 00:49:07,180
these two data structures we didn't did

809
00:49:01,749 --> 00:49:12,700
we do the I'm sorry I would have thought

810
00:49:07,180 --> 00:49:17,049
I'd have assembly code system might be a

811
00:49:12,700 --> 00:49:20,609
missing slide you so we'll see so

812
00:49:17,049 --> 00:49:20,609
imagine I wanted to reference

813
00:49:24,510 --> 00:49:29,840
I'm sorry I'm confused why there is no

814
00:49:32,390 --> 00:49:34,390
ah

815
00:49:46,310 --> 00:49:49,350
they should have been I'm sorry this is

816
00:49:49,050 --> 00:49:52,200
uh

817
00:49:49,350 --> 00:49:58,590
I'm pausing here because I think I meant

818
00:49:52,200 --> 00:50:02,330
to have a slide that would show what the

819
00:49:58,590 --> 00:50:02,330
code looks like and I don't

820
00:50:02,410 --> 00:50:06,450
okay what we're going to have to wing it

821
00:50:08,580 --> 00:50:17,250
so if you wanted to in assembly code

822
00:50:12,490 --> 00:50:19,960
then reference an element of an array

823
00:50:17,250 --> 00:50:22,060
like this a multi-dimensional array what

824
00:50:19,960 --> 00:50:26,310
you'll see is that the code kind of

825
00:50:22,060 --> 00:50:30,340
builds up a computation like this and

826
00:50:26,310 --> 00:50:34,210
typically in the compiled code the value

827
00:50:30,340 --> 00:50:36,970
of K is a kind of a constant value and

828
00:50:34,210 --> 00:50:40,420
if it's a Ray that's been declared with

829
00:50:36,970 --> 00:50:44,380
a constant bounds then the value of C

830
00:50:40,420 --> 00:50:46,480
will also be a constant and so a piece

831
00:50:44,380 --> 00:50:49,840
of code for this and that's why got

832
00:50:46,480 --> 00:50:52,210
omitted by accident will basically take

833
00:50:49,840 --> 00:50:55,240
this value and use some combination of

834
00:50:52,210 --> 00:50:58,330
the memory referencing and shifting and

835
00:50:55,240 --> 00:51:01,090
le.a instructions and so forth to

836
00:50:58,330 --> 00:51:05,050
implement this computation and then do a

837
00:51:01,090 --> 00:51:07,510
dereference so let's look at the second

838
00:51:05,050 --> 00:51:09,070
example and there is code for this and

839
00:51:07,510 --> 00:51:11,770
it's actually a little bit more complex

840
00:51:09,070 --> 00:51:15,130
because this is going through two levels

841
00:51:11,770 --> 00:51:22,600
of indirection so you'll see that to get

842
00:51:15,130 --> 00:51:26,860
the digit a particular digit from a

843
00:51:22,600 --> 00:51:32,280
particular of one of these universities

844
00:51:26,860 --> 00:51:36,760
then it has to first of all figure out

845
00:51:32,280 --> 00:51:39,400
do this D references get the a pointer

846
00:51:36,760 --> 00:51:43,410
to the beginning of the array and that's

847
00:51:39,400 --> 00:51:43,410
what this reference is doing here

848
00:51:48,310 --> 00:51:55,400
okay but first of all what it's doing is

849
00:51:51,380 --> 00:51:58,970
shifting RSA I left by two which is

850
00:51:55,400 --> 00:52:02,540
equivalent to scaling the the digit by

851
00:51:58,970 --> 00:52:05,630
four because it's getting ready to take

852
00:52:02,540 --> 00:52:11,900
that digit of parameter and scale it

853
00:52:05,630 --> 00:52:19,730
appropriately and then it takes that

854
00:52:11,900 --> 00:52:26,590
number and add to it the value I get by

855
00:52:19,730 --> 00:52:30,710
reading from their array Univ but using

856
00:52:26,590 --> 00:52:33,230
the index scaling it by eight to

857
00:52:30,710 --> 00:52:35,540
actually do a memory reference so

858
00:52:33,230 --> 00:52:37,370
remember this instruction then and it

859
00:52:35,540 --> 00:52:40,610
looks a little weird is actually doing a

860
00:52:37,370 --> 00:52:43,490
memory reference here of this three

861
00:52:40,610 --> 00:52:46,040
element array of called units so it's

862
00:52:43,490 --> 00:52:49,160
reading from memory and doing an array

863
00:52:46,040 --> 00:52:52,640
index directly here by scaling and now

864
00:52:49,160 --> 00:52:56,420
getting from that a pointer adding to

865
00:52:52,640 --> 00:52:59,780
that the the scaled value of of the

866
00:52:56,420 --> 00:53:08,660
digit and so that gives me a pointer now

867
00:52:59,780 --> 00:53:10,430
as this notation shows to to the

868
00:53:08,660 --> 00:53:13,340
particular element I want and now it

869
00:53:10,430 --> 00:53:16,190
does a dereference so that's a pretty

870
00:53:13,340 --> 00:53:19,210
tough example to get as you're one of

871
00:53:16,190 --> 00:53:19,210
your first array one

872
00:53:22,220 --> 00:53:29,570
and as I said I apologize for missing

873
00:53:25,400 --> 00:53:33,130
the reference to a particular element of

874
00:53:29,570 --> 00:53:35,930
this array is done entirely by computing

875
00:53:33,130 --> 00:53:41,410
scaling indices in appropriate ways you

876
00:53:35,930 --> 00:53:45,830
want to take the array and scale the

877
00:53:41,410 --> 00:53:48,950
first index by 20 because each row is 20

878
00:53:45,830 --> 00:53:53,060
elements it's 5 times 4 and you want to

879
00:53:48,950 --> 00:53:55,010
scale the digit by 4 to select the

880
00:53:53,060 --> 00:53:59,510
particular element within that array and

881
00:53:55,010 --> 00:54:01,130
so you all this address computation

882
00:53:59,510 --> 00:54:03,530
takes place and then there's a single

883
00:54:01,130 --> 00:54:04,880
memory reference whereas in this data

884
00:54:03,530 --> 00:54:07,160
structure you have to go through to

885
00:54:04,880 --> 00:54:09,350
memory references first of all to you

886
00:54:07,160 --> 00:54:11,870
have to index and get the appropriate

887
00:54:09,350 --> 00:54:14,900
element here but that's just a pointer

888
00:54:11,870 --> 00:54:16,700
now and then we add an offset to that

889
00:54:14,900 --> 00:54:20,120
pointer to get the appropriate element

890
00:54:16,700 --> 00:54:22,340
in this array here and then we read from

891
00:54:20,120 --> 00:54:24,620
that so that's what this notation means

892
00:54:22,340 --> 00:54:27,080
is that I'm doing two memory references

893
00:54:24,620 --> 00:54:28,460
here and just one there and it's a

894
00:54:27,080 --> 00:54:32,450
little bit curious because if you look

895
00:54:28,460 --> 00:54:34,550
in the C code it looks the same but the

896
00:54:32,450 --> 00:54:37,990
underlying data types are different and

897
00:54:34,550 --> 00:54:37,990
so the references are different

898
00:54:39,910 --> 00:54:45,849
okay so let's look at some other

899
00:54:43,349 --> 00:54:48,700
variations on this code and these are

900
00:54:45,849 --> 00:54:52,299
all we'll do to fall out from these

901
00:54:48,700 --> 00:54:55,000
general principles I've described so

902
00:54:52,299 --> 00:54:56,220
first of all what introduced an array a

903
00:54:55,000 --> 00:54:59,200
two by two

904
00:54:56,220 --> 00:55:03,910
I'm sorry sixteen by sixteen array of

905
00:54:59,200 --> 00:55:06,309
intz and it used to be and see if you

906
00:55:03,910 --> 00:55:08,230
wanted to do multi-dimensional arrays

907
00:55:06,309 --> 00:55:10,900
where the size of the array was not

908
00:55:08,230 --> 00:55:13,180
fixed at compile time you basically had

909
00:55:10,900 --> 00:55:17,309
to implement your own version of that

910
00:55:13,180 --> 00:55:21,579
computation I showed before of scaling

911
00:55:17,309 --> 00:55:26,230
the the row number by the number of

912
00:55:21,579 --> 00:55:28,210
columns and adding to it J so this is

913
00:55:26,230 --> 00:55:30,730
sort of classic C I've written it as a

914
00:55:28,210 --> 00:55:33,880
macro here but you can see it it's just

915
00:55:30,730 --> 00:55:36,880
doing the row major scaling directly

916
00:55:33,880 --> 00:55:40,029
here is the address arithmetic now since

917
00:55:36,880 --> 00:55:43,150
a more recent generation of the C

918
00:55:40,029 --> 00:55:52,750
compiler what they call c99 it was

919
00:55:43,150 --> 00:55:56,559
introduced in 1999 you can actually pass

920
00:55:52,750 --> 00:55:59,289
as a parameter an array where the number

921
00:55:56,559 --> 00:56:02,309
of elements in the array is also a

922
00:55:59,289 --> 00:56:05,170
parameter that's being passed to the

923
00:56:02,309 --> 00:56:08,289
function and similarly you can declare

924
00:56:05,170 --> 00:56:10,630
an array to be of n elements as long as

925
00:56:08,289 --> 00:56:13,150
n has been computed before it hits that

926
00:56:10,630 --> 00:56:15,430
array declaration and the compiler will

927
00:56:13,150 --> 00:56:18,630
do the right thing it will allocate the

928
00:56:15,430 --> 00:56:18,630
proper number of elements

929
00:56:19,550 --> 00:56:34,790
um so let's just look at some of this

930
00:56:26,180 --> 00:56:36,560
code examples and again what we'll see

931
00:56:34,790 --> 00:56:38,750
here and this will show you an example

932
00:56:36,560 --> 00:56:40,520
of the two turrets the the kind of

933
00:56:38,750 --> 00:56:43,640
address computation that takes place

934
00:56:40,520 --> 00:56:46,880
with a two dimensional array in this

935
00:56:43,640 --> 00:56:50,900
case I know C is 16 and K is 4 so if I

936
00:56:46,880 --> 00:56:57,100
want to get element I sub j IJ out of

937
00:56:50,900 --> 00:57:04,370
this array then first of all scale I by

938
00:56:57,100 --> 00:57:09,100
64 because that's and I'll add that to

939
00:57:04,370 --> 00:57:13,940
the base and then I'll scale RDX by 4

940
00:57:09,100 --> 00:57:16,130
that's J and add it to this array and so

941
00:57:13,940 --> 00:57:19,220
and then do a memory reference there so

942
00:57:16,130 --> 00:57:22,420
in the end I'm doing you see these two

943
00:57:19,220 --> 00:57:24,860
instructions have done the appropriate

944
00:57:22,420 --> 00:57:27,950
the three instructions have done the

945
00:57:24,860 --> 00:57:30,110
appropriate scaling of I and J as of

946
00:57:27,950 --> 00:57:36,020
them to the beginning address of a and

947
00:57:30,110 --> 00:57:41,570
I've done the computation on the other

948
00:57:36,020 --> 00:57:43,940
hand if it's a 1 the third example I

949
00:57:41,570 --> 00:57:45,830
showed where N is a parameter that's

950
00:57:43,940 --> 00:57:46,730
passed to the function so it's not known

951
00:57:45,830 --> 00:57:50,960
at compile time

952
00:57:46,730 --> 00:57:52,580
how big a scaling factor to use you see

953
00:57:50,960 --> 00:57:55,390
that it has to use a multiply

954
00:57:52,580 --> 00:57:57,860
instruction to do that which is a

955
00:57:55,390 --> 00:58:01,280
relatively expensive instruction in

956
00:57:57,860 --> 00:58:04,190
terms of performance and then once it

957
00:58:01,280 --> 00:58:07,280
has that that's just n times I and then

958
00:58:04,190 --> 00:58:11,230
it uses various combinations of le A's

959
00:58:07,280 --> 00:58:13,880
and the scaling notation from before to

960
00:58:11,230 --> 00:58:17,810
compute an appropriate offset into the

961
00:58:13,880 --> 00:58:23,720
array to do the reference so here I

962
00:58:17,810 --> 00:58:25,730
could do it with a shift and here I had

963
00:58:23,720 --> 00:58:31,220
to introduce a multiply because I don't

964
00:58:25,730 --> 00:58:43,310
know in advance how big it is if you

965
00:58:31,220 --> 00:58:51,260
want to torture yourself here's an

966
00:58:43,310 --> 00:58:54,470
example I was going to go over of triply

967
00:58:51,260 --> 00:59:00,980
nested possibilities and dereferencing

968
00:58:54,470 --> 00:59:06,530
of the same idea but let's move on to

969
00:59:00,980 --> 00:59:08,530
pointers oh it just drugs so the idea of

970
00:59:06,530 --> 00:59:11,720
a struct is actually quite simple oh

971
00:59:08,530 --> 00:59:12,620
well the base idea is since when it gets

972
00:59:11,720 --> 00:59:18,710
more complicated

973
00:59:12,620 --> 00:59:20,780
oh the idea that is I want to I declare

974
00:59:18,710 --> 00:59:24,290
a struct to have some number of fields

975
00:59:20,780 --> 00:59:27,200
each of which can be an int or it could

976
00:59:24,290 --> 00:59:29,930
be in this case a pointer or it could be

977
00:59:27,200 --> 00:59:31,580
an array itself but the rule is

978
00:59:29,930 --> 00:59:36,020
basically what I'll do is allocate

979
00:59:31,580 --> 00:59:38,090
enough space if I introduce one of these

980
00:59:36,020 --> 00:59:41,960
drugs for all the different array

981
00:59:38,090 --> 00:59:44,900
elements fields and that our struct and

982
00:59:41,960 --> 00:59:47,060
then I'll I'll basically keep track the

983
00:59:44,900 --> 00:59:50,990
compiler will keep track of where each

984
00:59:47,060 --> 00:59:53,240
of these fields starts and generate the

985
00:59:50,990 --> 00:59:55,880
appropriate code to offset from the

986
00:59:53,240 --> 00:59:57,410
beginning so the structure itself the

987
00:59:55,880 --> 00:59:59,900
reference to it will be the beginning

988
00:59:57,410 --> 01:00:02,330
address of the struct and then I'll use

989
00:59:59,900 --> 01:00:09,800
appropriate offset to get to the

990
01:00:02,330 --> 01:00:13,390
different field so here's an example of

991
01:00:09,800 --> 01:00:13,390
some code imagine I

992
01:00:14,730 --> 01:00:21,210
have a struct a pointer to one of these

993
01:00:17,280 --> 01:00:24,180
structures and I have an index and what

994
01:00:21,210 --> 01:00:29,820
I want to do is get to the that

995
01:00:24,180 --> 01:00:32,370
appropriate part of array a within this

996
01:00:29,820 --> 01:00:33,990
struct well array a is right at the

997
01:00:32,370 --> 01:00:36,240
beginning of the structure so I can

998
01:00:33,990 --> 01:00:40,410
treat this just like I would any array

999
01:00:36,240 --> 01:00:42,720
reference of scaling idx by 4 and adding

1000
01:00:40,410 --> 01:00:44,190
it to the base to get the appropriate

1001
01:00:42,720 --> 01:00:45,180
element so I don't really have to do

1002
01:00:44,190 --> 01:00:48,840
anything special

1003
01:00:45,180 --> 01:00:52,770
for this one let's go get some other

1004
01:00:48,840 --> 01:00:57,480
code that you'll typically see actually

1005
01:00:52,770 --> 01:00:58,950
this example is pretty involved so I'm

1006
01:00:57,480 --> 01:01:02,070
actually doing a whole bunch of stuff

1007
01:00:58,950 --> 01:01:04,530
here with this one struct first of all

1008
01:01:02,070 --> 01:01:11,060
I'm trying to retrieve element I from

1009
01:01:04,530 --> 01:01:15,270
the structure then I'm using that to

1010
01:01:11,060 --> 01:01:19,140
index into array a and and insert a

1011
01:01:15,270 --> 01:01:24,260
value into there and then I'm updating

1012
01:01:19,140 --> 01:01:24,260
this pointer to point to the next

1013
01:01:26,340 --> 01:01:31,650
I'm if this were a link twist

1014
01:01:30,360 --> 01:01:35,270
what I want to do is step to the next

1015
01:01:31,650 --> 01:01:39,540
owner is a list so I need to retrieve

1016
01:01:35,270 --> 01:01:41,640
the next field from here and so these in

1017
01:01:39,540 --> 01:01:44,190
so I'm actually making three references

1018
01:01:41,640 --> 01:01:46,140
to this structure and this one rather

1019
01:01:44,190 --> 01:01:51,240
small function so let's try and figure

1020
01:01:46,140 --> 01:01:53,610
it all out so first of all I have to

1021
01:01:51,240 --> 01:01:55,860
retrieve element I from it and here you

1022
01:01:53,610 --> 01:01:59,700
see that we know that element I is that

1023
01:01:55,860 --> 01:02:01,860
offset 16 and so and here's where you

1024
01:01:59,700 --> 01:02:04,560
see that displacement field being used

1025
01:02:01,860 --> 01:02:08,310
in the memory reference exactly for this

1026
01:02:04,560 --> 01:02:11,100
purpose I want to take R but add 16 to

1027
01:02:08,310 --> 01:02:13,640
it to get a memory address that I can

1028
01:02:11,100 --> 01:02:13,640
use for

1029
01:02:14,490 --> 01:02:26,820
for I and it you see it actually uses

1030
01:02:21,150 --> 01:02:28,800
move slq because I itself is an int but

1031
01:02:26,820 --> 01:02:33,270
I'm going to use it as an array index in

1032
01:02:28,800 --> 01:02:35,849
which case I have to scale it I have to

1033
01:02:33,270 --> 01:02:38,190
do address arithmetic using 8 byte

1034
01:02:35,849 --> 01:02:40,830
quantities so this actually retrieves

1035
01:02:38,190 --> 01:02:46,260
the 4 byte value and does a sign

1036
01:02:40,830 --> 01:02:54,000
extension on it and now what I want to

1037
01:02:46,260 --> 01:02:57,810
do is store at a Val at element I and so

1038
01:02:54,000 --> 01:03:02,119
here you'll see that it's using our ax

1039
01:02:57,810 --> 01:03:02,119
is the value of just computed for I

1040
01:03:02,450 --> 01:03:10,380
scale linked by 4 and using the starting

1041
01:03:07,680 --> 01:03:12,720
address of the R which happens to be the

1042
01:03:10,380 --> 01:03:15,089
starting address of a as well and doing

1043
01:03:12,720 --> 01:03:20,310
a store so that's sort of an array

1044
01:03:15,089 --> 01:03:26,849
operation there and then the next part

1045
01:03:20,310 --> 01:03:31,260
is I'm going to offset 24 which is the

1046
01:03:26,849 --> 01:03:35,060
position of next read from that location

1047
01:03:31,260 --> 01:03:37,950
and store that in our GI which is aa R

1048
01:03:35,060 --> 01:03:41,220
so this is the operation argit's our

1049
01:03:37,950 --> 01:03:43,830
arrow next and then the loop is I'm

1050
01:03:41,220 --> 01:03:47,240
testing until R is no so that's going on

1051
01:03:43,830 --> 01:03:50,640
here so you see that those three

1052
01:03:47,240 --> 01:03:53,250
references to destruct we're implemented

1053
01:03:50,640 --> 01:03:56,430
using three instructions here so it's a

1054
01:03:53,250 --> 01:03:59,609
very direct mapping between the the code

1055
01:03:56,430 --> 01:04:02,310
here and the x86 instructions and part

1056
01:03:59,609 --> 01:04:04,230
of the x86 instructions because this

1057
01:04:02,310 --> 01:04:06,900
kind of stuff is so commonplace in

1058
01:04:04,230 --> 01:04:08,910
programs they kind of made the

1059
01:04:06,900 --> 01:04:13,230
instructions map very directly toward

1060
01:04:08,910 --> 01:04:15,780
these operations and now you should

1061
01:04:13,230 --> 01:04:17,880
probably see why all the bells and

1062
01:04:15,780 --> 01:04:22,130
whistles are there for these address

1063
01:04:17,880 --> 01:04:28,520
references questions what if I was

1064
01:04:22,130 --> 01:04:35,750
what if I was three I'm sorry because

1065
01:04:28,520 --> 01:04:39,850
they fucking name 300 a had a eyes three

1066
01:04:35,750 --> 01:04:39,850
elements yes it will access

1067
01:04:41,640 --> 01:04:49,920
actually I think that's the typo Hayes

1068
01:04:45,049 --> 01:04:52,589
supposed to be for visit with them so if

1069
01:04:49,920 --> 01:04:56,339
I for it would access itself yeah and it

1070
01:04:52,589 --> 01:05:04,289
would mess things up question this is a

1071
01:04:56,339 --> 01:05:09,140
typo by the way it should be a 4 yes a

1072
01:05:04,289 --> 01:05:09,140
null pointer I know is a 0

1073
01:05:12,760 --> 01:05:17,150
so that's sort of the easy version of

1074
01:05:15,350 --> 01:05:20,660
structs now let's make them a little

1075
01:05:17,150 --> 01:05:25,220
harder one is for reasons that are a bit

1076
01:05:20,660 --> 01:05:27,470
obscure the machine generally prefers

1077
01:05:25,220 --> 01:05:30,920
that if you have a data type and

1078
01:05:27,470 --> 01:05:32,900
underlying data type of K bytes that the

1079
01:05:30,920 --> 01:05:38,470
address that that starts at be a

1080
01:05:32,900 --> 01:05:42,800
multiple of K and so that introduces a

1081
01:05:38,470 --> 01:05:44,950
property we call alignment which will

1082
01:05:42,800 --> 01:05:48,380
actually when a structure gets allocated

1083
01:05:44,950 --> 01:05:50,960
well the the compiler will actually

1084
01:05:48,380 --> 01:05:55,250
insert some blank unused bytes in the

1085
01:05:50,960 --> 01:05:57,590
data structure in its allocation just so

1086
01:05:55,250 --> 01:06:03,110
that it can maintain this alignment so

1087
01:05:57,590 --> 01:06:05,030
for example here I is a as an int and I

1088
01:06:03,110 --> 01:06:08,570
want it to address to be a multiple of

1089
01:06:05,030 --> 01:06:09,490
four now I'll give you a minute why

1090
01:06:08,570 --> 01:06:12,440
that's true

1091
01:06:09,490 --> 01:06:15,740
I'll just so trust me for a minute and

1092
01:06:12,440 --> 01:06:18,500
so it'll actually had three unused bytes

1093
01:06:15,740 --> 01:06:21,350
here because the first byte is being

1094
01:06:18,500 --> 01:06:22,790
used by C and in general we'll see in

1095
01:06:21,350 --> 01:06:24,860
the allocation we're going to make sure

1096
01:06:22,790 --> 01:06:27,620
that the pointer to this data structure

1097
01:06:24,860 --> 01:06:29,240
is itself a multiple of eight and the

1098
01:06:27,620 --> 01:06:33,250
reason for that is because there's a

1099
01:06:29,240 --> 01:06:35,570
double here and it should reside on a

1100
01:06:33,250 --> 01:06:38,360
boundary that its starting address

1101
01:06:35,570 --> 01:06:40,760
should be a multiple of eight and you

1102
01:06:38,360 --> 01:06:43,700
see as long as this is eight a multiple

1103
01:06:40,760 --> 01:06:45,680
of 8 and this offset here is a multiple

1104
01:06:43,700 --> 01:06:48,650
of 8 then this address will be a

1105
01:06:45,680 --> 01:06:53,540
multiple of eight so that's the idea of

1106
01:06:48,650 --> 01:06:55,970
alignment and so why is that true well

1107
01:06:53,540 --> 01:07:00,590
it's really a hardware issue that the

1108
01:06:55,970 --> 01:07:02,870
memory system instead of the actual

1109
01:07:00,590 --> 01:07:06,470
hardware memory does not reference one

1110
01:07:02,870 --> 01:07:09,380
byte at a time at references actually in

1111
01:07:06,470 --> 01:07:12,260
most machines nowadays about 64 bytes at

1112
01:07:09,380 --> 01:07:15,800
a time or depending on various widths

1113
01:07:12,260 --> 01:07:19,010
within the hardware and in general if if

1114
01:07:15,800 --> 01:07:22,090
a particular piece of data across is the

1115
01:07:19,010 --> 01:07:23,210
boundaries between 2 blocks of that are

1116
01:07:22,090 --> 01:07:25,730
the

1117
01:07:23,210 --> 01:07:27,589
a misaligned address that will take

1118
01:07:25,730 --> 01:07:30,140
extra steps by the hardware and

1119
01:07:27,589 --> 01:07:32,510
potentially even the operating system to

1120
01:07:30,140 --> 01:07:36,099
deal with so just for efficiency reason

1121
01:07:32,510 --> 01:07:39,980
they say do this alignment trust me in

1122
01:07:36,099 --> 01:07:42,170
x86 machines if you have unaligned data

1123
01:07:39,980 --> 01:07:44,390
it will execute just fine it just might

1124
01:07:42,170 --> 01:07:46,700
run a little bit more slowly on some

1125
01:07:44,390 --> 01:07:48,970
other machines if you try to do an

1126
01:07:46,700 --> 01:08:02,720
unwind access it will actually cause a

1127
01:07:48,970 --> 01:08:04,310
memory fault question yes the cecum the

1128
01:08:02,720 --> 01:08:08,240
question was how could you force it to

1129
01:08:04,310 --> 01:08:12,980
generate unwind data I don't know if you

1130
01:08:08,240 --> 01:08:15,650
could and we'll talk about ways you can

1131
01:08:12,980 --> 01:08:20,109
sort of be more clever in how you do

1132
01:08:15,650 --> 01:08:24,350
your allocation to avoid wasting space

1133
01:08:20,109 --> 01:08:26,029
so in general then we have we're mostly

1134
01:08:24,350 --> 01:08:30,770
looking here at data types that are

1135
01:08:26,029 --> 01:08:34,759
either 1 2 or 4 8 bytes long there are

1136
01:08:30,770 --> 01:08:37,670
some 16 byte data types but we won't be

1137
01:08:34,759 --> 01:08:40,250
looking at those and in general would be

1138
01:08:37,670 --> 01:08:43,100
address then you can tell the alignment

1139
01:08:40,250 --> 01:08:45,620
of an address by how many zeros if it's

1140
01:08:43,100 --> 01:08:46,880
a power of 2 alignment how many zeros

1141
01:08:45,620 --> 01:08:51,200
are at the end of a bit level

1142
01:08:46,880 --> 01:08:53,569
representation of that address and so as

1143
01:08:51,200 --> 01:08:56,989
we showed in general the C compiler when

1144
01:08:53,569 --> 01:09:01,730
it's creating the layout for a structure

1145
01:08:56,989 --> 01:09:06,020
a struct will put in padding bytes in

1146
01:09:01,730 --> 01:09:08,140
there to make the alignment work the

1147
01:09:06,020 --> 01:09:11,509
other thing it will do is if it need be

1148
01:09:08,140 --> 01:09:13,430
it will add bytes to the end to make

1149
01:09:11,509 --> 01:09:15,950
sure that the overall size of the data

1150
01:09:13,430 --> 01:09:17,839
structure meets whatever underlying

1151
01:09:15,950 --> 01:09:20,509
alignment requirement there is and this

1152
01:09:17,839 --> 01:09:22,370
one because it contains a double the

1153
01:09:20,509 --> 01:09:25,620
overall data structure has to be aligned

1154
01:09:22,370 --> 01:09:28,510
on an 8 byte boundary

1155
01:09:25,620 --> 01:09:34,240
and the reasoning for that is imagine I

1156
01:09:28,510 --> 01:09:38,170
had an array of structs of these trucks

1157
01:09:34,240 --> 01:09:41,350
in particular then if I can assume that

1158
01:09:38,170 --> 01:09:43,380
if I can ensure that this array is a

1159
01:09:41,350 --> 01:09:45,819
multi address to the multiple of eight

1160
01:09:43,380 --> 01:09:48,990
then you can see that each successive

1161
01:09:45,819 --> 01:09:52,299
element of this array of these trucks is

1162
01:09:48,990 --> 01:09:55,030
a multiple of eight and then within that

1163
01:09:52,299 --> 01:09:58,110
struct I've ensured that each field that

1164
01:09:55,030 --> 01:10:00,640
requires an alignment by eight is

1165
01:09:58,110 --> 01:10:02,620
positioned with an offset that's the

1166
01:10:00,640 --> 01:10:05,140
multiple of eight and so it all works

1167
01:10:02,620 --> 01:10:08,800
out but if you try to tinker with this

1168
01:10:05,140 --> 01:10:11,940
by making this too short then you start

1169
01:10:08,800 --> 01:10:11,940
getting misaligned reference

1170
01:10:18,409 --> 01:10:24,210
and so one thing you'll see is for every

1171
01:10:22,020 --> 01:10:27,119
struck the actual alignment requirement

1172
01:10:24,210 --> 01:10:29,850
depends on what's the sort of worst-case

1173
01:10:27,119 --> 01:10:32,429
alignment the the maximum alignment of

1174
01:10:29,850 --> 01:10:37,170
any element so this particular structure

1175
01:10:32,429 --> 01:10:40,409
for example contains a a float V which

1176
01:10:37,170 --> 01:10:44,969
has a size of four and so this would be

1177
01:10:40,409 --> 01:10:49,650
an alignment of four and you'll see in

1178
01:10:44,969 --> 01:10:52,260
the code in general when it has to this

1179
01:10:49,650 --> 01:10:54,530
all this address arithmetic we've seen

1180
01:10:52,260 --> 01:10:57,960
get fused in various different ways to

1181
01:10:54,530 --> 01:11:02,420
scale values compute offsets and so

1182
01:10:57,960 --> 01:11:05,280
forth to get the appropriate elements so

1183
01:11:02,420 --> 01:11:07,830
your question before is could I tell the

1184
01:11:05,280 --> 01:11:12,750
compiler not to do alignment and the

1185
01:11:07,830 --> 01:11:14,760
better way is to declare your fields in

1186
01:11:12,750 --> 01:11:20,030
a way that minimizes the amount of

1187
01:11:14,760 --> 01:11:22,619
wasted space so for example here I

1188
01:11:20,030 --> 01:11:24,630
wasted three bytes here and three bytes

1189
01:11:22,619 --> 01:11:27,630
here to meet the alignment requirements

1190
01:11:24,630 --> 01:11:30,150
but if I just put I at the beginning and

1191
01:11:27,630 --> 01:11:34,679
then C and D I would have only wasted

1192
01:11:30,150 --> 01:11:36,210
two bytes total and in general because

1193
01:11:34,679 --> 01:11:38,699
all the alignment requirements are

1194
01:11:36,210 --> 01:11:40,770
powers of two the sort of greedy

1195
01:11:38,699 --> 01:11:42,119
algorithm works it says if I just take

1196
01:11:40,770 --> 01:11:45,270
put the biggest stuff at the beginning

1197
01:11:42,119 --> 01:11:48,210
and then successfully smaller elements I

1198
01:11:45,270 --> 01:11:53,969
will be able to minimize any wasted

1199
01:11:48,210 --> 01:11:56,250
space and that's a general property but

1200
01:11:53,969 --> 01:11:59,699
this is a case where you is the writer

1201
01:11:56,250 --> 01:12:01,560
of C code have that effect if the

1202
01:11:59,699 --> 01:12:05,429
compiler will not do this for you

1203
01:12:01,560 --> 01:12:06,920
automatically question oh Jesus well

1204
01:12:05,429 --> 01:12:10,430
coming in

1205
01:12:06,920 --> 01:12:12,980
under race what's that oh but remember

1206
01:12:10,430 --> 01:12:14,840
an array I don't care about the array I

1207
01:12:12,980 --> 01:12:17,270
care about the elements of the array

1208
01:12:14,840 --> 01:12:19,010
because this is only down at the lowest

1209
01:12:17,270 --> 01:12:22,430
level where I'm accessing either a

1210
01:12:19,010 --> 01:12:24,950
single int a single double or a pointer

1211
01:12:22,430 --> 01:12:27,260
and not all the rest of the stuff

1212
01:12:24,950 --> 01:12:30,830
remember I never read an entire array

1213
01:12:27,260 --> 01:12:33,350
from memory so alignment only refers

1214
01:12:30,830 --> 01:12:38,930
down to the most the primitive types not

1215
01:12:33,350 --> 01:12:43,910
the aggregate types if this is confusing

1216
01:12:38,930 --> 01:12:45,230
the book covers this fairly carefully so

1217
01:12:43,910 --> 01:12:49,760
let me just finish up with a little

1218
01:12:45,230 --> 01:12:53,570
glimpse of floating-point floating-point

1219
01:12:49,760 --> 01:12:56,140
is a complicated history in x86 how back

1220
01:12:53,570 --> 01:12:59,090
in the really ancient days

1221
01:12:56,140 --> 01:13:02,960
there was a chip that went with the 8086

1222
01:12:59,090 --> 01:13:06,380
processor called the 8087 and at the

1223
01:13:02,960 --> 01:13:09,080
time it was a masterpiece of engineering

1224
01:13:06,380 --> 01:13:11,630
to be able to come all the hardware

1225
01:13:09,080 --> 01:13:15,830
necessary to implement full I Triple E

1226
01:13:11,630 --> 01:13:18,890
floating point on a single chip and it

1227
01:13:15,830 --> 01:13:21,350
was the first one of its type in fact it

1228
01:13:18,890 --> 01:13:23,650
was a sort of co-developed with the I

1229
01:13:21,350 --> 01:13:26,690
Triple E floating point standard itself

1230
01:13:23,650 --> 01:13:30,620
but the programming model for it is

1231
01:13:26,690 --> 01:13:33,080
horrendously awful and ugly I used to an

1232
01:13:30,620 --> 01:13:35,150
older addition to the book there were it

1233
01:13:33,080 --> 01:13:37,460
was in the first edition it was in a

1234
01:13:35,150 --> 01:13:40,100
website in the second edition and now

1235
01:13:37,460 --> 01:13:45,260
it's been expunged completely because

1236
01:13:40,100 --> 01:13:48,350
it's so awful but more recently in the

1237
01:13:45,260 --> 01:13:51,020
world of x86 they realized that to

1238
01:13:48,350 --> 01:13:52,760
support things like video and all the

1239
01:13:51,020 --> 01:13:56,420
stuff people actually do with their

1240
01:13:52,760 --> 01:13:59,300
machines they needed some more

1241
01:13:56,420 --> 01:14:02,390
horsepower in numeric processing and

1242
01:13:59,300 --> 01:14:10,270
they implemented a class of instructions

1243
01:14:02,390 --> 01:14:10,270
called SSE which stands for sim D

1244
01:14:10,600 --> 01:14:15,460
something Cindy execution anyways and

1245
01:14:14,200 --> 01:14:18,850
I'll show you in a minute what that

1246
01:14:15,460 --> 01:14:21,910
means and that's now in the more recent

1247
01:14:18,850 --> 01:14:27,040
versions of x86 has been juiced up to

1248
01:14:21,910 --> 01:14:29,560
something called a VX which but the

1249
01:14:27,040 --> 01:14:31,810
shark machines support this version of

1250
01:14:29,560 --> 01:14:33,970
what's called SSE so let me just give

1251
01:14:31,810 --> 01:14:35,650
you a feeling for that and in

1252
01:14:33,970 --> 01:14:38,770
particularly the shark machine support

1253
01:14:35,650 --> 01:14:40,720
what's called SSE version 3 and what it

1254
01:14:38,770 --> 01:14:43,030
is is that there are 16 special

1255
01:14:40,720 --> 01:14:45,610
registers distinct from the other

1256
01:14:43,030 --> 01:14:48,630
registers we've talked about before each

1257
01:14:45,610 --> 01:14:51,640
of which has 16 bytes and then there's

1258
01:14:48,630 --> 01:14:53,500
operations that can operate on those and

1259
01:14:51,640 --> 01:14:56,620
treat them in different ways so one is

1260
01:14:53,500 --> 01:15:00,570
to treat this section of register as an

1261
01:14:56,620 --> 01:15:07,410
array of sixteen cares or as eight of

1262
01:15:00,570 --> 01:15:12,070
shorts or four is or and also to support

1263
01:15:07,410 --> 01:15:14,080
a double floating-point arithmetic so

1264
01:15:12,070 --> 01:15:16,690
this stuff was certainly going on and

1265
01:15:14,080 --> 01:15:19,750
somebody had the observation that said

1266
01:15:16,690 --> 01:15:20,890
well I could just then sort of subset

1267
01:15:19,750 --> 01:15:23,620
all this and implement the

1268
01:15:20,890 --> 01:15:28,390
floating-point operations directly using

1269
01:15:23,620 --> 01:15:30,820
this SSE stuff and skip the old x87

1270
01:15:28,390 --> 01:15:33,400
stuff and so that's the way floating

1271
01:15:30,820 --> 01:15:36,880
point is now generated on say the shark

1272
01:15:33,400 --> 01:15:40,480
machines and most recent machines this

1273
01:15:36,880 --> 01:15:42,460
is a this is again an example of where

1274
01:15:40,480 --> 01:15:44,920
the world is more complicated than it

1275
01:15:42,460 --> 01:15:48,850
should have to be so for example there

1276
01:15:44,920 --> 01:15:51,160
is an instruction that says add SS so

1277
01:15:48,850 --> 01:15:55,770
add a single scalar is what that

1278
01:15:51,160 --> 01:15:55,770
notation add a single precision scalar

1279
01:15:57,449 --> 01:16:04,110
at a scaler single-precision and it

1280
01:16:01,350 --> 01:16:06,929
looks a little like the add instruction

1281
01:16:04,110 --> 01:16:11,370
the add Q instructions you've seen that

1282
01:16:06,929 --> 01:16:15,360
it it increments it adds the source to

1283
01:16:11,370 --> 01:16:18,870
the destination there's ways I can do

1284
01:16:15,360 --> 01:16:21,390
for ads in a all at the same time using

1285
01:16:18,870 --> 01:16:23,520
this is what they call Cindy execution

1286
01:16:21,390 --> 01:16:27,170
which stands for single instruction

1287
01:16:23,520 --> 01:16:30,350
multiple data one instruction the add

1288
01:16:27,170 --> 01:16:34,860
PSP since repect

1289
01:16:30,350 --> 01:16:36,989
will do will will perform that one

1290
01:16:34,860 --> 01:16:41,310
instruction will do ad with four

1291
01:16:36,989 --> 01:16:44,040
different numbers and similar you can do

1292
01:16:41,310 --> 01:16:47,219
it with double precision you can do one

1293
01:16:44,040 --> 01:16:49,830
of them you can do pet and so actually

1294
01:16:47,219 --> 01:16:52,320
the underlying and we'll see this when

1295
01:16:49,830 --> 01:16:53,910
we look at code optimizations if you

1296
01:16:52,320 --> 01:16:55,860
write codes to make use of these

1297
01:16:53,910 --> 01:16:59,219
instructions you can really boost the

1298
01:16:55,860 --> 01:17:00,660
performance of the computer but this

1299
01:16:59,219 --> 01:17:03,120
just gives you a flavor for what

1300
01:17:00,660 --> 01:17:05,130
floating-point code looks like and the

1301
01:17:03,120 --> 01:17:07,920
rules are pretty simple that just as we

1302
01:17:05,130 --> 01:17:10,440
saw before that that arguments get

1303
01:17:07,920 --> 01:17:12,870
passed in in registers while 14-point

1304
01:17:10,440 --> 01:17:16,739
arguments get passed in these xmm

1305
01:17:12,870 --> 01:17:19,469
registers x mmm 0 you don't have to

1306
01:17:16,739 --> 01:17:22,890
memorize our dir si RDX

1307
01:17:19,469 --> 01:17:25,920
there in X mmm 0 1 2 it's all very

1308
01:17:22,890 --> 01:17:28,410
logical and the return value is in X mmm

1309
01:17:25,920 --> 01:17:31,230
0 and all the registers are calling

1310
01:17:28,410 --> 01:17:33,239
callers safe there's no calling safe so

1311
01:17:31,230 --> 01:17:37,260
something like adding 2 floating point

1312
01:17:33,239 --> 01:17:41,280
numbers will just look like a single

1313
01:17:37,260 --> 01:17:45,510
floating point addition instruction same

1314
01:17:41,280 --> 01:17:48,929
with double and if you mix together code

1315
01:17:45,510 --> 01:17:51,870
that has a pointer and a floating point

1316
01:17:48,929 --> 01:17:55,230
operator the pointer will be passed in a

1317
01:17:51,870 --> 01:17:57,929
regular register RDI and this double

1318
01:17:55,230 --> 01:18:00,840
will be passed in x mm 0 so it sort of

1319
01:17:57,929 --> 01:18:04,290
as it goes through the argument list you

1320
01:18:00,840 --> 01:18:06,810
sort of in the particular order if it's

1321
01:18:04,290 --> 01:18:10,170
an integer or a pointer it's in one of

1322
01:18:06,810 --> 01:18:11,250
the our registers and if it's a floating

1323
01:18:10,170 --> 01:18:14,250
point value it's

1324
01:18:11,250 --> 01:18:16,760
one of the xmm registers and potentially

1325
01:18:14,250 --> 01:18:16,760
interleaved

1326
01:18:17,240 --> 01:18:24,780
almost done and so this is a code that

1327
01:18:21,960 --> 01:18:26,700
does this particular operation and it's

1328
01:18:24,780 --> 01:18:30,750
interesting because it's returning a

1329
01:18:26,700 --> 01:18:32,610
it's doing memory referencing so again

1330
01:18:30,750 --> 01:18:36,510
there's instructions that will read from

1331
01:18:32,610 --> 01:18:39,870
memory and copy into an XML register you

1332
01:18:36,510 --> 01:18:42,960
can add registers you can make a copy of

1333
01:18:39,870 --> 01:18:45,990
from one XML M register to another and

1334
01:18:42,960 --> 01:18:48,780
you can store results so this code looks

1335
01:18:45,990 --> 01:18:51,540
a lot like what you do in integer

1336
01:18:48,780 --> 01:18:53,360
arithmetic except it's using XML and

1337
01:18:51,540 --> 01:18:55,640
special floating-point instructions

1338
01:18:53,360 --> 01:18:59,090
rather than the ones you've seen before

1339
01:18:55,640 --> 01:19:02,100
so the basic idea of it is fairly simple

1340
01:18:59,090 --> 01:19:05,370
it gets way more complicated because

1341
01:19:02,100 --> 01:19:08,910
there are lots of instructions double

1342
01:19:05,370 --> 01:19:10,710
float on and on and on there's a special

1343
01:19:08,910 --> 01:19:13,440
instruction to do square root and all

1344
01:19:10,710 --> 01:19:15,810
this stuff and the comparison stuff is

1345
01:19:13,440 --> 01:19:20,400
really nasty and messy and hard to

1346
01:19:15,810 --> 01:19:22,680
understand and then you'll see various

1347
01:19:20,400 --> 01:19:24,060
tricks to use constant values to so it's

1348
01:19:22,680 --> 01:19:25,650
covered in the book we're not going to

1349
01:19:24,060 --> 01:19:28,650
really talk about it much in in this

1350
01:19:25,650 --> 01:19:29,910
course but the underlying the the basic

1351
01:19:28,650 --> 01:19:32,550
principles of it are fairly

1352
01:19:29,910 --> 01:19:34,760
straightforward ok that'll do us for

1353
01:19:32,550 --> 01:19:34,760
today

