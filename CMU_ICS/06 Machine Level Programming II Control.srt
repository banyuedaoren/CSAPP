1
00:00:01,010 --> 00:00:09,840
okay let's continue on in our coverage

2
00:00:05,879 --> 00:00:13,320
of machine level programming ii and i

3
00:00:09,840 --> 00:00:14,969
think a six part series as i mentioned

4
00:00:13,320 --> 00:00:17,190
yesterday machine level programming is

5
00:00:14,969 --> 00:00:19,740
sort of the core of this course that it

6
00:00:17,190 --> 00:00:22,800
gives you a set of tools and

7
00:00:19,740 --> 00:00:24,119
understanding that take you well beyond

8
00:00:22,800 --> 00:00:27,269
what years to the average

9
00:00:24,119 --> 00:00:29,130
run-of-the-mill of programmer or

10
00:00:27,269 --> 00:00:31,800
software developer would would know

11
00:00:29,130 --> 00:00:34,100
about and it's very powerful in terms of

12
00:00:31,800 --> 00:00:38,940
your better understanding of the system

13
00:00:34,100 --> 00:00:41,760
what goes wrong of why why programs

14
00:00:38,940 --> 00:00:43,140
crash what the meaning of those are and

15
00:00:41,760 --> 00:00:46,410
so it's a fairly core part of the

16
00:00:43,140 --> 00:00:50,430
material as you know the data web is due

17
00:00:46,410 --> 00:00:52,199
tonight and the next way about is called

18
00:00:50,430 --> 00:00:56,070
the bomb lab and I believe that's coming

19
00:00:52,199 --> 00:00:58,710
out tonight as well so the bomb lab will

20
00:00:56,070 --> 00:01:01,770
rely on your ability to understand

21
00:00:58,710 --> 00:01:03,660
machine level code so the these two

22
00:01:01,770 --> 00:01:05,580
lectures will actually be enough to get

23
00:01:03,660 --> 00:01:08,430
you started on some of the earlier parts

24
00:01:05,580 --> 00:01:11,340
of that lab you'll learn a lot more at

25
00:01:08,430 --> 00:01:13,710
recitation on Monday either in person or

26
00:01:11,340 --> 00:01:16,860
if you're viewing the recorded version

27
00:01:13,710 --> 00:01:19,259
of that that will help you move along on

28
00:01:16,860 --> 00:01:21,540
bomb web like all the labs in this

29
00:01:19,259 --> 00:01:23,700
course at least the first two we give

30
00:01:21,540 --> 00:01:25,439
you a fair amount of time for them but

31
00:01:23,700 --> 00:01:28,890
don't be fooled into thinking that means

32
00:01:25,439 --> 00:01:31,530
you can just slack off or work on other

33
00:01:28,890 --> 00:01:34,380
courses and then the last few moments

34
00:01:31,530 --> 00:01:36,329
jump in and finish this grab the bomb

35
00:01:34,380 --> 00:01:39,090
lab once you get the hang of what you're

36
00:01:36,329 --> 00:01:41,520
doing it's pretty of you can just kind

37
00:01:39,090 --> 00:01:45,030
of crank along but there's a certain

38
00:01:41,520 --> 00:01:47,130
learning curve that will take you to

39
00:01:45,030 --> 00:01:49,909
even get started on it effectively so

40
00:01:47,130 --> 00:01:49,909
don't put it off

41
00:01:52,480 --> 00:01:54,510
ah

42
00:01:55,930 --> 00:02:01,020
um oh is this

43
00:02:11,380 --> 00:02:15,800
so last time we introduced the very

44
00:02:14,030 --> 00:02:18,050
basic principles of machine level

45
00:02:15,800 --> 00:02:20,840
programming the idea of there being

46
00:02:18,050 --> 00:02:23,750
special states that you have access to

47
00:02:20,840 --> 00:02:26,390
the registers which people came after

48
00:02:23,750 --> 00:02:29,989
class nestor register is part of memory

49
00:02:26,390 --> 00:02:31,700
no are they part of the cache no through

50
00:02:29,989 --> 00:02:34,519
special they're different they don't

51
00:02:31,700 --> 00:02:35,780
exist to a sea level program when you're

52
00:02:34,519 --> 00:02:38,299
programming and see you don't have any

53
00:02:35,780 --> 00:02:40,580
visibility into them and in general

54
00:02:38,299 --> 00:02:43,010
today what we're going to do then is go

55
00:02:40,580 --> 00:02:44,390
beyond the sort of very basics and start

56
00:02:43,010 --> 00:02:47,420
talking about the control how you

57
00:02:44,390 --> 00:02:49,790
control the flow of execution of

58
00:02:47,420 --> 00:02:52,430
instructions in a at the machine level

59
00:02:49,790 --> 00:02:55,120
and how you use those techniques to

60
00:02:52,430 --> 00:02:58,160
implement basic constructs conditional

61
00:02:55,120 --> 00:03:00,049
statements loops and switch statements

62
00:02:58,160 --> 00:03:02,120
and then next time we'll talk about

63
00:03:00,049 --> 00:03:07,640
procedures which weren't a whole lecture

64
00:03:02,120 --> 00:03:10,700
of its own so that x86 and several

65
00:03:07,640 --> 00:03:14,780
machines of its generation have these

66
00:03:10,700 --> 00:03:16,940
curious little of one bit flags that are

67
00:03:14,780 --> 00:03:19,900
called condition codes and they're the

68
00:03:16,940 --> 00:03:25,130
basis of how conditional operations work

69
00:03:19,900 --> 00:03:26,480
so to a machine level programmer then we

70
00:03:25,130 --> 00:03:32,230
talked last time that you have

71
00:03:26,480 --> 00:03:35,930
visibility of the set of registers and a

72
00:03:32,230 --> 00:03:37,639
and the memory but you also have more

73
00:03:35,930 --> 00:03:39,530
things and this is only a partial list

74
00:03:37,639 --> 00:03:42,859
actually there's more and more stuff

75
00:03:39,530 --> 00:03:45,889
that you can add to this picture but we

76
00:03:42,859 --> 00:03:50,829
talked about in the 64-bit x86 64

77
00:03:45,889 --> 00:03:55,970
there's now 16 registers 8 of which have

78
00:03:50,829 --> 00:03:58,760
names that are historic based on old x86

79
00:03:55,970 --> 00:04:00,859
stuff and 68 of which were introduced

80
00:03:58,760 --> 00:04:04,670
and so they simply named name those are

81
00:04:00,859 --> 00:04:06,380
8 through our 15 and of these registers

82
00:04:04,670 --> 00:04:09,829
for the most part the only one that's

83
00:04:06,380 --> 00:04:11,989
really special is RSP it's the stack

84
00:04:09,829 --> 00:04:15,019
pointer it tells you where and we'll

85
00:04:11,989 --> 00:04:17,539
learn a lot more about stacks starting

86
00:04:15,019 --> 00:04:18,859
next time but it's sort of where the

87
00:04:17,539 --> 00:04:20,690
most the

88
00:04:18,859 --> 00:04:24,889
the state is that manages the execution

89
00:04:20,690 --> 00:04:26,960
of procedures and so you can't just use

90
00:04:24,889 --> 00:04:31,099
that or set it in arbitrary ways but the

91
00:04:26,960 --> 00:04:32,800
other ones you more or less come in with

92
00:04:31,099 --> 00:04:35,240
qualifications for that statement

93
00:04:32,800 --> 00:04:37,250
there's another register that they call

94
00:04:35,240 --> 00:04:42,110
the our IP which has nothing to do with

95
00:04:37,250 --> 00:04:45,379
death it means that the IP means

96
00:04:42,110 --> 00:04:48,080
instruction pointer in ia32 is called a

97
00:04:45,379 --> 00:04:51,039
IP and now it's called our IP just like

98
00:04:48,080 --> 00:04:54,560
the registries to be EAX now it's our IX

99
00:04:51,039 --> 00:04:56,629
so it all it contains is the address of

100
00:04:54,560 --> 00:05:01,370
the currently executing instruction and

101
00:04:56,629 --> 00:05:03,590
you can it's not a register that you

102
00:05:01,370 --> 00:05:05,810
access in a normal way but you actually

103
00:05:03,590 --> 00:05:08,030
there are tricks that you can find out

104
00:05:05,810 --> 00:05:11,449
what the value of that is so that just

105
00:05:08,030 --> 00:05:12,560
tells you where in the program what part

106
00:05:11,449 --> 00:05:14,780
of the program is currently being

107
00:05:12,560 --> 00:05:16,490
executed and then there's these things

108
00:05:14,780 --> 00:05:18,080
that are called condition codes and

109
00:05:16,490 --> 00:05:21,020
we're only showing four there's actually

110
00:05:18,080 --> 00:05:24,319
more like eight of them but not relevant

111
00:05:21,020 --> 00:05:27,650
to our general discussion that are all

112
00:05:24,319 --> 00:05:30,110
one bit flags and they get set not

113
00:05:27,650 --> 00:05:32,509
directly but as a side effect of other

114
00:05:30,110 --> 00:05:34,659
operations that take place and they're

115
00:05:32,509 --> 00:05:38,569
the basis for which conditional

116
00:05:34,659 --> 00:05:41,090
operation gets decided so let's go

117
00:05:38,569 --> 00:05:43,099
through what those mean and there

118
00:05:41,090 --> 00:05:44,779
they're given names but these names are

119
00:05:43,099 --> 00:05:49,159
actually useful to memorize what they

120
00:05:44,779 --> 00:05:51,349
mean so CF means the carry flag and that

121
00:05:49,159 --> 00:05:53,810
if you think of adding two numbers think

122
00:05:51,349 --> 00:05:56,509
of them as two unsigned numbers and you

123
00:05:53,810 --> 00:05:59,419
do the binary arithmetic and sometimes

124
00:05:56,509 --> 00:06:01,699
an extra one pops out of the left hand

125
00:05:59,419 --> 00:06:05,029
side right that's the carry bit if you

126
00:06:01,699 --> 00:06:10,550
the numbers you added sort of were too

127
00:06:05,029 --> 00:06:12,650
big to be contained in the the 32 or 64

128
00:06:10,550 --> 00:06:15,560
bit or even sixteen or eight that result

129
00:06:12,650 --> 00:06:19,520
and so an extra bit was generated that's

130
00:06:15,560 --> 00:06:23,240
called the carry bit the zero flag is

131
00:06:19,520 --> 00:06:25,879
what it sounds like it's set if the the

132
00:06:23,240 --> 00:06:27,169
value you just computed is zero these

133
00:06:25,879 --> 00:06:29,220
are set typically by arithmetic

134
00:06:27,169 --> 00:06:31,530
instructions by the way

135
00:06:29,220 --> 00:06:35,070
the sign flag is said if the value just

136
00:06:31,530 --> 00:06:36,930
computed as a 1 and the most significant

137
00:06:35,070 --> 00:06:42,090
bit meaning it's a negative value and

138
00:06:36,930 --> 00:06:44,850
the ole flag overflow flag is a tooth

139
00:06:42,090 --> 00:06:47,160
compliment version of overflow so in

140
00:06:44,850 --> 00:06:50,340
particular if you remember from data web

141
00:06:47,160 --> 00:06:53,340
how do you know us if addition of two

142
00:06:50,340 --> 00:06:55,500
values is overflowed it's if the signs

143
00:06:53,340 --> 00:06:56,970
of the operands are the same but the

144
00:06:55,500 --> 00:06:57,390
sign of the result is different than

145
00:06:56,970 --> 00:06:59,640
that

146
00:06:57,390 --> 00:07:02,160
so either you added two positive numbers

147
00:06:59,640 --> 00:07:04,260
and got a negative result that was a

148
00:07:02,160 --> 00:07:06,150
positive overflow or you added two

149
00:07:04,260 --> 00:07:08,520
negative numbers and got a negative

150
00:07:06,150 --> 00:07:11,160
result that's negative overflow

151
00:07:08,520 --> 00:07:15,450
you can't overflow up the two arguments

152
00:07:11,160 --> 00:07:18,180
are of opposite signs right so those

153
00:07:15,450 --> 00:07:22,230
four flags get set as the sort of normal

154
00:07:18,180 --> 00:07:25,260
activity by many of the instructions not

155
00:07:22,230 --> 00:07:27,120
by our friend the le.a instruction which

156
00:07:25,260 --> 00:07:29,640
I mentioned is kind of a quirky

157
00:07:27,120 --> 00:07:34,440
instruction that GCC really likes a lot

158
00:07:29,640 --> 00:07:36,540
and you'll see it in a lot of places but

159
00:07:34,440 --> 00:07:39,060
in general and most of the time those

160
00:07:36,540 --> 00:07:42,750
flags get completely ignored because who

161
00:07:39,060 --> 00:07:44,070
cares right a but they do show up at

162
00:07:42,750 --> 00:07:49,350
various points when you're doing

163
00:07:44,070 --> 00:07:51,840
conditional operations so there's some

164
00:07:49,350 --> 00:07:53,850
special instructions whose only effect

165
00:07:51,840 --> 00:07:55,830
is to set condition codes and the one

166
00:07:53,850 --> 00:07:59,250
that you'll see is especially it's

167
00:07:55,830 --> 00:08:01,140
called compare CMP and by the way the

168
00:07:59,250 --> 00:08:02,970
the queue at the end of these is all

169
00:08:01,140 --> 00:08:09,420
just a reflection of their operating on

170
00:08:02,970 --> 00:08:11,160
64-bit words quadword as I said so the

171
00:08:09,420 --> 00:08:14,730
comparison is sort of like a subtraction

172
00:08:11,160 --> 00:08:16,730
instruction except that you don't you

173
00:08:14,730 --> 00:08:19,680
don't do anything with the result

174
00:08:16,730 --> 00:08:23,310
normal subtraction instruction is like X

175
00:08:19,680 --> 00:08:24,990
minus equals y it will read two numbers

176
00:08:23,310 --> 00:08:29,010
but then it will store the result

177
00:08:24,990 --> 00:08:30,330
wherever X is stored but compare just

178
00:08:29,010 --> 00:08:32,790
takes these two values does a

179
00:08:30,330 --> 00:08:35,100
subtraction and doesn't do anything with

180
00:08:32,790 --> 00:08:39,140
the result but it will set it's these

181
00:08:35,100 --> 00:08:39,140
four condition flags and

182
00:08:39,950 --> 00:08:45,170
just a few things to keep in mind that

183
00:08:42,230 --> 00:08:50,210
are often will be sources of confusion

184
00:08:45,170 --> 00:08:52,280
is remember that the arguments in the

185
00:08:50,210 --> 00:08:55,580
way we write them in machine code is the

186
00:08:52,280 --> 00:08:57,530
opposite of what you'd expect by the way

187
00:08:55,580 --> 00:08:59,930
I somebody asked me last time there's

188
00:08:57,530 --> 00:09:02,630
another there's sort of two dialects of

189
00:08:59,930 --> 00:09:05,060
assembly code used on x86 machines

190
00:09:02,630 --> 00:09:08,240
there's one that's used by Intel and

191
00:09:05,060 --> 00:09:11,200
Microsoft and we don't use it and then

192
00:09:08,240 --> 00:09:13,940
there's the one use that sort of used by

193
00:09:11,200 --> 00:09:15,950
Linux systems and that's the one we use

194
00:09:13,940 --> 00:09:17,690
and they're different and one of the

195
00:09:15,950 --> 00:09:20,060
quirks of them is they write their

196
00:09:17,690 --> 00:09:22,190
arguments in in different orders so it

197
00:09:20,060 --> 00:09:24,620
will drive you crazy reading trying to

198
00:09:22,190 --> 00:09:26,690
read if you're familiar with one it's

199
00:09:24,620 --> 00:09:30,050
like if you've ever tried to drive a car

200
00:09:26,690 --> 00:09:35,090
on the wrong side of the road you often

201
00:09:30,050 --> 00:09:37,760
will crash you do bad things um so

202
00:09:35,090 --> 00:09:39,950
that's just an aside that what I find by

203
00:09:37,760 --> 00:09:43,250
the way when I'm looking at code and I

204
00:09:39,950 --> 00:09:49,430
see a compare instruction I actually

205
00:09:43,250 --> 00:09:51,770
write as a comment of compare of the two

206
00:09:49,430 --> 00:09:54,260
but I flipped the order so that I'm sure

207
00:09:51,770 --> 00:09:57,440
that I sort of keep in my mind what the

208
00:09:54,260 --> 00:09:59,390
comparison was up and so these flags get

209
00:09:57,440 --> 00:10:02,600
set according to the rules of

210
00:09:59,390 --> 00:10:04,670
subtraction and so it turns out that the

211
00:10:02,600 --> 00:10:06,680
carry flag and the overflow flag you

212
00:10:04,670 --> 00:10:08,720
have to do to flip your sense of what

213
00:10:06,680 --> 00:10:10,820
happened because it's a subtraction

214
00:10:08,720 --> 00:10:16,810
rather than addition but it's the same

215
00:10:10,820 --> 00:10:19,550
general idea so that sort of shows you

216
00:10:16,810 --> 00:10:21,410
one particular one and another

217
00:10:19,550 --> 00:10:24,680
instruction that you'll see whose only

218
00:10:21,410 --> 00:10:27,410
purpose in the world is to to set

219
00:10:24,680 --> 00:10:29,780
condition flags condition codes is the

220
00:10:27,410 --> 00:10:32,210
test instruction and this is typically

221
00:10:29,780 --> 00:10:33,560
used to compare as you think it's when

222
00:10:32,210 --> 00:10:35,690
you have two values and you want to

223
00:10:33,560 --> 00:10:37,760
compare them to each other and the test

224
00:10:35,690 --> 00:10:39,890
is if you really just have one value and

225
00:10:37,760 --> 00:10:43,040
you want to see what it's like is it

226
00:10:39,890 --> 00:10:44,600
zero is it negative those are the main

227
00:10:43,040 --> 00:10:46,790
things you care about in fact that's the

228
00:10:44,600 --> 00:10:50,630
only thing you can determine but just

229
00:10:46,790 --> 00:10:53,180
because I guess they had they had sort

230
00:10:50,630 --> 00:10:53,540
of a possibility of having two arguments

231
00:10:53,180 --> 00:10:55,430
to the

232
00:10:53,540 --> 00:10:57,560
so they decided well let's to go ahead

233
00:10:55,430 --> 00:11:00,380
and do it how do you have two arguments

234
00:10:57,560 --> 00:11:03,320
to a test instruction what's and the two

235
00:11:00,380 --> 00:11:07,160
results and then test that value so what

236
00:11:03,320 --> 00:11:11,150
you typically see is a test where both

237
00:11:07,160 --> 00:11:16,460
arguments are the same so test q % RI X

238
00:11:11,150 --> 00:11:18,980
comma % RI x where so that you're just

239
00:11:16,460 --> 00:11:21,830
any register to itself and one property

240
00:11:18,980 --> 00:11:24,980
the end operation is it's what they call

241
00:11:21,830 --> 00:11:26,690
item potent adding ending two things the

242
00:11:24,980 --> 00:11:28,990
same things together gives you that same

243
00:11:26,690 --> 00:11:28,990
time

244
00:11:30,700 --> 00:11:37,790
so we can see these and now so I told

245
00:11:36,410 --> 00:11:39,770
you that's how the condition codes get

246
00:11:37,790 --> 00:11:41,840
set now how do you actually read them

247
00:11:39,770 --> 00:11:44,180
how do you make use of them well there's

248
00:11:41,840 --> 00:11:46,640
two in principle you can actually

249
00:11:44,180 --> 00:11:49,850
extract and get the condition code

250
00:11:46,640 --> 00:11:52,100
values directly out of this special

251
00:11:49,850 --> 00:11:54,830
status register but that's very unusual

252
00:11:52,100 --> 00:11:58,160
to do that what's more common is you

253
00:11:54,830 --> 00:12:01,670
either try to read it in and set a 1-bit

254
00:11:58,160 --> 00:12:04,490
flag based on the result in a reg some

255
00:12:01,670 --> 00:12:07,490
other register or you try and do a

256
00:12:04,490 --> 00:12:10,580
conditional branch so the first example

257
00:12:07,490 --> 00:12:12,680
where you try to read it in a way that

258
00:12:10,580 --> 00:12:15,529
you can make use of it is done with the

259
00:12:12,680 --> 00:12:19,760
set instruction and you'll see there's a

260
00:12:15,529 --> 00:12:22,540
whole range of set instructions of but

261
00:12:19,760 --> 00:12:25,490
their only difference is really just

262
00:12:22,540 --> 00:12:30,230
what the condition they're setting based

263
00:12:25,490 --> 00:12:33,500
on so the what a set instruction does is

264
00:12:30,230 --> 00:12:37,820
it sets a single byte of a single

265
00:12:33,500 --> 00:12:40,730
register to either 1 or 0 and the the

266
00:12:37,820 --> 00:12:44,690
basis for whether it sets it to one or

267
00:12:40,730 --> 00:12:47,780
to zero is a based on what the condition

268
00:12:44,690 --> 00:12:50,060
codes are in essence what's the what

269
00:12:47,780 --> 00:12:51,920
happened your most recent instruction

270
00:12:50,060 --> 00:12:55,040
beforehand was it an arithmetic

271
00:12:51,920 --> 00:12:57,920
instruction or a set instruction or a

272
00:12:55,040 --> 00:13:00,260
test instruction or a compare

273
00:12:57,920 --> 00:13:03,200
instruction and as you can see there's

274
00:13:00,260 --> 00:13:05,240
they're all based on some logical

275
00:13:03,200 --> 00:13:09,490
combination of these condition codes

276
00:13:05,240 --> 00:13:14,630
that correspond to what the names imply

277
00:13:09,490 --> 00:13:17,600
so for example the set s instruction is

278
00:13:14,630 --> 00:13:19,640
true if the sign flag is true meaning

279
00:13:17,600 --> 00:13:22,670
that the most recent result was negative

280
00:13:19,640 --> 00:13:26,290
and there's other ones in less than less

281
00:13:22,670 --> 00:13:28,880
than or equal to our T's complement

282
00:13:26,290 --> 00:13:31,250
comparisons and they have to take into

283
00:13:28,880 --> 00:13:34,100
consideration did the most recent result

284
00:13:31,250 --> 00:13:37,600
cause an overflow or not because that

285
00:13:34,100 --> 00:13:40,459
will affect the result of the comparison

286
00:13:37,600 --> 00:13:42,620
so that's part of the reason we tortured

287
00:13:40,459 --> 00:13:44,450
you with understanding two's complement

288
00:13:42,620 --> 00:13:46,520
arithmetic and how you compare

289
00:13:44,450 --> 00:13:48,560
dalts and making you understand the

290
00:13:46,520 --> 00:13:51,400
bit-level behavior so that you can

291
00:13:48,560 --> 00:13:54,350
understand what these instructions do

292
00:13:51,400 --> 00:13:59,180
so we're cruel but we have a reason for

293
00:13:54,350 --> 00:14:00,830
our cruelty so you say one bite how do

294
00:13:59,180 --> 00:14:02,720
you deal with one bite well here's

295
00:14:00,830 --> 00:14:04,310
another thing we didn't tell you yet and

296
00:14:02,720 --> 00:14:06,590
we're going to keep telling you more

297
00:14:04,310 --> 00:14:09,110
stuff over and over again it turns out

298
00:14:06,590 --> 00:14:12,170
for every one of these sixteen registers

299
00:14:09,110 --> 00:14:16,250
you can directly set the lowest order

300
00:14:12,170 --> 00:14:18,080
bite of it to either 0 or 1 and it won't

301
00:14:16,250 --> 00:14:20,300
affect it turns out it doesn't affect

302
00:14:18,080 --> 00:14:23,750
any of the other 7 bites of that

303
00:14:20,300 --> 00:14:32,180
register so and they all have Corky

304
00:14:23,750 --> 00:14:35,300
names the L means below in there so

305
00:14:32,180 --> 00:14:36,710
here's an example of using putting all

306
00:14:35,300 --> 00:14:41,930
this together to do something that

307
00:14:36,710 --> 00:14:44,330
vaguely useful suppose that I want a

308
00:14:41,930 --> 00:14:47,720
function GT that will take two numbers

309
00:14:44,330 --> 00:14:50,750
and compare them and set the result

310
00:14:47,720 --> 00:14:54,370
return result value of 1 if X is greater

311
00:14:50,750 --> 00:14:57,770
than Y and 0 otherwise

312
00:14:54,370 --> 00:15:01,570
and so here's the assembly code with

313
00:14:57,770 --> 00:15:01,570
some tabbing problems

314
00:15:03,320 --> 00:15:08,680
success getting bugs me or that

315
00:15:13,250 --> 00:15:16,810
I might not want to try and do this

316
00:15:27,960 --> 00:15:42,180
Oh No I will fix this later anyways it's

317
00:15:34,860 --> 00:15:43,800
not the end of the world normally an

318
00:15:42,180 --> 00:15:46,170
assembly code one thing you've noticed

319
00:15:43,800 --> 00:15:50,220
is that the instructions are indented

320
00:15:46,170 --> 00:15:52,440
via tab space and the only thing that's

321
00:15:50,220 --> 00:15:56,760
way over in the left margin or label so

322
00:15:52,440 --> 00:15:58,550
this is just sort of this what the the

323
00:15:56,760 --> 00:16:00,660
assembler is actually quite tolerant of

324
00:15:58,550 --> 00:16:03,810
formatting things but this isn't the way

325
00:16:00,660 --> 00:16:06,899
it normally looks so anyways the point

326
00:16:03,810 --> 00:16:09,420
is there's a comparing the one rule that

327
00:16:06,899 --> 00:16:11,820
you need to understand about procedure

328
00:16:09,420 --> 00:16:13,260
is isn't so the first argument is passed

329
00:16:11,820 --> 00:16:16,230
in register RDI

330
00:16:13,260 --> 00:16:18,029
and the second and register RS I and

331
00:16:16,230 --> 00:16:20,730
that if I'm going to return a result

332
00:16:18,029 --> 00:16:24,600
from a function I do that by storing it

333
00:16:20,730 --> 00:16:28,080
and register our ax before I return so

334
00:16:24,600 --> 00:16:30,750
the first instruction compares these two

335
00:16:28,080 --> 00:16:35,130
and you notice how I flip the order that

336
00:16:30,750 --> 00:16:38,850
it says RSI which is why an RD I which

337
00:16:35,130 --> 00:16:41,670
is X but when I annotate it I say X to Y

338
00:16:38,850 --> 00:16:43,500
so that I mentally am thinking in the

339
00:16:41,670 --> 00:16:46,260
order that the actual comparison is made

340
00:16:43,500 --> 00:16:48,150
rather than the way they're listed so I

341
00:16:46,260 --> 00:16:52,830
always do that when I'm looking at code

342
00:16:48,150 --> 00:16:54,660
to help me flip those two around and

343
00:16:52,830 --> 00:16:56,670
then here's our instruction so that

344
00:16:54,660 --> 00:16:59,010
compare instruction set these four

345
00:16:56,670 --> 00:17:02,250
condition code register x' and now the

346
00:16:59,010 --> 00:17:05,850
set G says now set this single byte

347
00:17:02,250 --> 00:17:09,750
register the lowest byte of our ax to Z

348
00:17:05,850 --> 00:17:13,880
1 if the reason the result was the

349
00:17:09,750 --> 00:17:17,809
comparison was greater so according to

350
00:17:13,880 --> 00:17:17,809
this this rule

351
00:17:17,870 --> 00:17:26,520
and and the effect of that was to set

352
00:17:22,890 --> 00:17:29,280
just as one bite of this eight byte

353
00:17:26,520 --> 00:17:32,310
register to either zero or one now my

354
00:17:29,280 --> 00:17:34,110
problem is that these remaining seven

355
00:17:32,310 --> 00:17:37,770
bytes have whatever happened to be there

356
00:17:34,110 --> 00:17:42,710
before and I want it to be all zeros so

357
00:17:37,770 --> 00:17:45,870
the the way it does it is a bit weird

358
00:17:42,710 --> 00:17:51,120
there's an instruction called move with

359
00:17:45,870 --> 00:17:54,270
zero extension byte too long now you get

360
00:17:51,120 --> 00:17:58,980
to know these better if with time okay

361
00:17:54,270 --> 00:18:02,010
um and what what that means is you can

362
00:17:58,980 --> 00:18:03,330
actually copy a byte from any place like

363
00:18:02,010 --> 00:18:06,930
the low order byte of some other

364
00:18:03,330 --> 00:18:09,570
register into a new register and you'll

365
00:18:06,930 --> 00:18:12,690
put put zeros to the left of it that's

366
00:18:09,570 --> 00:18:14,640
what they mean by zero extension that

367
00:18:12,690 --> 00:18:17,840
seems logical but one thing you'll

368
00:18:14,640 --> 00:18:20,760
notice is the destination here is EAX

369
00:18:17,840 --> 00:18:24,000
which you'll recall although it doesn't

370
00:18:20,760 --> 00:18:28,440
show here that's the lower 32 bits of

371
00:18:24,000 --> 00:18:32,700
register are a X and then you'd say well

372
00:18:28,440 --> 00:18:35,280
that only got me halfway there right how

373
00:18:32,700 --> 00:18:38,480
do I make sure the upper 32 bits are set

374
00:18:35,280 --> 00:18:45,840
to zero well one of the weird quirks of

375
00:18:38,480 --> 00:18:50,100
x86 64 is for any computation where the

376
00:18:45,840 --> 00:18:53,010
result is a 32-bit result it will add

377
00:18:50,100 --> 00:18:56,580
zeros to the remaining 32 bits of the

378
00:18:53,010 --> 00:18:58,710
register and it's different for example

379
00:18:56,580 --> 00:19:03,830
the byte level operations only affect

380
00:18:58,710 --> 00:19:06,510
the bikes the two byte or operations

381
00:19:03,830 --> 00:19:08,880
like what you'd have if the data type

382
00:19:06,510 --> 00:19:12,000
were short only affect those two bytes

383
00:19:08,880 --> 00:19:14,870
but the four byte instructions set the

384
00:19:12,000 --> 00:19:17,910
upper bytes to zero and that was some

385
00:19:14,870 --> 00:19:20,730
somebody at AMD and I don't know who it

386
00:19:17,910 --> 00:19:22,710
is decided this was a good idea and it

387
00:19:20,730 --> 00:19:25,740
might be a good idea but it's really

388
00:19:22,710 --> 00:19:28,260
confusing but that's something you'll

389
00:19:25,740 --> 00:19:30,030
have to just sort of remember in the

390
00:19:28,260 --> 00:19:31,150
back your mind when you see things like

391
00:19:30,030 --> 00:19:33,580
this

392
00:19:31,150 --> 00:19:35,530
so the effect of this instruction is to

393
00:19:33,580 --> 00:19:39,100
take this one bite result which is the

394
00:19:35,530 --> 00:19:41,740
lower door bite of register our ax copy

395
00:19:39,100 --> 00:19:44,470
it to the same place as it already is

396
00:19:41,740 --> 00:19:48,520
but then set the remaining seven bytes

397
00:19:44,470 --> 00:19:55,000
to zero which is what we want so you'll

398
00:19:48,520 --> 00:19:55,830
see this pattern quite often question

399
00:19:55,000 --> 00:19:59,710
got it

400
00:19:55,830 --> 00:20:02,290
okay so now that's sort of sometimes I

401
00:19:59,710 --> 00:20:05,190
want to do this I just want to get a one

402
00:20:02,290 --> 00:20:08,559
bit flag as a result of the comparison

403
00:20:05,190 --> 00:20:10,510
but more generally I want to do

404
00:20:08,559 --> 00:20:14,260
something with that information and not

405
00:20:10,510 --> 00:20:17,800
just set one bit so the simplest version

406
00:20:14,260 --> 00:20:22,420
is what about a conditional and if and

407
00:20:17,800 --> 00:20:25,179
possibly an else well that's done by

408
00:20:22,420 --> 00:20:27,340
this actually two ways to do it so we'll

409
00:20:25,179 --> 00:20:30,309
go through the sort of general purpose

410
00:20:27,340 --> 00:20:33,340
traditional way and then we'll show the

411
00:20:30,309 --> 00:20:35,530
more specialized newer way and we'll

412
00:20:33,340 --> 00:20:37,480
compare those so the traditional way is

413
00:20:35,530 --> 00:20:39,370
to use what's known as a jump

414
00:20:37,480 --> 00:20:42,130
instruction and a jump instruction

415
00:20:39,370 --> 00:20:44,470
normally instructions execute in a

416
00:20:42,130 --> 00:20:46,809
particular order just like when you're

417
00:20:44,470 --> 00:20:49,660
writing a program and you write a series

418
00:20:46,809 --> 00:20:52,450
of statements they execute one after the

419
00:20:49,660 --> 00:20:54,220
next a jump instruction is the way you

420
00:20:52,450 --> 00:20:57,040
can go from wherever you are to

421
00:20:54,220 --> 00:20:59,470
someplace else and either skip over some

422
00:20:57,040 --> 00:21:03,429
instructions or jump back to some other

423
00:20:59,470 --> 00:21:06,540
a previous position or wherever and

424
00:21:03,429 --> 00:21:08,140
there's two kinds of jumps ones that are

425
00:21:06,540 --> 00:21:10,870
unconditional where there's several

426
00:21:08,140 --> 00:21:13,750
kinds but an unconditional jump means

427
00:21:10,870 --> 00:21:15,550
when I say jump you jump but there's

428
00:21:13,750 --> 00:21:17,980
others conditional jumps that will

429
00:21:15,550 --> 00:21:19,480
actually only do that jumping if the

430
00:21:17,980 --> 00:21:21,910
condition codes are set appropriately

431
00:21:19,480 --> 00:21:23,920
and you'll see that the names of these

432
00:21:21,910 --> 00:21:25,480
jump instructions are the same as the

433
00:21:23,920 --> 00:21:27,970
set instructions with the same

434
00:21:25,480 --> 00:21:31,120
conditions so there's a variety of

435
00:21:27,970 --> 00:21:34,920
different reasons that the program may

436
00:21:31,120 --> 00:21:34,920
be given to either jump or not jump

437
00:21:37,640 --> 00:21:42,860
so I'm going to use this one example to

438
00:21:40,820 --> 00:21:46,850
show you several different versions of

439
00:21:42,860 --> 00:21:48,530
it and like everything you'll see here

440
00:21:46,850 --> 00:21:52,250
these particular programs aren't that

441
00:21:48,530 --> 00:21:57,410
useful but they illustrate ideas so

442
00:21:52,250 --> 00:21:59,720
imagine I wanted to compute the the

443
00:21:57,410 --> 00:22:03,170
difference of two values and then take

444
00:21:59,720 --> 00:22:04,520
their absolute value so there's various

445
00:22:03,170 --> 00:22:06,020
ways you could imagine doing it by the

446
00:22:04,520 --> 00:22:09,080
way I'm going to do it is decide to

447
00:22:06,020 --> 00:22:11,330
either subtract Y from X or X from Y

448
00:22:09,080 --> 00:22:14,090
depending on the relative values of

449
00:22:11,330 --> 00:22:17,960
those two and of course the astute

450
00:22:14,090 --> 00:22:20,740
observer will notice that this has

451
00:22:17,960 --> 00:22:24,020
problems if you have a team in somewhere

452
00:22:20,740 --> 00:22:25,490
if the result because there's no

453
00:22:24,020 --> 00:22:30,559
absolute value but we're not going to

454
00:22:25,490 --> 00:22:32,510
worry about that table so in other words

455
00:22:30,559 --> 00:22:35,480
I just want to say if X is greater than

456
00:22:32,510 --> 00:22:37,309
Y then I wanted to track Y from X and if

457
00:22:35,480 --> 00:22:40,400
X is less than or equal to Y I want to

458
00:22:37,309 --> 00:22:42,860
subtract X from 1 and here's the code

459
00:22:40,400 --> 00:22:44,770
for it where the blue and the red or

460
00:22:42,860 --> 00:22:49,370
color coding the different parts of it

461
00:22:44,770 --> 00:22:53,780
so here you see the compare instruction

462
00:22:49,370 --> 00:22:56,390
and again I've written them out in the

463
00:22:53,780 --> 00:22:59,330
reverse order to help me keep track of

464
00:22:56,390 --> 00:23:02,120
what the comparison is and it says I'm

465
00:22:59,330 --> 00:23:04,490
going to compare x and y and if X is

466
00:23:02,120 --> 00:23:08,510
less than or equal to Y I want to jump

467
00:23:04,490 --> 00:23:11,630
to a location specified by this label l4

468
00:23:08,510 --> 00:23:14,179
and so in general in assembly code if

469
00:23:11,630 --> 00:23:16,880
you give a name and then a colon what's

470
00:23:14,179 --> 00:23:20,179
to the left of that is called a label

471
00:23:16,880 --> 00:23:22,040
and it's just a tag that that only

472
00:23:20,179 --> 00:23:24,830
visible in the assembly code it's not

473
00:23:22,040 --> 00:23:28,120
actually in the object code that will

474
00:23:24,830 --> 00:23:32,330
later I'll be used to compute an address

475
00:23:28,120 --> 00:23:35,600
for determining that will encode what

476
00:23:32,330 --> 00:23:37,130
where this jump will actually land when

477
00:23:35,600 --> 00:23:39,559
you're looking at assembly code one of

478
00:23:37,130 --> 00:23:42,740
the features it provides is a little bit

479
00:23:39,559 --> 00:23:45,800
easier way to understand it than to look

480
00:23:42,740 --> 00:23:48,020
at addresses and so it just tells you to

481
00:23:45,800 --> 00:23:49,629
be looking at that the jump would occur

482
00:23:48,020 --> 00:23:54,529
to this position

483
00:23:49,629 --> 00:23:56,629
and what you'll see here is the in these

484
00:23:54,529 --> 00:23:58,279
two branches the blue code versus the

485
00:23:56,629 --> 00:24:03,950
red what you're doing is in one case

486
00:23:58,279 --> 00:24:08,029
subtracting Y from X here you move X

487
00:24:03,950 --> 00:24:10,100
into our ax and you subtract Y from it

488
00:24:08,029 --> 00:24:17,840
and here you do the opposite you're

489
00:24:10,100 --> 00:24:21,110
subtracting X from Y and in this case so

490
00:24:17,840 --> 00:24:23,779
in the first case you'll make the jump

491
00:24:21,110 --> 00:24:27,109
if X is less than or equal to Y you'll

492
00:24:23,779 --> 00:24:29,629
compact Y from X and you'll do a return

493
00:24:27,109 --> 00:24:32,090
and you remember that I don't have to do

494
00:24:29,629 --> 00:24:34,279
anything special to return a value back

495
00:24:32,090 --> 00:24:37,309
from a function all I have to do is

496
00:24:34,279 --> 00:24:38,929
stick it and register IX and the calling

497
00:24:37,309 --> 00:24:42,409
function will know that's where to find

498
00:24:38,929 --> 00:24:44,840
the return value so here it does a rep

499
00:24:42,409 --> 00:24:46,970
and here it does the subtraction and it

500
00:24:44,840 --> 00:24:52,279
simply does a return directly from that

501
00:24:46,970 --> 00:24:53,749
part of it so it's a pretty

502
00:24:52,279 --> 00:24:56,330
straightforward piece of code but you

503
00:24:53,749 --> 00:24:59,389
can see it's using this jumping to

504
00:24:56,330 --> 00:25:01,970
create two different parts of code that

505
00:24:59,389 --> 00:25:05,440
get executed under two different

506
00:25:01,970 --> 00:25:05,440
conditions question

507
00:25:06,770 --> 00:25:16,399
what's that I'm sorry I didn't hear you

508
00:25:11,450 --> 00:25:18,760
oh well there's a couple things one is

509
00:25:16,399 --> 00:25:22,070
you want the result to end up in our X

510
00:25:18,760 --> 00:25:24,799
right and remember the subtract

511
00:25:22,070 --> 00:25:29,809
instruction structions are just two

512
00:25:24,799 --> 00:25:32,330
argument instructions there that you

513
00:25:29,809 --> 00:25:34,640
take two values and then you the ones

514
00:25:32,330 --> 00:25:36,950
the second argument the destination

515
00:25:34,640 --> 00:25:39,679
argument you overwrite what was there

516
00:25:36,950 --> 00:25:42,710
with the new result so this is a pretty

517
00:25:39,679 --> 00:25:46,340
typical pattern you'll see of you move

518
00:25:42,710 --> 00:25:49,159
some value into a register and then you

519
00:25:46,340 --> 00:25:51,740
into our ax is very common and then you

520
00:25:49,159 --> 00:25:54,860
do some arithmetic operation with that

521
00:25:51,740 --> 00:25:58,309
register as a destination to kind of

522
00:25:54,860 --> 00:26:00,020
update it if it's like if you were

523
00:25:58,309 --> 00:26:02,870
writing and see if all the time you had

524
00:26:00,020 --> 00:26:06,409
to write sort of X plus equals something

525
00:26:02,870 --> 00:26:08,149
X minus equals and that all your

526
00:26:06,409 --> 00:26:10,450
arithmetic had to be expressed in those

527
00:26:08,149 --> 00:26:10,450
terms

528
00:26:12,750 --> 00:26:20,429
okay so it's fun to look at assembly

529
00:26:17,490 --> 00:26:24,150
code for about five minutes and then you

530
00:26:20,429 --> 00:26:26,370
get sick of it so one thing to sort of

531
00:26:24,150 --> 00:26:29,850
present these same ideas but give it in

532
00:26:26,370 --> 00:26:33,179
a little bit more abstract form is to

533
00:26:29,850 --> 00:26:35,640
write it and see but in a form of C that

534
00:26:33,179 --> 00:26:38,250
looks a lot like assembly code and in

535
00:26:35,640 --> 00:26:42,020
particular one of the features of C that

536
00:26:38,250 --> 00:26:45,990
is not generally advertised is there's a

537
00:26:42,020 --> 00:26:54,419
statement called go-to and you can put

538
00:26:45,990 --> 00:26:56,490
labels in your code and you can tell the

539
00:26:54,419 --> 00:26:58,530
program that if something happens then

540
00:26:56,490 --> 00:27:00,840
you want to jump to that part of the

541
00:26:58,530 --> 00:27:04,530
program so it looks a lot like that

542
00:27:00,840 --> 00:27:09,150
assembly code right that you saw jump jl

543
00:27:04,530 --> 00:27:12,020
e instead of what this says it's like

544
00:27:09,150 --> 00:27:14,400
i'm doing a test and then if the test is

545
00:27:12,020 --> 00:27:16,230
which in this case i call it end test

546
00:27:14,400 --> 00:27:19,830
because it's the opposite of the test

547
00:27:16,230 --> 00:27:22,140
that's in the original program and if

548
00:27:19,830 --> 00:27:24,059
that end test condition holds i want to

549
00:27:22,140 --> 00:27:27,150
jump to another part of the program i'm

550
00:27:24,059 --> 00:27:29,159
calling else and you notice i uppercase

551
00:27:27,150 --> 00:27:34,500
that because it's not the actual else of

552
00:27:29,159 --> 00:27:39,450
a an if-then-else and certainly if this

553
00:27:34,500 --> 00:27:41,429
one is well actually to be most accurate

554
00:27:39,450 --> 00:27:44,970
i should have simply said return result

555
00:27:41,429 --> 00:27:48,000
from this point this codes a little bit

556
00:27:44,970 --> 00:27:50,580
out of date so I should have said return

557
00:27:48,000 --> 00:27:52,650
result but another version would be to

558
00:27:50,580 --> 00:27:54,780
have done a goto down to here and return

559
00:27:52,650 --> 00:27:56,190
the result from there and you'll see

560
00:27:54,780 --> 00:27:59,640
different compilers generate in

561
00:27:56,190 --> 00:28:01,470
different forms so I'm going to

562
00:27:59,640 --> 00:28:04,890
typically use this way of presenting

563
00:28:01,470 --> 00:28:07,380
code just so that you can look at and

564
00:28:04,890 --> 00:28:09,720
understand what these control structures

565
00:28:07,380 --> 00:28:12,630
look like without having to sort of

566
00:28:09,720 --> 00:28:15,470
scrutinize the low-level assembly code

567
00:28:12,630 --> 00:28:15,470
instructions

568
00:28:16,130 --> 00:28:28,740
so we consider take this question yes I

569
00:28:27,120 --> 00:28:30,840
think there's a homework or practice

570
00:28:28,740 --> 00:28:33,210
problems of exactly that sort so in

571
00:28:30,840 --> 00:28:35,310
general you could do it neither way and

572
00:28:33,210 --> 00:28:36,900
why the compiler picks one versus the

573
00:28:35,310 --> 00:28:39,750
other is I think it's a completely

574
00:28:36,900 --> 00:28:43,370
arbitrary decision but consistently I

575
00:28:39,750 --> 00:28:43,370
found GCC does it this way

576
00:28:44,780 --> 00:28:52,380
okay so what sort of talking sort of

577
00:28:50,160 --> 00:28:55,230
imagine you're writing a compiler how

578
00:28:52,380 --> 00:28:58,010
would you take this special case I just

579
00:28:55,230 --> 00:29:02,250
showed and generalize it into a rule for

580
00:28:58,010 --> 00:29:05,610
compiling if-then-else expressions and

581
00:29:02,250 --> 00:29:07,770
I'm going to use the version of in see

582
00:29:05,610 --> 00:29:09,600
the question mark : version where you

583
00:29:07,770 --> 00:29:11,630
kind of encapsulate that whole

584
00:29:09,600 --> 00:29:14,610
conditional is a single expression

585
00:29:11,630 --> 00:29:16,800
rather than the statement but you can

586
00:29:14,610 --> 00:29:19,500
understand that these rules would be the

587
00:29:16,800 --> 00:29:23,310
same in either case so imagine in

588
00:29:19,500 --> 00:29:26,550
general you had a C code where there's a

589
00:29:23,310 --> 00:29:29,900
test controlling whether to return the

590
00:29:26,550 --> 00:29:33,600
result of one expression or another and

591
00:29:29,900 --> 00:29:37,950
this is what my ABS diff code would look

592
00:29:33,600 --> 00:29:42,000
like if I wrote it in that form and so

593
00:29:37,950 --> 00:29:44,970
in general what we can say is what what

594
00:29:42,000 --> 00:29:48,510
we'll do is we'll come take the test and

595
00:29:44,970 --> 00:29:58,200
tit and invert it and say if that test

596
00:29:48,510 --> 00:30:01,260
is not true then we will so if n test is

597
00:29:58,200 --> 00:30:03,090
true then we will jump to some part of

598
00:30:01,260 --> 00:30:06,900
the code where we've compiled the code

599
00:30:03,090 --> 00:30:10,140
for the else expression and if the that

600
00:30:06,900 --> 00:30:13,200
test fails here so that the original

601
00:30:10,140 --> 00:30:17,520
test condition holds then we'll stick in

602
00:30:13,200 --> 00:30:19,890
whatever code it takes to to compute the

603
00:30:17,520 --> 00:30:22,260
done expression and then we'll merge

604
00:30:19,890 --> 00:30:24,450
back together in the case you saw where

605
00:30:22,260 --> 00:30:26,430
it's just a single little function we

606
00:30:24,450 --> 00:30:29,370
can just call a rep here and get out of

607
00:30:26,430 --> 00:30:29,940
the thing but if this is one line of

608
00:30:29,370 --> 00:30:31,110
code

609
00:30:29,940 --> 00:30:33,480
then there's a whole bunch of lines

610
00:30:31,110 --> 00:30:35,490
after that typically you want to merge

611
00:30:33,480 --> 00:30:37,649
back together again and continue from

612
00:30:35,490 --> 00:30:41,309
there and so that's what this shows all

613
00:30:37,649 --> 00:30:45,059
I'll finish by going to whatever comes

614
00:30:41,309 --> 00:30:47,159
afterwards so this is a way I like to

615
00:30:45,059 --> 00:30:48,960
you know although we're not writing

616
00:30:47,159 --> 00:30:51,720
compilers in this course I think it

617
00:30:48,960 --> 00:30:54,360
helps to to think in terms of general

618
00:30:51,720 --> 00:30:58,110
rules of how a compiler would translate

619
00:30:54,360 --> 00:30:59,519
C code into assembly code so that when

620
00:30:58,110 --> 00:31:01,830
you see that assembly code you'll

621
00:30:59,519 --> 00:31:04,649
recognize these patterns and know what

622
00:31:01,830 --> 00:31:06,450
they mean question so after you go to

623
00:31:04,649 --> 00:31:11,730
the else clause doesn't like fall

624
00:31:06,450 --> 00:31:15,539
through to the John yes yes so just as

625
00:31:11,730 --> 00:31:18,570
we saw yes in general it like here it

626
00:31:15,539 --> 00:31:20,960
would fall through to the done good

627
00:31:18,570 --> 00:31:20,960
question

628
00:31:22,610 --> 00:31:27,510
okay so that's one version of

629
00:31:25,110 --> 00:31:29,900
conditional that's the most general way

630
00:31:27,510 --> 00:31:33,420
and the way it used to always be done

631
00:31:29,900 --> 00:31:35,430
but there's another approach that you'll

632
00:31:33,420 --> 00:31:38,600
see fairly common in code it's sort of

633
00:31:35,430 --> 00:31:42,120
an optimization called conditional move

634
00:31:38,600 --> 00:31:44,130
and it's bit non-intuitive from a

635
00:31:42,120 --> 00:31:46,380
software developers perspective of why

636
00:31:44,130 --> 00:31:48,420
you'd ever want to do this the basic

637
00:31:46,380 --> 00:31:50,790
idea is I'm going to compute both the

638
00:31:48,420 --> 00:31:53,430
then and the elks the values they'd

639
00:31:50,790 --> 00:31:54,600
produce and only after that I choose

640
00:31:53,430 --> 00:31:56,970
which one I use

641
00:31:54,600 --> 00:32:01,110
so it seems wasteful but it actually

642
00:31:56,970 --> 00:32:03,660
turns out to be more efficient if there

643
00:32:01,110 --> 00:32:05,880
are fairly simple computations and the

644
00:32:03,660 --> 00:32:07,710
reason of that is and we'll see a little

645
00:32:05,880 --> 00:32:10,740
bit more when we talk about performance

646
00:32:07,710 --> 00:32:14,430
optimization a modern processor is a

647
00:32:10,740 --> 00:32:18,000
little like a an oil tanker sailing in

648
00:32:14,430 --> 00:32:21,060
the sea meaning that it plows along in a

649
00:32:18,000 --> 00:32:25,530
certain direction and it really is hard

650
00:32:21,060 --> 00:32:28,500
to get it to stop or to turn so that you

651
00:32:25,530 --> 00:32:31,710
say what are you talking about but think

652
00:32:28,500 --> 00:32:34,140
of an instruction sequences you know the

653
00:32:31,710 --> 00:32:36,840
ocean of code that you're cruising

654
00:32:34,140 --> 00:32:38,850
through and these things can just fly

655
00:32:36,840 --> 00:32:42,330
through a straight sequence of code

656
00:32:38,850 --> 00:32:44,340
because they are they do what they call

657
00:32:42,330 --> 00:32:46,080
pipelining meaning they start bringing

658
00:32:44,340 --> 00:32:48,300
in parts of one instruction before

659
00:32:46,080 --> 00:32:50,400
they're done with the next and actually

660
00:32:48,300 --> 00:32:53,430
go up to depths of 20 or more

661
00:32:50,400 --> 00:32:56,310
instructions deep of how far had they're

662
00:32:53,430 --> 00:32:58,680
working to defecting forward and future

663
00:32:56,310 --> 00:33:01,080
instructions while finishing up the ones

664
00:32:58,680 --> 00:33:04,920
that still remain so that's my ocean

665
00:33:01,080 --> 00:33:06,840
line of my tanker analogy but all of a

666
00:33:04,920 --> 00:33:09,720
sudden you come and then what happens

667
00:33:06,840 --> 00:33:12,780
when they hit a branch they'll try to

668
00:33:09,720 --> 00:33:15,270
guess called branch prediction and guess

669
00:33:12,780 --> 00:33:16,740
where is this kind of branch going to go

670
00:33:15,270 --> 00:33:17,910
where you know

671
00:33:16,740 --> 00:33:19,740
well the conditional branch should be

672
00:33:17,910 --> 00:33:21,660
taken or is it going to fall through and

673
00:33:19,740 --> 00:33:24,360
they're pretty good at that they're good

674
00:33:21,660 --> 00:33:28,890
at it ninety ninety eight percent of the

675
00:33:24,360 --> 00:33:31,650
time so they can even anticipate suit it

676
00:33:28,890 --> 00:33:33,180
curves in the road my analogy is

677
00:33:31,650 --> 00:33:37,500
breaking down

678
00:33:33,180 --> 00:33:38,880
and start going in that direction and as

679
00:33:37,500 --> 00:33:41,700
long as they get it right it's very

680
00:33:38,880 --> 00:33:45,240
efficient but if they get it wrong it's

681
00:33:41,700 --> 00:33:48,420
as if you have to stop the thing back it

682
00:33:45,240 --> 00:33:51,510
up turn the other way start again and

683
00:33:48,420 --> 00:33:55,980
that can take 40 instructions 40 clock

684
00:33:51,510 --> 00:33:57,630
cycles so to do in bed situation so and

685
00:33:55,980 --> 00:34:00,300
this is pretty common if you think of

686
00:33:57,630 --> 00:34:02,610
like an absolute value can you predict

687
00:34:00,300 --> 00:34:06,750
whether a value is going to be positive

688
00:34:02,610 --> 00:34:08,340
or negative if not usually so about half

689
00:34:06,750 --> 00:34:11,370
the time whatever you guess you're going

690
00:34:08,340 --> 00:34:13,830
to guess wrong so these are conditional

691
00:34:11,370 --> 00:34:17,220
move instructions it turns out it's much

692
00:34:13,830 --> 00:34:19,050
easier to just plow through compute both

693
00:34:17,220 --> 00:34:22,530
and then at the last minute all you have

694
00:34:19,050 --> 00:34:24,600
to do is move a value into a register or

695
00:34:22,530 --> 00:34:26,909
not and that doesn't require stopping

696
00:34:24,600 --> 00:34:32,340
the whole processor and making this turn

697
00:34:26,909 --> 00:34:34,169
so that's my long explanation for and if

698
00:34:32,340 --> 00:34:35,909
you don't want to understand that I'll

699
00:34:34,169 --> 00:34:42,000
just say well just trust me it's a good

700
00:34:35,909 --> 00:34:45,510
idea sometimes so the the general

701
00:34:42,000 --> 00:34:47,850
pattern then if I use the same idea is I

702
00:34:45,510 --> 00:34:50,970
want to compute both results and I'll

703
00:34:47,850 --> 00:34:54,389
call the result and this is an eval this

704
00:34:50,970 --> 00:34:57,510
is eval the elks value I'll compute both

705
00:34:54,389 --> 00:35:00,060
of them I'll do my test and then this

706
00:34:57,510 --> 00:35:03,390
red thing imagine that's all done with a

707
00:35:00,060 --> 00:35:06,840
single instruction that says I'll copy

708
00:35:03,390 --> 00:35:09,240
the value of eval to result but only if

709
00:35:06,840 --> 00:35:13,260
a condition holds so that's why it's

710
00:35:09,240 --> 00:35:16,290
called a conditional move then we'll see

711
00:35:13,260 --> 00:35:18,270
this is the code by the way you saw my

712
00:35:16,290 --> 00:35:22,770
original version starting to have to

713
00:35:18,270 --> 00:35:26,550
jump back I had to explicitly tell the

714
00:35:22,770 --> 00:35:29,430
GCC don't put use conditional moves

715
00:35:26,550 --> 00:35:33,060
because it really wants to very badly

716
00:35:29,430 --> 00:35:35,930
and so you have to force it not to and I

717
00:35:33,060 --> 00:35:35,930
did that here

718
00:35:36,990 --> 00:35:42,480
so here's the actual code then and again

719
00:35:39,599 --> 00:35:46,260
you'll see the color coding that it's

720
00:35:42,480 --> 00:35:48,780
doing both subtractions it's actually

721
00:35:46,260 --> 00:35:51,599
doing the move and subtract move and

722
00:35:48,780 --> 00:35:53,609
subtract so it's doing both the branches

723
00:35:51,599 --> 00:35:58,050
you saw before the den and the Elks

724
00:35:53,609 --> 00:35:59,910
branch it's doing a comparison and then

725
00:35:58,050 --> 00:36:03,599
here is the conditional move instruction

726
00:35:59,910 --> 00:36:06,150
C move in this case the L here is not a

727
00:36:03,599 --> 00:36:12,810
word size it's the less than or equal to

728
00:36:06,150 --> 00:36:16,020
a direction so in the case the that I

729
00:36:12,810 --> 00:36:19,400
need the red value basically you saw the

730
00:36:16,020 --> 00:36:22,410
red value is stored in register RDX in

731
00:36:19,400 --> 00:36:26,869
that case I will copy it into the result

732
00:36:22,410 --> 00:36:29,849
register so again it's like this idea of

733
00:36:26,869 --> 00:36:32,070
just go ahead and do everything and then

734
00:36:29,849 --> 00:36:34,560
pick at the last end and the point is

735
00:36:32,070 --> 00:36:39,210
that this one instruction it looks just

736
00:36:34,560 --> 00:36:41,099
as far as for this processor execution

737
00:36:39,210 --> 00:36:44,630
that's sort of like a a move instruction

738
00:36:41,099 --> 00:36:44,630
that it's fairly straightforward to do

739
00:36:47,050 --> 00:36:50,210
okay

740
00:36:48,230 --> 00:36:52,880
so why does it do that all the time well

741
00:36:50,210 --> 00:36:56,330
there's a couple reasons one is that

742
00:36:52,880 --> 00:36:59,060
might be a really really bad idea to do

743
00:36:56,330 --> 00:37:02,030
both computations if you have to like

744
00:36:59,060 --> 00:37:03,770
crack a password in one and you know

745
00:37:02,030 --> 00:37:05,630
find the enterprise number and another

746
00:37:03,770 --> 00:37:11,870
you probably don't want to do both of

747
00:37:05,630 --> 00:37:14,270
those so in general in that case and so

748
00:37:11,870 --> 00:37:16,730
the and you'll notice GCC will only do

749
00:37:14,270 --> 00:37:18,830
this if both branches are fairly

750
00:37:16,730 --> 00:37:21,500
straightforward computations that

751
00:37:18,830 --> 00:37:24,590
they're trying to do and they sometimes

752
00:37:21,500 --> 00:37:26,540
when you just plain can't do it so for

753
00:37:24,590 --> 00:37:29,720
example if you're using a conditional to

754
00:37:26,540 --> 00:37:31,580
guard whether a pointer can be

755
00:37:29,720 --> 00:37:33,890
dereferenced or not because it's a null

756
00:37:31,580 --> 00:37:35,690
pointer potentially a null pointer then

757
00:37:33,890 --> 00:37:42,320
you really don't want to try that null

758
00:37:35,690 --> 00:37:45,710
pointer dereference just for the for as

759
00:37:42,320 --> 00:37:48,710
a way to save some time and similarly if

760
00:37:45,710 --> 00:37:51,440
if you could have a side-effect if the

761
00:37:48,710 --> 00:37:53,480
result of executing either branch could

762
00:37:51,440 --> 00:37:55,760
be to change some other part of the

763
00:37:53,480 --> 00:37:59,360
program state then you don't really want

764
00:37:55,760 --> 00:38:01,630
to do that either and so the conditional

765
00:37:59,360 --> 00:38:04,040
move only gets used then in this

766
00:38:01,630 --> 00:38:07,220
somewhat special case that you have two

767
00:38:04,040 --> 00:38:10,400
computations relatively easy to do safe

768
00:38:07,220 --> 00:38:12,290
to do no side-effects but that happens

769
00:38:10,400 --> 00:38:15,070
just often enough so this is actually a

770
00:38:12,290 --> 00:38:15,070
worthwhile thing

771
00:38:15,890 --> 00:38:22,020
okay so that gets us conditionals and

772
00:38:19,350 --> 00:38:27,680
now let's look at loops that sort of

773
00:38:22,020 --> 00:38:30,240
next step up in control structures and

774
00:38:27,680 --> 00:38:33,360
see actually has three different kinds

775
00:38:30,240 --> 00:38:35,100
of loops it has a a while loop which

776
00:38:33,360 --> 00:38:36,990
you're familiar with and a for loop

777
00:38:35,100 --> 00:38:39,330
which you're familiar with and it has a

778
00:38:36,990 --> 00:38:41,010
third one which in my whole life of

779
00:38:39,330 --> 00:38:43,620
writing and I've written a lot of C code

780
00:38:41,010 --> 00:38:46,800
in my life I've used this like about six

781
00:38:43,620 --> 00:38:48,420
times so but it turns out it's the

782
00:38:46,800 --> 00:38:51,030
simplest one to implement so we'll go

783
00:38:48,420 --> 00:38:53,910
ahead and do it so that the it's called

784
00:38:51,030 --> 00:38:57,150
the do-while loop and so the keyword is

785
00:38:53,910 --> 00:39:00,090
do and then there's some stuff you do

786
00:38:57,150 --> 00:39:02,730
that's the body of the do and then

787
00:39:00,090 --> 00:39:05,280
there's a test at the end that tells you

788
00:39:02,730 --> 00:39:07,560
whether to keep repeating this loop so

789
00:39:05,280 --> 00:39:09,480
it sort of flips the normal while loop

790
00:39:07,560 --> 00:39:11,400
you you have the conditional test at the

791
00:39:09,480 --> 00:39:16,920
front and here you have it at the end

792
00:39:11,400 --> 00:39:18,720
and so it turns out if we think in terms

793
00:39:16,920 --> 00:39:23,730
of go-to that's a pretty straightforward

794
00:39:18,720 --> 00:39:27,420
thing to replace this with a code that

795
00:39:23,730 --> 00:39:30,510
will do a test and if the test holds it

796
00:39:27,420 --> 00:39:32,580
will jump back and say okay a reacts

797
00:39:30,510 --> 00:39:37,440
acute that part of the program I was

798
00:39:32,580 --> 00:39:39,950
just in so it sets up a loop where you

799
00:39:37,440 --> 00:39:45,290
can think of it's literally a loop of

800
00:39:39,950 --> 00:39:45,290
control flow going round and round and

801
00:39:45,920 --> 00:39:50,550
by the way this is actually a semi

802
00:39:48,270 --> 00:39:53,460
useful function it's called pop count

803
00:39:50,550 --> 00:39:58,560
sometimes how many ones are there in a

804
00:39:53,460 --> 00:40:01,650
in a word of data in this case at 64-bit

805
00:39:58,560 --> 00:40:03,150
word there's been some generations of

806
00:40:01,650 --> 00:40:05,370
data web where you were required to

807
00:40:03,150 --> 00:40:10,410
write this function using all your

808
00:40:05,370 --> 00:40:13,920
favorite operations and with a fairly

809
00:40:10,410 --> 00:40:20,730
small limit on operations but we're not

810
00:40:13,920 --> 00:40:22,200
doing that today so here my point is you

811
00:40:20,730 --> 00:40:25,560
see that there's a fairly

812
00:40:22,200 --> 00:40:28,420
straightforward way of taking this

813
00:40:25,560 --> 00:40:30,910
particular loop and turning it into just

814
00:40:28,420 --> 00:40:32,650
combination of conditional that where

815
00:40:30,910 --> 00:40:35,530
you do is you jump back to where you

816
00:40:32,650 --> 00:40:36,220
were before and here's the actual code

817
00:40:35,530 --> 00:40:39,910
for it

818
00:40:36,220 --> 00:40:42,400
I won't go through all of it but you can

819
00:40:39,910 --> 00:40:44,530
believe from these annotations that it

820
00:40:42,400 --> 00:40:47,260
very closely follows the code here and

821
00:40:44,530 --> 00:40:53,710
the main thing to see is this jump if

822
00:40:47,260 --> 00:40:58,780
not equal to label l2 and that takes you

823
00:40:53,710 --> 00:41:03,400
back to here and so the general form of

824
00:40:58,780 --> 00:41:05,050
it then is you take a do and then this

825
00:41:03,400 --> 00:41:07,660
part that's called the body of the loop

826
00:41:05,050 --> 00:41:09,730
and this is the test and so now you set

827
00:41:07,660 --> 00:41:12,760
up some code where you can execute the

828
00:41:09,730 --> 00:41:18,070
body perform the test and if the test

829
00:41:12,760 --> 00:41:20,320
holds you go back to the loop so a while

830
00:41:18,070 --> 00:41:23,380
loop is really just what I could do loop

831
00:41:20,320 --> 00:41:25,060
a do while loop except that you move the

832
00:41:23,380 --> 00:41:27,760
test to the beginning and the only

833
00:41:25,060 --> 00:41:30,700
difference therefore is with a do loop

834
00:41:27,760 --> 00:41:32,440
you never you don't do the test it the

835
00:41:30,700 --> 00:41:35,940
first time through you're guaranteed to

836
00:41:32,440 --> 00:41:38,830
do it the first time no matter what

837
00:41:35,940 --> 00:41:41,560
while a while loop will explicitly test

838
00:41:38,830 --> 00:41:43,510
even at the very beginning and and skip

839
00:41:41,560 --> 00:41:47,200
over the loop if the condition doesn't

840
00:41:43,510 --> 00:41:48,970
hold so there's two ways to generate a

841
00:41:47,200 --> 00:41:51,130
code whether there's more than two ways

842
00:41:48,970 --> 00:41:53,320
to generate code for a while loop but

843
00:41:51,130 --> 00:41:56,230
you'll find GCC of two uses two

844
00:41:53,320 --> 00:41:59,800
different ways one is what we'll find

845
00:41:56,230 --> 00:42:01,600
when we use this optimization setting I

846
00:41:59,800 --> 00:42:05,860
talked about last time called minus

847
00:42:01,600 --> 00:42:08,470
capital o stands for optimized aji which

848
00:42:05,860 --> 00:42:12,430
means debug of course as you've already

849
00:42:08,470 --> 00:42:16,570
know there's some history to what the

850
00:42:12,430 --> 00:42:18,160
minus G flags means so and as I

851
00:42:16,570 --> 00:42:20,350
mentioned last time this turns out to be

852
00:42:18,160 --> 00:42:22,450
the perfect level of optimization for

853
00:42:20,350 --> 00:42:24,490
this course where you want to be able to

854
00:42:22,450 --> 00:42:27,370
look at machine code and understand it

855
00:42:24,490 --> 00:42:29,260
and how it relates to the C code because

856
00:42:27,370 --> 00:42:31,480
it does some sort of simple

857
00:42:29,260 --> 00:42:32,980
optimizations but it doesn't try to

858
00:42:31,480 --> 00:42:36,640
rewrite your whole program to make it

859
00:42:32,980 --> 00:42:38,230
run better whereas even with minus o 1

860
00:42:36,640 --> 00:42:41,170
which is the next level in the

861
00:42:38,230 --> 00:42:42,150
optimization you'll find sometimes it

862
00:42:41,170 --> 00:42:47,520
will do some pretty cool

863
00:42:42,150 --> 00:42:49,380
stuff but when you actually as a program

864
00:42:47,520 --> 00:42:51,990
developer as a software developer out

865
00:42:49,380 --> 00:42:54,000
there or you talk to companies and yes

866
00:42:51,990 --> 00:42:57,450
what optimization level do you use

867
00:42:54,000 --> 00:43:01,349
they'll probably say - OH - that's sort

868
00:42:57,450 --> 00:43:03,599
of the common point so usually there's

869
00:43:01,349 --> 00:43:05,490
higher levels optimization and we're

870
00:43:03,599 --> 00:43:08,220
purposely backing off from that to make

871
00:43:05,490 --> 00:43:12,059
this code easier to understand so

872
00:43:08,220 --> 00:43:14,720
anyways with the default optimization

873
00:43:12,059 --> 00:43:17,039
we're using for this course it does a

874
00:43:14,720 --> 00:43:19,470
transformation I call the jump to middle

875
00:43:17,039 --> 00:43:21,240
translation these are by the way my own

876
00:43:19,470 --> 00:43:27,319
names you won't find them in any other

877
00:43:21,240 --> 00:43:29,819
document but with the idea of it is

878
00:43:27,319 --> 00:43:32,279
imagine again I have a while loop of

879
00:43:29,819 --> 00:43:34,920
this form where there's a test in the

880
00:43:32,279 --> 00:43:36,690
body to execute well what out the

881
00:43:34,920 --> 00:43:39,270
problem I have to do compared to before

882
00:43:36,690 --> 00:43:42,089
is some I've to execute the test before

883
00:43:39,270 --> 00:43:44,250
I start the first iteration of the loop

884
00:43:42,089 --> 00:43:48,210
so the way I'll do it here is I'll just

885
00:43:44,250 --> 00:43:51,180
jump to the middle of the what was the

886
00:43:48,210 --> 00:43:53,789
old loop code to the test portion of

887
00:43:51,180 --> 00:43:56,339
that loop and then let that test

888
00:43:53,789 --> 00:44:01,859
determine whether I actually enter the

889
00:43:56,339 --> 00:44:08,460
loop itself and so this is an example of

890
00:44:01,859 --> 00:44:10,680
a go to a code version of my pop count

891
00:44:08,460 --> 00:44:15,059
function so I've written a pop count

892
00:44:10,680 --> 00:44:17,039
function using a while loop this time it

893
00:44:15,059 --> 00:44:18,599
turns out whether you do or a while loop

894
00:44:17,039 --> 00:44:24,660
you'll get the same result in this

895
00:44:18,599 --> 00:44:28,049
particular function and and you'll see

896
00:44:24,660 --> 00:44:31,200
the way it looks is it it jumped to the

897
00:44:28,049 --> 00:44:33,599
test portion of the code and and then if

898
00:44:31,200 --> 00:44:36,270
that holds it then actually starts in

899
00:44:33,599 --> 00:44:37,920
the first execution of the loop and then

900
00:44:36,270 --> 00:44:41,609
from there on it looks the same as the

901
00:44:37,920 --> 00:44:44,250
do-while loop it just does the what was

902
00:44:41,609 --> 00:44:46,640
in the loop does the test jumps back to

903
00:44:44,250 --> 00:44:46,640
the beginning

904
00:44:48,410 --> 00:44:52,800
although and then there's a second

905
00:44:50,579 --> 00:44:55,440
method which is in some ways more

906
00:44:52,800 --> 00:44:58,319
traditional and you'll find that if you

907
00:44:55,440 --> 00:45:01,530
use optimization one which is a fairly

908
00:44:58,319 --> 00:45:03,930
useful thing to do in practice so just

909
00:45:01,530 --> 00:45:05,550
to show you that instead of deciding

910
00:45:03,930 --> 00:45:09,930
which one I was going to show you I

911
00:45:05,550 --> 00:45:13,050
decided to show you both and the idea of

912
00:45:09,930 --> 00:45:14,970
that is to do it essentially to take a

913
00:45:13,050 --> 00:45:17,970
while loop and turn it into do-while

914
00:45:14,970 --> 00:45:21,569
loop but introducing a conditional

915
00:45:17,970 --> 00:45:24,720
beforehand that would essentially guard

916
00:45:21,569 --> 00:45:28,260
your entrance to the loop so you do an

917
00:45:24,720 --> 00:45:29,609
initial test and if that false then you

918
00:45:28,260 --> 00:45:32,250
skip over the loop all together

919
00:45:29,609 --> 00:45:36,690
otherwise it's performed like a do-while

920
00:45:32,250 --> 00:45:38,369
loop and so that has a fairly

921
00:45:36,690 --> 00:45:40,710
straightforward translation into code

922
00:45:38,369 --> 00:45:43,500
and that again it looks a little

923
00:45:40,710 --> 00:45:46,920
different from before that it has an

924
00:45:43,500 --> 00:45:49,609
initial test but then it looks like a

925
00:45:46,920 --> 00:45:49,609
do-while loop

926
00:45:50,920 --> 00:45:55,900
and so I won't show you the assembly

927
00:45:52,900 --> 00:45:59,339
versions of those but if you if you look

928
00:45:55,900 --> 00:46:02,010
at it actually the code is all in

929
00:45:59,339 --> 00:46:05,650
directories that are linked to your

930
00:46:02,010 --> 00:46:07,150
class directory to the class webpage so

931
00:46:05,650 --> 00:46:09,700
you can actually look at the code and

932
00:46:07,150 --> 00:46:13,510
you'll see that it follows exactly the

933
00:46:09,700 --> 00:46:18,880
way I'm describing it and then a third

934
00:46:13,510 --> 00:46:22,210
kind of loop is the for loop which in C

935
00:46:18,880 --> 00:46:23,950
is actually a very powerful very general

936
00:46:22,210 --> 00:46:27,660
type of thing and so it's very commonly

937
00:46:23,950 --> 00:46:30,519
used but you can see that the for loop

938
00:46:27,660 --> 00:46:34,180
has four components to it has an

939
00:46:30,519 --> 00:46:37,180
initialization as a test has a rule for

940
00:46:34,180 --> 00:46:39,279
doing an update in case as a way to

941
00:46:37,180 --> 00:46:41,440
continue the loop and then it has the

942
00:46:39,279 --> 00:46:45,400
body of the loop and so here's the

943
00:46:41,440 --> 00:46:48,160
version of my pop calc function where

944
00:46:45,400 --> 00:46:53,140
I'm just going through all the bits in

945
00:46:48,160 --> 00:46:55,980
the word extracting them out and adding

946
00:46:53,140 --> 00:47:00,789
them accumulating them to be the result

947
00:46:55,980 --> 00:47:04,000
so ripping apart this for you'll see

948
00:47:00,789 --> 00:47:06,309
that these four blocks of of the loop

949
00:47:04,000 --> 00:47:09,700
corresponds the initialization is to set

950
00:47:06,309 --> 00:47:13,900
equal to zero the test is to compare I

951
00:47:09,700 --> 00:47:18,549
to the word size which I've set here to

952
00:47:13,900 --> 00:47:21,309
be eight ton so however many bytes are

953
00:47:18,549 --> 00:47:24,549
in an int multiply that by 8 to get the

954
00:47:21,309 --> 00:47:26,950
word size and then the update is I plus

955
00:47:24,549 --> 00:47:31,500
plus and then the body is this stuff

956
00:47:26,950 --> 00:47:35,440
that's within the brackets here so I can

957
00:47:31,500 --> 00:47:40,059
think of that in general one one general

958
00:47:35,440 --> 00:47:44,170
way to think about a for loop and see is

959
00:47:40,059 --> 00:47:50,019
by this rule that will turn a for loop

960
00:47:44,170 --> 00:47:53,049
into a while loop and so what it says is

961
00:47:50,019 --> 00:47:57,009
I first do the initialization and then I

962
00:47:53,049 --> 00:48:01,210
do a loop where I I guard it with this

963
00:47:57,009 --> 00:48:04,240
test and then what I keep doing is

964
00:48:01,210 --> 00:48:04,880
executing the body and then performing

965
00:48:04,240 --> 00:48:07,130
whatever

966
00:48:04,880 --> 00:48:09,979
date there is and then continuing with

967
00:48:07,130 --> 00:48:13,489
the test so that sort of the semantics

968
00:48:09,979 --> 00:48:18,950
the the definition of the behavior of a

969
00:48:13,489 --> 00:48:22,940
for loop and see so I can take my

970
00:48:18,950 --> 00:48:26,089
different pieces of my for loop and say

971
00:48:22,940 --> 00:48:29,479
well okay I'll take that rule and use it

972
00:48:26,089 --> 00:48:31,789
to pack them in to form a while work and

973
00:48:29,479 --> 00:48:34,819
of course you know that you can sort of

974
00:48:31,789 --> 00:48:36,710
go between those two as somewhat a

975
00:48:34,819 --> 00:48:39,229
matter of taste whether a given loop

976
00:48:36,710 --> 00:48:48,170
should be written using a for loop or a

977
00:48:39,229 --> 00:48:51,759
while loop so one reason why it's

978
00:48:48,170 --> 00:48:53,930
actually useful to do the - oh one

979
00:48:51,759 --> 00:48:56,479
optimization I talked to you about is

980
00:48:53,930 --> 00:48:59,869
it's fairly common for the initial test

981
00:48:56,479 --> 00:49:03,049
to be trivially trivially true so for

982
00:48:59,869 --> 00:49:05,599
example in here if I equals zero and I'm

983
00:49:03,049 --> 00:49:07,930
comparing it to the word size which

984
00:49:05,599 --> 00:49:10,940
would typically be 32

985
00:49:07,930 --> 00:49:13,339
well that test is true that's a certain

986
00:49:10,940 --> 00:49:16,089
thing and so what you'll see is that the

987
00:49:13,339 --> 00:49:20,390
compiler can figure that out and just

988
00:49:16,089 --> 00:49:24,829
throw away this guarding code that would

989
00:49:20,390 --> 00:49:26,779
have to be there otherwise so so that

990
00:49:24,829 --> 00:49:28,579
that I believe is the main reason why

991
00:49:26,779 --> 00:49:31,880
this is the transformation that gets

992
00:49:28,579 --> 00:49:34,549
used to the oh one optimization level is

993
00:49:31,880 --> 00:49:37,269
that often times it doesn't need this

994
00:49:34,549 --> 00:49:37,269
initial test

995
00:49:39,839 --> 00:49:46,329
okay so now I'm going to finish up with

996
00:49:42,579 --> 00:49:51,309
what's in its immediately the loop stuff

997
00:49:46,329 --> 00:49:56,319
is sort of what you'd expect if you were

998
00:49:51,309 --> 00:49:58,480
to have to you know turn a C code into

999
00:49:56,319 --> 00:50:01,900
something very low-level where all you

1000
00:49:58,480 --> 00:50:04,450
could do is jumps and test well maybe

1001
00:50:01,900 --> 00:50:06,520
that's obvious but maybe not the switch

1002
00:50:04,450 --> 00:50:08,859
statement on the other hand is a totally

1003
00:50:06,520 --> 00:50:11,470
different beast and I want to show you

1004
00:50:08,859 --> 00:50:14,170
that because there's no counterpart in

1005
00:50:11,470 --> 00:50:19,540
normal C code of how you'd even think

1006
00:50:14,170 --> 00:50:21,880
about it and it's fairly a little bit

1007
00:50:19,540 --> 00:50:25,869
harder to do cipher and you're going to

1008
00:50:21,880 --> 00:50:28,030
have to do it in the bomb lab so here's

1009
00:50:25,869 --> 00:50:32,109
an example of a switch statement that is

1010
00:50:28,030 --> 00:50:34,000
of nothing about this is useful except

1011
00:50:32,109 --> 00:50:37,030
to demonstrate some principles of how to

1012
00:50:34,000 --> 00:50:40,630
turn a switch statement into a assembly

1013
00:50:37,030 --> 00:50:43,150
code so the point of it is as you know

1014
00:50:40,630 --> 00:50:47,170
and C you switch on a particular value

1015
00:50:43,150 --> 00:50:50,079
some type of integer value and then it

1016
00:50:47,170 --> 00:50:52,030
will match different cases where each of

1017
00:50:50,079 --> 00:50:58,200
these cases has to be some constant

1018
00:50:52,030 --> 00:51:01,720
numeric value constant integer value and

1019
00:50:58,200 --> 00:51:04,510
one of the weirdest features of C is if

1020
00:51:01,720 --> 00:51:07,540
you don't at the end of the case if you

1021
00:51:04,510 --> 00:51:10,900
don't explicitly say break it will do

1022
00:51:07,540 --> 00:51:14,530
what's known as falling through so in

1023
00:51:10,900 --> 00:51:18,190
this example here it will divide Y by Z

1024
00:51:14,530 --> 00:51:22,359
and then it will just glide right into

1025
00:51:18,190 --> 00:51:24,910
this statement that adds e to W this is

1026
00:51:22,359 --> 00:51:26,500
by the way like one of the worst design

1027
00:51:24,910 --> 00:51:28,150
decisions in the history of programming

1028
00:51:26,500 --> 00:51:30,960
languages

1029
00:51:28,150 --> 00:51:34,420
and it's been the cause of more and more

1030
00:51:30,960 --> 00:51:36,280
you know art break and bugs that nobody

1031
00:51:34,420 --> 00:51:39,100
could understand than any other single

1032
00:51:36,280 --> 00:51:40,840
part of the language and for some

1033
00:51:39,100 --> 00:51:43,030
bizarre reason they've kept it alive

1034
00:51:40,840 --> 00:51:46,210
even into Java and all these other

1035
00:51:43,030 --> 00:51:48,460
languages that fix a lot of the worst

1036
00:51:46,210 --> 00:51:50,530
parts you know the most dangerous parts

1037
00:51:48,460 --> 00:51:54,220
of C but somehow they kept this suture

1038
00:51:50,530 --> 00:51:57,400
and so just as a advice as a programmer

1039
00:51:54,220 --> 00:52:00,370
if you ever ever use this where you

1040
00:51:57,400 --> 00:52:03,250
purposely want it to go from one case to

1041
00:52:00,370 --> 00:52:06,280
another you should have to put a comment

1042
00:52:03,250 --> 00:52:08,440
in there to say trust me I really did

1043
00:52:06,280 --> 00:52:10,180
want it to fall through I know you

1044
00:52:08,440 --> 00:52:13,740
almost never want to do this but I do

1045
00:52:10,180 --> 00:52:16,300
here so that's a fairly common

1046
00:52:13,740 --> 00:52:19,660
convention I don't know how many times

1047
00:52:16,300 --> 00:52:23,760
I've had bugs that were because I forgot

1048
00:52:19,660 --> 00:52:28,090
to put brakes in anyways enough of my

1049
00:52:23,760 --> 00:52:32,020
editorializing the other feature you see

1050
00:52:28,090 --> 00:52:34,300
and see is you can insert a bunch up

1051
00:52:32,020 --> 00:52:36,460
multiple cases if you think of it that's

1052
00:52:34,300 --> 00:52:39,490
just a special case of the fall through

1053
00:52:36,460 --> 00:52:42,430
right the case five has nothing to do

1054
00:52:39,490 --> 00:52:44,110
but to fall through to six but so that's

1055
00:52:42,430 --> 00:52:46,990
the same general way and there's nothing

1056
00:52:44,110 --> 00:52:50,290
that's not that's not bad and it doesn't

1057
00:52:46,990 --> 00:52:52,150
require a comment and the other one is

1058
00:52:50,290 --> 00:52:55,480
that there's a default so if none of

1059
00:52:52,150 --> 00:52:57,970
these cases match either because X was 0

1060
00:52:55,480 --> 00:53:02,620
or smaller or X was a really big number

1061
00:52:57,970 --> 00:53:04,930
or in this case if X were 4 there's no

1062
00:53:02,620 --> 00:53:06,700
matching case and of course you also

1063
00:53:04,930 --> 00:53:09,910
know that these cases don't have to be

1064
00:53:06,700 --> 00:53:11,800
in any particular order is it so that's

1065
00:53:09,910 --> 00:53:17,610
all the sort of features of a case

1066
00:53:11,800 --> 00:53:21,220
statement of a switch statement turn up

1067
00:53:17,610 --> 00:53:23,200
so normally if you write this in sort of

1068
00:53:21,220 --> 00:53:25,420
if you were told

1069
00:53:23,200 --> 00:53:28,030
thou shalt not use switch statements

1070
00:53:25,420 --> 00:53:30,340
anymore what you'd probably do is write

1071
00:53:28,030 --> 00:53:35,830
this big long chain of if else if else

1072
00:53:30,340 --> 00:53:38,020
is else right and you'd expect that to

1073
00:53:35,830 --> 00:53:39,310
be the machine code but it's not and so

1074
00:53:38,020 --> 00:53:41,550
let me show you what the machine code

1075
00:53:39,310 --> 00:53:41,550
does

1076
00:53:41,650 --> 00:53:48,650
it's kind of a long story so think of

1077
00:53:45,680 --> 00:53:53,930
the general form of it as being some

1078
00:53:48,650 --> 00:53:56,300
blocks of code the entry points of which

1079
00:53:53,930 --> 00:53:57,980
are labeled by these case values and

1080
00:53:56,300 --> 00:53:59,540
then the blocks

1081
00:53:57,980 --> 00:54:00,940
you know string together in various

1082
00:53:59,540 --> 00:54:05,180
different ways and do various things

1083
00:54:00,940 --> 00:54:08,060
what I'm going to do is compile a code

1084
00:54:05,180 --> 00:54:11,530
for all of those blocks and store them

1085
00:54:08,060 --> 00:54:14,870
away in some part of memory load up

1086
00:54:11,530 --> 00:54:17,420
memory to contain these code blocks and

1087
00:54:14,870 --> 00:54:21,620
then I'm going to build a table and each

1088
00:54:17,420 --> 00:54:24,110
entry of this table describes the

1089
00:54:21,620 --> 00:54:27,860
starting location of one of these code

1090
00:54:24,110 --> 00:54:31,430
blocks and I'll put them in order of my

1091
00:54:27,860 --> 00:54:35,750
case labels if I have you know I want to

1092
00:54:31,430 --> 00:54:37,520
span a scope from well it's assumed zero

1093
00:54:35,750 --> 00:54:40,670
but typically that's not the case

1094
00:54:37,520 --> 00:54:44,030
zero up to n minus one

1095
00:54:40,670 --> 00:54:49,640
I'll have this table will have that many

1096
00:54:44,030 --> 00:54:53,720
entries of addresses to tell me where

1097
00:54:49,640 --> 00:54:55,300
these code blocks are located and then

1098
00:54:53,720 --> 00:55:00,950
I'm going to use this really cool

1099
00:54:55,300 --> 00:55:04,610
instruction which is a sort of like it's

1100
00:55:00,950 --> 00:55:07,730
as if you it's like a ray indexing so if

1101
00:55:04,610 --> 00:55:10,100
you think of a ray indexing it means you

1102
00:55:07,730 --> 00:55:15,320
can grab a value out of the middle of

1103
00:55:10,100 --> 00:55:17,720
some you know array some set of values

1104
00:55:15,320 --> 00:55:20,630
without having to step through them one

1105
00:55:17,720 --> 00:55:25,430
by one and it's the same idea here that

1106
00:55:20,630 --> 00:55:28,820
I will take my value and use that to

1107
00:55:25,430 --> 00:55:32,450
figure out directly where I should jump

1108
00:55:28,820 --> 00:55:34,930
to a block of code without having to

1109
00:55:32,450 --> 00:55:38,240
step through a bunch of other conditions

1110
00:55:34,930 --> 00:55:39,800
so and you can see the efficiency again

1111
00:55:38,240 --> 00:55:42,230
from that it's the difference between

1112
00:55:39,800 --> 00:55:46,460
sort of in one step knowing exactly

1113
00:55:42,230 --> 00:55:48,560
where you want to be versus stepping

1114
00:55:46,460 --> 00:55:53,350
through you know on average n over two

1115
00:55:48,560 --> 00:55:53,350
conditions to get to where I want to go

1116
00:55:53,400 --> 00:56:01,119
so let's look at this at the assembly

1117
00:55:56,259 --> 00:56:03,279
code level and it's a little bit of a

1118
00:56:01,119 --> 00:56:08,109
long thing because we have to build some

1119
00:56:03,279 --> 00:56:10,930
machinery around this so here's my

1120
00:56:08,109 --> 00:56:14,859
example I've got three arguments

1121
00:56:10,930 --> 00:56:16,930
so just remember I told you our VI and

1122
00:56:14,859 --> 00:56:22,630
our si for the first two arguments the

1123
00:56:16,930 --> 00:56:27,099
third argument is in RDX and here's the

1124
00:56:22,630 --> 00:56:30,130
beginning of the switch code it's just

1125
00:56:27,099 --> 00:56:33,180
making a copy of argument Z here for

1126
00:56:30,130 --> 00:56:38,019
some reason and then it's looking at

1127
00:56:33,180 --> 00:56:42,099
comparing X 2 6 and Y is 6 an important

1128
00:56:38,019 --> 00:56:45,720
number because you see 6 was the largest

1129
00:56:42,099 --> 00:56:45,720
value of any of my cases

1130
00:56:47,560 --> 00:56:54,700
and now it's using a jump instruction to

1131
00:56:51,460 --> 00:56:57,300
go to LA what we'll find is that tells

1132
00:56:54,700 --> 00:57:01,630
you what the default behavior should be

1133
00:56:57,300 --> 00:57:03,700
so it's sort of flushing away the the

1134
00:57:01,630 --> 00:57:07,420
default cases the cases that are either

1135
00:57:03,700 --> 00:57:08,830
X is too small or X is too large and I

1136
00:57:07,420 --> 00:57:12,490
should mention there's a clever trick

1137
00:57:08,830 --> 00:57:16,990
there if you look at J a means jump

1138
00:57:12,490 --> 00:57:20,250
above that's the unsigned comparison and

1139
00:57:16,990 --> 00:57:22,750
what it's making use of is our our

1140
00:57:20,250 --> 00:57:25,690
result that you remember that if a

1141
00:57:22,750 --> 00:57:28,150
number is negative if you think of it as

1142
00:57:25,690 --> 00:57:31,950
an unsigned value it becomes very large

1143
00:57:28,150 --> 00:57:36,760
positive value so by doing the J a

1144
00:57:31,950 --> 00:57:40,720
instead of AJ G I jump greater than I'm

1145
00:57:36,760 --> 00:57:49,620
doing jump above it's saying I want to

1146
00:57:40,720 --> 00:57:53,980
jump to the default if either X is

1147
00:57:49,620 --> 00:57:58,780
greater than 6 but also it will cause it

1148
00:57:53,980 --> 00:58:01,840
to jump if X is less than 0 got it so

1149
00:57:58,780 --> 00:58:03,550
it's a clever trick of unsigned versus

1150
00:58:01,840 --> 00:58:07,330
signed numbers is taking advantage of

1151
00:58:03,550 --> 00:58:09,310
and then the final part is this is the

1152
00:58:07,330 --> 00:58:14,680
real heart of the work this is my very

1153
00:58:09,310 --> 00:58:18,550
special go-to instruction that lets me

1154
00:58:14,680 --> 00:58:21,400
index into a table and extract out of

1155
00:58:18,550 --> 00:58:24,820
that an address and then jump to that

1156
00:58:21,400 --> 00:58:31,000
address so that's what lets me go

1157
00:58:24,820 --> 00:58:34,570
directly to some block of code based on

1158
00:58:31,000 --> 00:58:38,230
whether my values we'll see will be in

1159
00:58:34,570 --> 00:58:41,640
the range between 0 and 6 so there'll be

1160
00:58:38,230 --> 00:58:41,640
seven entries in that table

1161
00:58:44,289 --> 00:58:50,059
one one thing just to keep track up for

1162
00:58:47,359 --> 00:58:54,469
later you'll see that for some reason

1163
00:58:50,059 --> 00:58:57,130
the GCC said you know if I look at all

1164
00:58:54,469 --> 00:59:00,079
the code I actually don't use W as

1165
00:58:57,130 --> 00:59:01,999
initialized very much so I won't bother

1166
00:59:00,079 --> 00:59:04,430
doing it until somewhere within the code

1167
00:59:01,999 --> 00:59:10,130
blocks so just we'll have to keep track

1168
00:59:04,430 --> 00:59:13,309
of that here okay so this is the magic

1169
00:59:10,130 --> 00:59:17,839
instruction and now if we look and this

1170
00:59:13,309 --> 00:59:20,420
is all assembly code you'll see this is

1171
00:59:17,839 --> 00:59:23,029
the actual jump table and it's

1172
00:59:20,420 --> 00:59:24,920
constructed it specified in assembly

1173
00:59:23,029 --> 00:59:26,660
code it's the job of the assembler to

1174
00:59:24,920 --> 00:59:33,229
actually fill in the contents of this

1175
00:59:26,660 --> 00:59:36,859
table excuse me but what the assembly

1176
00:59:33,229 --> 00:59:39,259
code is telling the assembler is I need

1177
00:59:36,859 --> 00:59:42,979
a quad it's just a declaration to say I

1178
00:59:39,259 --> 00:59:46,459
need an 8 byte value here and that value

1179
00:59:42,979 --> 00:59:49,130
should match whatever address you decide

1180
00:59:46,459 --> 00:59:51,880
you later determine is the address of

1181
00:59:49,130 --> 00:59:54,890
where I'm going to stick a label 8 and

1182
00:59:51,880 --> 00:59:57,499
all these other ones and these are in

1183
00:59:54,890 --> 01:00:01,369
the order as I mentioned from x equals 0

1184
00:59:57,499 --> 01:00:05,179
through 6 and we can already see a few

1185
01:00:01,369 --> 01:00:08,859
cases that are interesting here let me

1186
01:00:05,179 --> 01:00:08,859
see if I've got a picture on this

1187
01:00:11,560 --> 01:00:14,560
yeah

1188
01:00:16,030 --> 01:00:22,990
so we can actually already see some of

1189
01:00:20,350 --> 01:00:24,970
the logic of this switch statement built

1190
01:00:22,990 --> 01:00:28,240
into the ordering of entries in this

1191
01:00:24,970 --> 01:00:31,000
table so in particular there is no case

1192
01:00:28,240 --> 01:00:34,870
zero here so case zero should be the

1193
01:00:31,000 --> 01:00:37,270
default there is no case for here the

1194
01:00:34,870 --> 01:00:39,340
case for should be the default and it

1195
01:00:37,270 --> 01:00:42,580
turns out and we already saw before the

1196
01:00:39,340 --> 01:00:44,290
J a instruction going to LA so L eight

1197
01:00:42,580 --> 01:00:47,650
is actually where the code block is

1198
01:00:44,290 --> 01:00:50,140
going to be for the default case so you

1199
01:00:47,650 --> 01:00:52,810
see basically you can think of this as

1200
01:00:50,140 --> 01:00:54,700
sometimes kept having holes in your

1201
01:00:52,810 --> 01:00:58,510
switch statement and we're going to just

1202
01:00:54,700 --> 01:01:05,320
fill in those holes by saying those

1203
01:00:58,510 --> 01:01:07,090
should go to the default case and here

1204
01:01:05,320 --> 01:01:10,030
you'll notice that they're not put in

1205
01:01:07,090 --> 01:01:17,850
any particularly logical order a one

1206
01:01:10,030 --> 01:01:21,760
thing you'll see again is L 7 is

1207
01:01:17,850 --> 01:01:24,850
repeated twice here because it covers

1208
01:01:21,760 --> 01:01:26,860
both cases five and six so again you'll

1209
01:01:24,850 --> 01:01:30,490
see that sort of doubling up is handled

1210
01:01:26,860 --> 01:01:32,710
automatically by the jump table we'll

1211
01:01:30,490 --> 01:01:35,280
give you the same address for multiple

1212
01:01:32,710 --> 01:01:35,280
different cases

1213
01:01:37,730 --> 01:01:42,080
okay and now the rest of it is to look

1214
01:01:40,400 --> 01:01:44,750
at the various code blocks and this by

1215
01:01:42,080 --> 01:01:47,990
the way I'm showing you I took a file

1216
01:01:44,750 --> 01:01:49,490
and I'm you know extracted little bits

1217
01:01:47,990 --> 01:01:53,000
of it but normally you're looking at

1218
01:01:49,490 --> 01:01:55,940
this whole listing in one big order so

1219
01:01:53,000 --> 01:01:57,650
now we can look at the individual code

1220
01:01:55,940 --> 01:01:59,630
blocks and see what's going on and

1221
01:01:57,650 --> 01:02:02,810
you'll see for example case one told me

1222
01:01:59,630 --> 01:02:05,360
to multiply two numbers and you'll see

1223
01:02:02,810 --> 01:02:06,770
that the break in the general it's just

1224
01:02:05,360 --> 01:02:11,420
going to be turned into return

1225
01:02:06,770 --> 01:02:14,120
instructions here because my function go

1226
01:02:11,420 --> 01:02:16,850
sorry to jump in code you see this

1227
01:02:14,120 --> 01:02:21,260
function did a switch statement and then

1228
01:02:16,850 --> 01:02:23,570
whatever whatever gets computed within

1229
01:02:21,260 --> 01:02:26,540
the switch statement gets returned as a

1230
01:02:23,570 --> 01:02:29,660
result of this so the compiler doesn't

1231
01:02:26,540 --> 01:02:32,210
actually come to a single point and say

1232
01:02:29,660 --> 01:02:35,240
okay everyone returned at this point it

1233
01:02:32,210 --> 01:02:38,290
just sticks returns directly in wherever

1234
01:02:35,240 --> 01:02:38,290
these breaks occur

1235
01:02:41,590 --> 01:02:50,510
so here it does a multiply and a return

1236
01:02:46,240 --> 01:02:52,730
here is actually a curious by the way

1237
01:02:50,510 --> 01:02:56,300
I'm always somewhat surprised by what

1238
01:02:52,730 --> 01:03:03,130
the compiler does it is never exactly

1239
01:02:56,300 --> 01:03:06,400
what you'd expect so in particular it it

1240
01:03:03,130 --> 01:03:12,500
patched together this fall through case

1241
01:03:06,400 --> 01:03:16,640
by two blocks of code and it had to do

1242
01:03:12,500 --> 01:03:20,510
these separately because remember W was

1243
01:03:16,640 --> 01:03:23,480
not set before I entered the these code

1244
01:03:20,510 --> 01:03:25,580
blocks it deferred setting that and here

1245
01:03:23,480 --> 01:03:30,320
I hit k3 and all of a sudden I actually

1246
01:03:25,580 --> 01:03:33,110
need whatever W was which was one and so

1247
01:03:30,320 --> 01:03:35,240
I guess the complier said well gosh I

1248
01:03:33,110 --> 01:03:37,910
guess I better set W to one here before

1249
01:03:35,240 --> 01:03:40,070
we continue so as a result it sort of

1250
01:03:37,910 --> 01:03:44,870
creates two code blocks but it jumps

1251
01:03:40,070 --> 01:03:51,260
from the second one this block into

1252
01:03:44,870 --> 01:03:54,650
partway through this other block here's

1253
01:03:51,260 --> 01:03:58,850
some actual yeah so here's the actual

1254
01:03:54,650 --> 01:04:00,800
code this is the block that does the

1255
01:03:58,850 --> 01:04:03,050
division it's very quickly how you have

1256
01:04:00,800 --> 01:04:05,750
to write division discovered in the book

1257
01:04:03,050 --> 01:04:08,960
I won't go through it here and then this

1258
01:04:05,750 --> 01:04:10,880
jump l6 is what I say go to merge and

1259
01:04:08,960 --> 01:04:13,550
the merge is where you're bringing these

1260
01:04:10,880 --> 01:04:18,710
two cases together here is where it's

1261
01:04:13,550 --> 01:04:21,260
setting L to one again it's making use

1262
01:04:18,710 --> 01:04:23,720
of this feature and that the upper 32

1263
01:04:21,260 --> 01:04:29,290
bits get set to zeros so I I can use a

1264
01:04:23,720 --> 01:04:29,290
move L instruction here yes question

1265
01:04:33,080 --> 01:04:39,960
did not have the code for what no the

1266
01:04:37,349 --> 01:04:42,950
jump table is sort of embedded let me

1267
01:04:39,960 --> 01:04:42,950
just show you real quick

1268
01:04:43,070 --> 01:04:51,300
no probably bad idea the jump if you

1269
01:04:48,810 --> 01:04:52,770
look at the the dot s file the assembly

1270
01:04:51,300 --> 01:04:55,020
code file Oh

1271
01:04:52,770 --> 01:04:57,990
all this stuff I'm showing you I've

1272
01:04:55,020 --> 01:04:58,440
extracted out of that but it's all in

1273
01:04:57,990 --> 01:05:01,170
there

1274
01:04:58,440 --> 01:05:03,840
and so that the compiler generated these

1275
01:05:01,170 --> 01:05:06,330
tables at least the sort of framework

1276
01:05:03,840 --> 01:05:09,359
for these tables the details of which

1277
01:05:06,330 --> 01:05:12,500
gets filled in by the assembler so it is

1278
01:05:09,359 --> 01:05:12,500
generated by the compiler

1279
01:05:16,089 --> 01:05:21,849
okay so that just shows you this one

1280
01:05:19,449 --> 01:05:25,089
example of handling a particular way to

1281
01:05:21,849 --> 01:05:29,019
handle the fall through case and then

1282
01:05:25,089 --> 01:05:31,599
the remaining ones again you'll see here

1283
01:05:29,019 --> 01:05:34,630
I got if I get to this case I need the

1284
01:05:31,599 --> 01:05:38,469
fact that W is initialized to 1 so we'll

1285
01:05:34,630 --> 01:05:40,989
do so here in the default case it just

1286
01:05:38,469 --> 01:05:43,569
designs to 2w and so that's all it does

1287
01:05:40,989 --> 01:05:45,369
so anyways I've actually shown you all

1288
01:05:43,569 --> 01:05:46,989
the code blocks but I've shown you one

1289
01:05:45,369 --> 01:05:49,479
by one but they're just all kind of

1290
01:05:46,989 --> 01:05:52,329
strong in the file and in no particular

1291
01:05:49,479 --> 01:06:03,699
order it doesn't matter what orders they

1292
01:05:52,329 --> 01:06:10,359
are yes yep so that was the reason for

1293
01:06:03,699 --> 01:06:13,839
that jump above at the beginning so this

1294
01:06:10,359 --> 01:06:18,609
jump above la was the way that if X was

1295
01:06:13,839 --> 01:06:21,039
either less than 0 or greater than 6 it

1296
01:06:18,609 --> 01:06:29,499
would go to the default case and it will

1297
01:06:21,039 --> 01:06:33,339
only do this indexing trick if the if X

1298
01:06:29,499 --> 01:06:35,640
is between 0 and 6 and that's typically

1299
01:06:33,339 --> 01:06:38,589
the way this works that you'll see that

1300
01:06:35,640 --> 01:06:40,150
whatever range of values you give it has

1301
01:06:38,589 --> 01:06:42,939
to figure out the smallest and the

1302
01:06:40,150 --> 01:06:45,219
largest one set up so it goes to the

1303
01:06:42,939 --> 01:06:47,679
default case if it's out of that range

1304
01:06:45,219 --> 01:06:52,390
and then set up a table for the values

1305
01:06:47,679 --> 01:06:55,900
within that range question like some

1306
01:06:52,390 --> 01:06:59,079
negative number - yeah does it try to do

1307
01:06:55,900 --> 01:07:00,969
the index into it with that X power so

1308
01:06:59,079 --> 01:07:04,029
the question I'm realize I should be

1309
01:07:00,969 --> 01:07:06,459
repeating questions the question is what

1310
01:07:04,029 --> 01:07:08,829
if it's a negative number for your case

1311
01:07:06,459 --> 01:07:11,619
which is perfectly legal it will

1312
01:07:08,829 --> 01:07:14,309
typically add a bias to it effectively

1313
01:07:11,619 --> 01:07:18,249
so that whatever your lowest value was

1314
01:07:14,309 --> 01:07:20,900
become 0 or it'll do something like that

1315
01:07:18,249 --> 01:07:29,150
to avoid having to do negative indexing

1316
01:07:20,900 --> 01:07:33,229
another question is he yes yeah so you

1317
01:07:29,150 --> 01:07:34,880
can go from zero to a million yeah they

1318
01:07:33,229 --> 01:07:36,859
could be you could go zero in a million

1319
01:07:34,880 --> 01:07:38,660
and nothing in between right so you'd

1320
01:07:36,859 --> 01:07:41,779
have two cases you really don't want a

1321
01:07:38,660 --> 01:07:45,440
million entry table for just two cases

1322
01:07:41,779 --> 01:07:46,849
so it will turn it into a felt code but

1323
01:07:45,440 --> 01:07:48,160
the clever thing that we'll do if you

1324
01:07:46,849 --> 01:07:50,869
know binary search

1325
01:07:48,160 --> 01:07:52,460
they relies on the fact that it knows in

1326
01:07:50,869 --> 01:07:55,569
advance all the values and it will

1327
01:07:52,460 --> 01:07:58,759
actually set up a tree of it Phelps's so

1328
01:07:55,569 --> 01:08:00,319
really it will do it if you want to

1329
01:07:58,759 --> 01:08:03,200
thank algorithmically it does it with a

1330
01:08:00,319 --> 01:08:09,819
logarithmic number of tests rather than

1331
01:08:03,200 --> 01:08:09,819
a linear number of test question

1332
01:08:15,239 --> 01:08:22,130
oh yeah

1333
01:08:18,319 --> 01:08:24,799
yeah so so there's two inches that one

1334
01:08:22,130 --> 01:08:26,839
is this which I actually answered both

1335
01:08:24,799 --> 01:08:28,520
now if one is what if there's some

1336
01:08:26,839 --> 01:08:32,960
negative values or what if the lowest

1337
01:08:28,520 --> 01:08:36,200
number is 5700 right well what it will

1338
01:08:32,960 --> 01:08:38,810
typically do is put some bias and you'll

1339
01:08:36,200 --> 01:08:42,319
add or subtract some value so that the

1340
01:08:38,810 --> 01:08:43,850
first case is at value 0 so that's where

1341
01:08:42,319 --> 01:08:46,040
it handles you know ones that are just

1342
01:08:43,850 --> 01:08:48,500
completely out of range and the other is

1343
01:08:46,040 --> 01:08:51,470
what if it's a really big spread of

1344
01:08:48,500 --> 01:08:53,839
values and relatively sparse how much

1345
01:08:51,470 --> 01:08:56,930
you're using it and there it will revert

1346
01:08:53,839 --> 01:08:59,089
to FL code and the compiler has its own

1347
01:08:56,930 --> 01:09:01,130
rules about how it does these things you

1348
01:08:59,089 --> 01:09:03,589
can sort of run experiments and try and

1349
01:09:01,130 --> 01:09:05,089
reverse engineer because you know these

1350
01:09:03,589 --> 01:09:08,080
are all valid questions by the way

1351
01:09:05,089 --> 01:09:08,080
appreciative

1352
01:09:11,069 --> 01:09:16,950
okay so we're going to get through this

1353
01:09:14,680 --> 01:09:16,950
Oh

1354
01:09:17,290 --> 01:09:26,819
so anyways and like I said I think in my

1355
01:09:23,259 --> 01:09:30,850
own experience you know understanding

1356
01:09:26,819 --> 01:09:33,430
the conditionals you can kind of figure

1357
01:09:30,850 --> 01:09:35,890
that out it's intuitive sort of feels

1358
01:09:33,430 --> 01:09:40,660
like what you'd expect a program to do

1359
01:09:35,890 --> 01:09:43,089
whereas a switch statement is maybe

1360
01:09:40,660 --> 01:09:49,270
unexpected it's a way to do something

1361
01:09:43,089 --> 01:09:50,799
that is not totally obvious but then

1362
01:09:49,270 --> 01:09:53,380
when you think about it and appreciate

1363
01:09:50,799 --> 01:09:55,270
it it's actually it gives you a good

1364
01:09:53,380 --> 01:09:57,430
performance boost you know again

1365
01:09:55,270 --> 01:10:02,440
algorithmically this jump table makes it

1366
01:09:57,430 --> 01:10:04,420
so it's a constant time a constant

1367
01:10:02,440 --> 01:10:07,120
number of steps to get to where you need

1368
01:10:04,420 --> 01:10:10,719
to in the switch statement if you just

1369
01:10:07,120 --> 01:10:12,130
get it linearly one after the other then

1370
01:10:10,719 --> 01:10:14,160
that would be linear time and you'd

1371
01:10:12,130 --> 01:10:17,020
expect on you know if everything's

1372
01:10:14,160 --> 01:10:20,830
uniform and average about how you'd be

1373
01:10:17,020 --> 01:10:23,050
about halfway through on average if

1374
01:10:20,830 --> 01:10:25,719
you're if it's sparse you'll see it will

1375
01:10:23,050 --> 01:10:28,480
set up a tree of conditionals so it can

1376
01:10:25,719 --> 01:10:30,850
do in logarithmic time so no matter what

1377
01:10:28,480 --> 01:10:32,739
it will be better than just what you get

1378
01:10:30,850 --> 01:10:35,460
in the obvious form of your felts I saw

1379
01:10:32,739 --> 01:10:35,460
a question over here

1380
01:10:36,849 --> 01:10:43,190
well the good news is I don't set up the

1381
01:10:40,909 --> 01:10:46,429
jump tree the compiler sets up to jump

1382
01:10:43,190 --> 01:10:48,289
tree right but if you're asking if I

1383
01:10:46,429 --> 01:10:50,530
were a compiler how would I set up the

1384
01:10:48,289 --> 01:10:53,210
jump tree right which is a good question

1385
01:10:50,530 --> 01:10:55,039
if you know binary search right that

1386
01:10:53,210 --> 01:10:57,050
you've got a range of values and you

1387
01:10:55,039 --> 01:11:00,199
pick you compare it to the middle value

1388
01:10:57,050 --> 01:11:03,739
and it's either less or it's greater or

1389
01:11:00,199 --> 01:11:05,929
equal and if it's less than you sort of

1390
01:11:03,739 --> 01:11:07,639
recursively handle the one set and if

1391
01:11:05,929 --> 01:11:10,340
it's greater the other hat that's

1392
01:11:07,639 --> 01:11:12,050
exactly what these trees look like so

1393
01:11:10,340 --> 01:11:13,429
they're balanced binary trees and

1394
01:11:12,050 --> 01:11:15,829
they're taking advantage of the fact

1395
01:11:13,429 --> 01:11:19,039
that in --see which is not true in all

1396
01:11:15,829 --> 01:11:21,170
languages that all the the case

1397
01:11:19,039 --> 01:11:24,949
conditions you're looking at our

1398
01:11:21,170 --> 01:11:26,749
constants they're determined when the

1399
01:11:24,949 --> 01:11:29,929
compiler is doing the compilation those

1400
01:11:26,749 --> 01:11:31,849
are constant values so it can can sort

1401
01:11:29,929 --> 01:11:33,469
them figure out how many there are what

1402
01:11:31,849 --> 01:11:35,989
range of values so there are decide

1403
01:11:33,469 --> 01:11:41,809
which version to do this and generate

1404
01:11:35,989 --> 01:11:44,210
the code other questions so these are

1405
01:11:41,809 --> 01:11:47,380
all good and it's a very good question

1406
01:11:44,210 --> 01:11:49,760
so and you're starting to think about

1407
01:11:47,380 --> 01:11:51,079
you know which is the way that computer

1408
01:11:49,760 --> 01:11:52,929
scientist should think is how do you

1409
01:11:51,079 --> 01:11:55,670
take some idea I've seen one case of

1410
01:11:52,929 --> 01:11:58,159
well how do I handle condition X and

1411
01:11:55,670 --> 01:12:01,670
condition Y and you know what happens if

1412
01:11:58,159 --> 01:12:03,920
this that's exactly what we do we sort

1413
01:12:01,670 --> 01:12:06,320
of we're never happy with a simple

1414
01:12:03,920 --> 01:12:07,849
explanation we want to understand how we

1415
01:12:06,320 --> 01:12:11,019
could actually implement it as a program

1416
01:12:07,849 --> 01:12:11,019
if we ever had to do so

1417
01:12:12,730 --> 01:12:20,570
so and so just in general that the main

1418
01:12:19,190 --> 01:12:24,950
thing you see is that there's a fairly

1419
01:12:20,570 --> 01:12:27,170
limited in bag of tricks for which the

1420
01:12:24,950 --> 01:12:31,000
program implements conditional

1421
01:12:27,170 --> 01:12:35,990
constructs you've seen basically three

1422
01:12:31,000 --> 01:12:38,600
one is to use conditional jumps go to

1423
01:12:35,990 --> 01:12:42,020
different parts of the code another to

1424
01:12:38,600 --> 01:12:45,170
use conditional moods and the third is

1425
01:12:42,020 --> 01:12:48,830
to use this jump table idea and those

1426
01:12:45,170 --> 01:12:52,400
are really that puts a little bit to do

1427
01:12:48,830 --> 01:12:55,370
of procedures consider all there is and

1428
01:12:52,400 --> 01:12:58,910
all the other stuff you see in a program

1429
01:12:55,370 --> 01:13:01,960
that sort of changes the flow of

1430
01:12:58,910 --> 01:13:05,990
execution or what gets executed are all

1431
01:13:01,960 --> 01:13:07,760
built out of those basic primitives and

1432
01:13:05,990 --> 01:13:11,690
that's generally true that what we see

1433
01:13:07,760 --> 01:13:13,760
is when you go from C codes of machine

1434
01:13:11,690 --> 01:13:17,120
code you often have to kind of piece

1435
01:13:13,760 --> 01:13:21,130
together various low-level instructions

1436
01:13:17,120 --> 01:13:21,130
to implement some higher-level construct

1437
01:13:21,710 --> 01:13:28,130
and so we've seen these all in different

1438
01:13:24,500 --> 01:13:30,710
form stone and next time then we'll talk

1439
01:13:28,130 --> 01:13:33,190
about procedures and that as you can

1440
01:13:30,710 --> 01:13:37,250
imagine a fairly major topic because it

1441
01:13:33,190 --> 01:13:39,700
is worth one entire procedure okay very

1442
01:13:37,250 --> 01:13:39,700
good thank you

